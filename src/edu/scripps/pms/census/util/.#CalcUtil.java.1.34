package edu.scripps.pms.census.util;

//import com.sun.jndi.ldap.PersistentSearchControl;
import java.io.*;
import gnu.trove.TDoubleArrayList;
import java.io.RandomAccessFile;
import edu.scripps.pms.census.hash.IndexedFile;
import edu.scripps.pms.census.CensusConstants;
import edu.scripps.pms.census.conf.*;
import edu.scripps.pms.census.model.*;
import edu.scripps.pms.census.model.mrm.*;
import gnu.trove.TIntLongHashMap;
import gnu.trove.TIntDoubleHashMap;
import edu.scripps.pms.census.exception.PrecursorNotFoundException;
import edu.scripps.pms.census.exception.CensusIndexOutOfBoundException;

import java.util.*;
import java.text.*;
import edu.scripps.pms.util.io.*;
import edu.scripps.pms.util.spectrum.*;
import edu.scripps.pms.util.MZXmlHandler;
import gnu.trove.TDoubleDoubleHashMap;

/**
 * <p>Title: </p>
 *
 * <p>Description: </p>
 *
 * <p>Copyright: Copyright (c) 2004</p>
 *
 * <p>Company: Yates Lab</p>
 *
 * @author Robin Park
 * @version 1.0
 */
public class CalcUtil
{
    private static final char SPACE = ' ';
    private static int ION_START_INDEX = 3;
    private static final char CARRIAGE_RETURN = '\n';
    private static final char WINDOW_CR = '\r';
    private static final char DOT = '.';
    private static TIntDoubleHashMap precursorMap;
    private static double samplePrecursor;
    private static double refPrecursor;
    private static int chargeState;

    private static double[] massArr = null;
    private static double[] intArr = null;    
    private static boolean hasChargeCol;
    private static double massTolerance;

    private static float steepRatioThreshold;
    private static int[][][] pathArray;
    private static Hashtable<String, IndexedFile> ht;

    private static String pathFileName;
    
    private static boolean align;
    private static Configuration conf;

    private static DecimalFormat formatter = new DecimalFormat("0.0000");
    
    public static void findMRMPeakScan(
            List<MRMPeptideModel> pepList, 
            String[] flist,
            Hashtable<String, IndexedFile> ht
    ) 
        throws PrecursorNotFoundException, IOException, CensusIndexOutOfBoundException, Exception
    {
        for(Iterator<MRMPeptideModel> pitr=pepList.iterator(); pitr.hasNext(); )
        {
            MRMPeptideModel model = pitr.next();
            IndexedFile iFile = ht.get(conf.getFilePath() + model.getFileName());
            double[] rtArr = iFile.getRtArr();
            double mass = model.getParentMass();                                       

            RandomAccessFile rfile = iFile.getFile();
            TIntLongHashMap indexMap = iFile.getMsIndex();
            TDoubleDoubleHashMap rtPrecursorMap = iFile.getRtPrecursorMap();
            //long startPos = indexMap.get( Integer.parseInt(model.getScanNum()) );

            int keyIndex = Arrays.binarySearch(rtArr, Double.parseDouble(model.getRt()));
            int startKeyIndex = Arrays.binarySearch(rtArr, Double.parseDouble(model.getRt()) - model.getRtTolerance());
            int endKeyIndex = Arrays.binarySearch(rtArr, Double.parseDouble(model.getRt()) + model.getRtTolerance());
            keyIndex = fixIndex(keyIndex, rtArr.length);
            model.setKeyIndex(keyIndex);
            startKeyIndex = fixIndex(startKeyIndex, rtArr.length);
            endKeyIndex = fixIndex(endKeyIndex, rtArr.length);

            long maxInt=0;
            double maxRt=0;
            
            
            double[][] bs = model.getBionArr();
            double[][] ys = model.getYionArr();
            
            
            //double[][] br = model.getBionRef();
            //double[][] yr = model.getYionRef();

            /*
            for(int l=0;l<bs.length;l++)
            {
                for(int m=0;m<bs[l].length;m++)
            }
            */
                
            for(int j=startKeyIndex;j<=endKeyIndex;j++)
            {

                double pcursor = rtPrecursorMap.get(rtArr[j]);
                
                if(pcursor != model.getParentMass())
                    continue;
                double[] result = readSpectrumByRt(rtArr, j, iFile, model); //.getBionSample(), model.getBionRef(), model.getYionSample(), model.getYionRef()); 
                if(maxInt<result[1])
                {
                    maxInt = (long)result[1];
                    maxRt = result[0];                        
                }
            }

            keyIndex = Arrays.binarySearch(rtArr, maxRt);
            keyIndex = fixIndex(keyIndex, rtArr.length);
            model.setKeyIndex(keyIndex);            
            model.setStartRt( maxRt );
            
        }          
    }
    
    public static int fixIndex(int i, int length)
    {
	if(i<0) //Cannot find index
	    i=-(++i); //Math.abs(++keyIndex);

	if(i>=length)
	    i--;

	return i;
    }
    
    public static String calculateMRMNoId(
        List<MRMPeptideModel> pepList,
        String[] flist,
        //double sPrecursor, double rPrecursor,
        Configuration con,
        Hashtable<String, IndexedFile> ht
        ) throws PrecursorNotFoundException, IOException, CensusIndexOutOfBoundException, Exception
            
    {
        conf = con;
        int maxWindow = conf.getMaxWindow();
        int margin = conf.getMargin();
        
       // double[][] result = new double[maxWindow*2+1 + margin*2][4*bioSample.length+3]; //scan #, sample intensity, ref intensity
        
        findMRMPeakScan(pepList, flist, ht);
       
	StringBuffer sb = new StringBuffer();

        for(Iterator<MRMPeptideModel> pitr=pepList.iterator(); pitr.hasNext(); )
        {
            MRMPeptideModel model = pitr.next();
            IndexedFile iFile = ht.get(conf.getFilePath() + model.getFileName());
	    sb.append(peakFindingMRM(model, conf, iFile) );
	    sb.append("&");
        }

        

        /*
            precursorMap = iFile.getPrecursorMap();

            int margin = conf.getMargin();
            int steepArea = conf.getSteepArea();
            steepRatioThreshold = conf.getSteepRatioThreshold();
            int maxWindow = conf.getMaxWindow();

            double[][] result = new double[maxWindow*2+1 + margin*2][4*bioSample.length+3]; //scan #, sample intensity, ref intensity

         *
         *
    */
        
        /*
            IndexedFile iFile = ht.get(conf.getFilePath() + model.getFileName());
                
            precursorMap = iFile.getPrecursorMap();

            int[] keys = iFile.getKeys();

        
        
            SpectrumModel sModel = new SpectrumModel();
            sModel.setHighRes(false);
            sModel.setKeys(keys);
            sModel.setIndex(index);
            sModel.setIFile(iFile);
            sModel.setFile(file);
            sModel.setBioSample(bioSample);
            sModel.setYioSample(yioSample);
            sModel.setBioRef(bioRef);
            sModel.setYioRef(yioRef);


            return peakFindingMSMS(sModel, range, conf, keyIndex); 

            */
        
        return sb.toString();
    }
    
    
    //MSMS Labeled Low res
    public static String calculateMS2Mass (            
            IndexedFile iFile, 
            SpecRange range,
            int keyIndex,
            ///int diff,
            double[][] bioSample, double[][] bioRef,
            double[][] yioSample, double[][] yioRef,
            //double sPrecursor, double rPrecursor,
            Configuration conf, int cState 
            ) throws PrecursorNotFoundException, IOException, CensusIndexOutOfBoundException, Exception
    {
         
        TIntLongHashMap index = iFile.getMsIndex();
        precursorMap = iFile.getPrecursorMap();

        int[] keys = iFile.getKeys();
        RandomAccessFile file = iFile.getFile();

	//this condition is not default
        if(conf.getMsmsFragType()<0 || conf.getMsmsFragType() == conf.AUTOMATIC_FRAGMENT_ION ) //data independent
	{
            //hasChargeCol = conf.isChargeColumn();
            //massTolerance = conf.getMassTolerance();
            //int numIsoWindows = conf.getNumOfIsolationWindow();
            //samplePrecursor = sPrecursor;
            //refPrecursor = rPrecursor;
            //chargeState = cState;
            precursorMap = iFile.getPrecursorMap();

            int margin = conf.getMargin();
            int steepArea = conf.getSteepArea();
            steepRatioThreshold = conf.getSteepRatioThreshold();
            int maxWindow = conf.getMaxWindow();

            double[][] result = new double[maxWindow*2+1 + margin*2][4*bioSample.length+3]; //scan #, sample intensity, ref intensity

            SpectrumModel sModel = new SpectrumModel();
            sModel.setHighRes(false);
            sModel.setKeys(keys);
            sModel.setIndex(index);
            sModel.setIFile(iFile);
            sModel.setFile(file);
            sModel.setBioSample(bioSample);
            sModel.setYioSample(yioSample);
            sModel.setBioRef(bioRef);
            sModel.setYioRef(yioRef);
            //sModel.setDiff(diff);

            return peakFindingMSMS(sModel, range, conf, keyIndex); 
	}
	//this option is default
        else if(conf.getMsmsFragType() == conf.SPECIFIC_FRAGMENT_ION)
	{
            //there are two different types.  1. single spectrum 2. multiple spectra

            List massList = conf.getMsmsMassArr();
//System.out.println("aaaaaa" + mItr.next());

            if(conf.getMsmsSpectrumNum() == conf.MSMS_SINGLE_SPECTRUM)  //single spectrum.  No peak finding
            {
                double[] result = readSpectrumSpecificPeaks(
                        keyIndex, 
                        iFile, 
                        massList,
                        conf.getMsmsSpecificTolerance()
                        );
                
                StringBuffer sb = new StringBuffer();
                
                for(Iterator<String> mItr=massList.iterator(); mItr.hasNext(); )
                {

                    sb.append( mItr.next() ).append(" ");
                }
                
                sb.setCharAt(sb.length()-1, ',');
                
                for(double d : result)
                {
                    sb.append((long)d).append(" ");
                }
                
                return sb.toString();
                
            } else if(conf.getMsmsSpectrumNum() == conf.MSMS_MULTIPLE_SPECTRA) //multiple spectra.  Peak finding
            {                
                int margin = conf.getMargin();
                int steepArea = conf.getSteepArea();
                steepRatioThreshold = conf.getSteepRatioThreshold();
                int maxWindow = conf.getMaxWindow();

                double[][] result = new double[maxWindow*2+1 + margin*2][massList.size()+3]; //scan #, sample intensity, ref intensity

                SpectrumModel sModel = new SpectrumModel();
                sModel.setHighRes(false);
                sModel.setKeys(keys);
                sModel.setIndex(index);
                sModel.setIFile(iFile);
                sModel.setFile(file);
                sModel.setMsmsSpecificMassList(massList);
            
                return peakFindingMSMSMultipleSpecific(sModel, range, conf, keyIndex); 
            }
                
	}
        
        return null;

    }

    private static String buildDDResult(int peakStart, int peakEnd, int leftIndex, int rightIndex, double[][] result)
    {
        StringBuffer sb = new StringBuffer();
        sb.append("P ").append((long)result[peakStart][0]).append(" ").append((long)result[peakEnd][0]).append(";");
          
        for(int i=leftIndex+1;i<rightIndex-1;i++)
	{
            for(int j=0;j<result[i].length-2;j++)
            {
                sb.append((long)result[i][j]).append(" ");
            }
            
            sb.append((double)result[i][result[i].length-2]).append(" ");
            sb.append((double)result[i][result[i].length-1]).append(";");
            
            //sb.append((int)result[i][0]).append(" ").append((long)result[i][1]).append(" ").append((long)result[i][2]).append(";");
	}

	return sb.toString();
    }

    //build non labeling result
    //expSize : number of experiments
    private static String buildNLResult(int peakStart, int peakEnd, int leftIndex, int rightIndex, double[][] result, int expSize)
    {
	return buildNLResult(peakStart, peakEnd, leftIndex, rightIndex, result, -1, expSize);
    }
    
    private static String buildNLResult(int peakStart, int peakEnd, int leftIndex, int rightIndex, double[][] result, int ionLength, int expSize)
    {
        StringBuffer resultBuffer = new StringBuffer();
        resultBuffer.append("P ").append((int)result[peakStart][0]).append(" ").append((int)result[peakEnd][0]).append(";");

        if(conf.getQuantLevel() == 1)
        {
            if(leftIndex<0) leftIndex=0;
            if(rightIndex>=result.length) rightIndex = result.length-1;

            for(int i=leftIndex+1;i<rightIndex-1;i++)
            {
                for(int j=0;j<result[i].length;j++)
                {
                    resultBuffer.append((int)result[i][j]).append(" ");

                      //System.out.print(result[i][j] + "\t");
                }

                //System.out.println(result[231].length + "\t" + result[i].length + " \t" + i);
      //          resultBuffer.append((int)result[i][0]).append(" "); //spec num
        //        resultBuffer.append((long)result[i][1]).append(" "); //sample intensity
          //      resultBuffer.append((long)result[i][2]).append(","); //ref intensity

                resultBuffer.append(";");
            }      

            
        } else if(conf.getQuantLevel() == 2)
        {            
            int ionMaxIndex = ionLength-1;            
            
            if(leftIndex<0) leftIndex=0;
            if(rightIndex>=result.length) rightIndex = result.length-1;

            for(int i=leftIndex+1;i<rightIndex-1;i++)
            {
                for(int j=0;j<expSize-1;j++)
		{
		    resultBuffer.append((long)result[i][j]).append(" ");
//		    System.out.println(j);
		}

		resultBuffer.append((long)result[i][expSize-1]).append(",");
//		    System.out.println(expSize-1);

                for(int j=expSize;j<2*expSize-1;j++)
		{
		    resultBuffer.append((long)result[i][j]).append(" ");
//		    System.out.println(j);
		}

		resultBuffer.append((long)result[i][2*expSize-1]).append(",");
//		System.out.println(2*expSize-1);

                for(int j=0;j<expSize*2;j++)
                {
                    for(int k=6;k<ionLength+6;k++)
                    {
                        resultBuffer.append(result[i][k+j*(ionMaxIndex+1)]).append(" ");
//			System.out.println(k+j*(ionMaxIndex+1));
                    }

                    resultBuffer.append(result[i][ionLength+6]).append(",");
//			System.out.println("==>>" + (ionMaxIndex+6));
                    
                }
               
                resultBuffer.setCharAt(resultBuffer.length()-1, ';');
               
//	       System.out.println(resultBuffer.toString());
  //             System.exit(0);
      
            }        
    
        }
	
        return resultBuffer.toString();
        
    }
    
    private static String buildDIResult(int peakStart, int peakEnd, int leftIndex, int rightIndex, double[][] result, int ionLength)
    {
        StringBuffer resultBuffer = new StringBuffer();
        resultBuffer.append("P ").append((int)result[peakStart][0]).append(" ").append((int)result[peakEnd][0]).append(";");

        int ionMaxIndex = ionLength-1;

	if(leftIndex<0) leftIndex=0;
	if(rightIndex>=result.length) rightIndex = result.length-1;
	   
        for(int i=leftIndex+1;i<rightIndex-1;i++)
        {
            resultBuffer.append((int)result[i][0]).append(" "); //spec num
            resultBuffer.append((long)result[i][1]).append(" "); //sample intensity
            resultBuffer.append((long)result[i][2]).append(","); //ref intensity

            for(int j=0;j<3;j++) //3 ions b_sample, b_ref, y_sample
            {
                for(int k=3;k<ionMaxIndex+3;k++)
                {
                    resultBuffer.append(result[i][k+j*(ionMaxIndex+1)]).append(" ");
                }

                resultBuffer.append(result[i][3+ionMaxIndex + j*(ionMaxIndex+1)]).append(",");
            }

            //y_ref ion. do this separately due to delimitation
            for(int k=3;k<ionMaxIndex+3;k++)
            {
                resultBuffer.append(result[i][k+ionMaxIndex*3+3]).append(" ");
            }

            resultBuffer.append(result[i][6+ionMaxIndex + ionMaxIndex*3]).append(";");
        }        

        return resultBuffer.toString();
    }

    private static String buildMRMResult(int peakStart, int peakEnd, int leftIndex, int rightIndex, double[][] result, int ionLength)
    {
        StringBuffer resultBuffer = new StringBuffer();
        resultBuffer.append("P ").append(result[peakStart][0]).append(" ").append(result[peakEnd][0]).append(";");

        int ionMaxIndex = ionLength-1;

	if(leftIndex<0) leftIndex=0;
	if(rightIndex>=result.length) rightIndex = result.length-1;
	   
        for(int i=leftIndex+1;i<rightIndex-1;i++)
        {
            resultBuffer.append((double)result[i][0]).append(" "); //spec num
            resultBuffer.append((long)result[i][1]).append(" "); //sample intensity
            resultBuffer.append((long)result[i][2]).append(","); //ref intensity

            for(int j=0;j<3;j++) //3 ions b_sample, b_ref, y_sample
            {
                for(int k=3;k<ionMaxIndex+3;k++)
                {
	//	    System.out.println(i + " " + result.length + " " + (k+j*(ionMaxIndex+1)) + " " + result[i].length);
                    resultBuffer.append(result[i][k+j*(ionMaxIndex+1)]).append(" ");
                }

                resultBuffer.append(result[i][3+ionMaxIndex + j*(ionMaxIndex+1)]).append(",");
            }

            //y_ref ion. do this separately due to delimitation
            for(int k=3;k<ionMaxIndex+3;k++)
            {
                resultBuffer.append(result[i][k+ionMaxIndex*3+3]).append(" ");
            }

            resultBuffer.append(result[i][6+ionMaxIndex + ionMaxIndex*3]).append(";");
        }        

        return resultBuffer.toString();
    }

    public static IrisDataModel readSpectrumPeaks(IndexedFile iFile, int keyIndex, int[] keys) throws IOException
    {

        double[] result = new double[2];
	RandomAccessFile rfile = iFile.getFile();
	TIntLongHashMap indexMap = iFile.getMsIndex();

	long startPos = indexMap.get(keys[keyIndex]);

        int byteSize=-1;
        byte[] bytes;

        char ch;
        int pos;

        rfile.seek(startPos);

	if( (keyIndex+1)>=keys.length )
	    byteSize = (int)(rfile.length() - startPos); 

	if(indexMap.get(keys[keyIndex+1])>0)
	    byteSize = (int)(indexMap.get(keys[keyIndex+1]) - startPos);    

        bytes = new byte[byteSize];

        rfile.readFully(bytes);

        pos=0;

        ch = (char)bytes[pos];

        //        pos++;
        //Remove Z, S, I, D lines
        //System.out.println("sample");
        while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
        {
            while( ch != CARRIAGE_RETURN )
            {
                pos++;
                ch = (char)bytes[pos];
            }       

            pos++;
        }

        int arrSize=0;
        for(int j=pos;j<byteSize;j++)
        {
            if( CARRIAGE_RETURN == (char)bytes[j] )
                arrSize++;

        }
        double[] massArr = new double[arrSize];
        double[] intArr = new double[arrSize];

        //pos++;
        StringBuilder mass = new StringBuilder(10);
        StringBuilder intensity = new StringBuilder(10);
	intensity.append('0');

        boolean isMass=true;
        boolean isInt=true;

        int massIndex=0;
        //double tempMass;
        for(int j=pos;j<byteSize;j++)
        {
            ch = (char)bytes[j];
            switch(ch)
            {
		case WINDOW_CR:
		    break;
                    
                case SPACE:
                    isMass=false;
                    isInt=true;
                    break;

                case CARRIAGE_RETURN:
                    isMass=true; 
                    isInt=false;

                    intArr[massIndex] = Long.parseLong(intensity.toString());
                    massArr[massIndex++] = Double.parseDouble(mass.toString());

                    mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
                    intensity.delete(0, intensity.length()).append('0');

                    break;

                case DOT:
                    isInt=false;

                default:
                    if(isMass)
                        mass.append(ch);
                    else if(isInt) //remove decimal value of intensity
                        intensity.append(ch);

                    break;
            }

        } 

	return new IrisDataModel(massArr, intArr);
    }
  
//aaa 
    public static double[] readSpectrumSpecificPeaks(
            int i,
            IndexedFile iFile,
            List massList,
            double tolerance
            ) throws IOException            
    {
	RandomAccessFile file = iFile.getFile();
        TIntLongHashMap index = iFile.getMsIndex();

        int[] keys = iFile.getKeys();
        double[] result = new double[massList.size()+1];        
        
        int byteSize;
        byte[] bytes;
        char ch;
        int pos;
        
        if(i<0)
        {
            return result;
        }           
        
        long sampleIndex = index.get(keys[i]);
        
        StringBuilder mass, intensity;
        
        if(sampleIndex<0)
        {
            return result;
        }                   

        result[0] = keys[i];

        file.seek(sampleIndex);

        int increIndex=1;

        while(true)
        {
            if( (i+increIndex)>=keys.length )
            {
                byteSize = (int)(file.length() - sampleIndex); 

                break;
            }

            if(index.get(keys[i+increIndex])>0)
            { 
                byteSize = (int)(index.get(keys[i+increIndex]) - sampleIndex);    
                break;
            }

            increIndex++;
        }

        //byteSize = (int)(index.get(keys[i+1]) - sampleIndex);
        bytes = new byte[byteSize];

        file.readFully(bytes);
        pos=0;

        ch = (char)bytes[pos];

        //        pos++;
        //Remove Z, S, I, D lines
        //System.out.println("sample");
        while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
        {
            while( ch != CARRIAGE_RETURN )
            {
                pos++;
                ch = (char)bytes[pos];
            }       

            pos++;
        }

        
	    int arrSize=0;
	    for(int j=pos;j<byteSize;j++)
	    {
		if( CARRIAGE_RETURN == (char)bytes[j] )
		    arrSize++;

	    }
	    double[] massArr = new double[arrSize];
	    double[] intArr = new double[arrSize];

	    //pos++;
	    mass = new StringBuilder(10);
	    intensity = new StringBuilder(10);
	    intensity.append('0');

	    boolean isMass=true;
	    boolean isInt=true;

	    int massIndex=0;
	    //double tempMass;

	    for(int j=pos;j<byteSize;j++)
	    {
		ch = (char)bytes[j];
                //System.out.print(ch);
                
		switch(ch)
		{
		    case WINDOW_CR:
			break;
			
		    case SPACE:
			isMass=false;
			isInt=true;
			break;

		    case CARRIAGE_RETURN:
			isMass=true; 
			isInt=false;

                        //try {
			intArr[massIndex] = Long.parseLong(intensity.toString());
			massArr[massIndex++] = Double.parseDouble(mass.toString());
			mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
			intensity.delete(0, intensity.length()).append('0');
                        //} catch(Exception e) { System.out.println("-->>" + mass.toString() + " " + intensity.toString()); System.exit(0); };

			break;

		    case DOT:
			isInt=false;

		    default:
			if(isMass)
			    mass.append(ch);
			else if(isInt) //remove decimal value of intensity
			    intensity.append(ch);

                    break;
            }

        } 
           

        int tmpIndex=1;
        for(Iterator<String> itr=massList.iterator(); itr.hasNext(); )
        {
            double d = Double.parseDouble( itr.next() );            
            double sum = intensitySumForSinglePeak(massArr, intArr, d, tolerance);
            
            result[tmpIndex++] = sum;
        }

       /* 

        for(int ii=0;ii<result.length;ii++)
        {
            System.out.println("rr+>>" + result[ii] + " " + result[ii]);
        }
        
        for(int ii=0;ii<massArr.length;ii++)
        {
            System.out.println("+>>" + massArr[ii] + " " + intArr[ii]);
        }
	System.exit(0);
        */

        return result;
    
    }
    
    public static double intensitySumForSinglePeak(double[] massArr, double[] intArr, double mass, double tolerance)
    {
        double sumIntensity=0;
      
        double startMass = mass - tolerance;
        double endMass = mass + tolerance;

        //System.out.println(startMass + " " + endMass);
        int start = Arrays.binarySearch(massArr, startMass);        
        int end = Arrays.binarySearch(massArr, endMass);        

        //System.out.println(startMass + " " + endMass);
        if(start<0)
            start = -start -1;

        if(end<0)
            end = -end -2;

	double inttemp=0;
	double masstemp=0;
        for(int i=start;i<=end;i++)
        {
//           System.out.println("data\t" + mass + "\t" + massArr[i] + "\t" + intArr[i]);
	if(inttemp< intArr[i]) {
		masstemp=massArr[i];
		inttemp = intArr[i];
	}


            sumIntensity += intArr[i];
        }

	if(masstemp!=0)
           System.out.println("mass\t" + mass + "\t" + masstemp + "\t" + (mass-masstemp) + "\t" + inttemp);
        
        return sumIntensity;
    }
                
    //read frag ions only for light one.  For MRM CRV
    public static double[] readSimpleSpectrum(
            MRMPeptideModel model, 
            //.getBionArr(), model.getYionArr()
            ListIterator<Peak> peakList 
            ) throws IOException            
    {   
        double[][] bionArr = model.getBionSample();
        double[][] yionArr = model.getYionSample();
        
        TDoubleArrayList massList = new TDoubleArrayList();
        TDoubleArrayList intList = new TDoubleArrayList();
        
        for(Iterator<Peak> itr=peakList; itr.hasNext(); )
        {
            Peak p = itr.next();
            
            massList.add(p.getM2z());
            intList.add(p.getIntensity());            
        }
            
        double[] massArr = massList.toNativeArray();
        double[] intArr = intList.toNativeArray();
        

        int bionSum=0; 
        int yionSum=0;
        
        //boolean tempBool=false;
        double mass = model.getParentMass();
        
        double[] ionArr = new double[bionArr.length];
        
        
        for(int k=0;k<bionArr.length;k++)
        {            
            if(bionArr[k][1]>mass)
            {
                double bion = intensitySum(massArr, intArr, bionArr[k][1], bionArr[k][2]);        
                bionSum += bion;    
                
            //    System.out.print(bionArr[k][1] + "\t" + bion  + "\t");
            }
            
            if(yionArr[k][1]>mass)
            {
                double yion = intensitySum(massArr, intArr, yionArr[k][1], yionArr[k][2]);     
                yionSum += yion;
                
          //      System.out.print(yionArr[k][1]  + "\t" + yion  + "\t");
            }
            
//            sampleSum += result[ION_START_INDEX+k];
  //          sampleSum += result[ION_START_INDEX+bioSample.length+k];

        }   

        return null;
    }

    
    //read frag ions only for light one.  For MRM CRV
    public static double[] readSpectrum(
            int[] keys, 
            int i, 
            IndexedFile iFile, 
            //TIntLongHashMap index, 
            //int diff, 
            double[][] bioSample,
            double[][] yioSample
            ) throws IOException            
    {                       
	RandomAccessFile file = iFile.getFile();
        TIntLongHashMap index = iFile.getMsIndex();

        //int[] result = new int[3];
        ION_START_INDEX = 2; //no labeling
        int ionLength = bioSample.length;
        double[] result = new double[ionLength*2+ION_START_INDEX];
        
	//if( (i+diff)>=keys.length )
	//    return result;

        int byteSize;
        byte[] bytes;
        char ch;
        int pos;
        
        if(i<0)
        {
            return result;
        }           
        
        long sampleIndex = index.get(keys[i]);
        
        StringBuilder mass, intensity;
        
        if(sampleIndex<0)
        {
            return result;
        }                   


	    result[0] = keys[i];

	    /**********************************
	     * Go to Spectrum for sample, and calculate intensity
	     **********************************/        
	    file.seek(sampleIndex);

	    int increIndex=1;

	    while(true)
	    {
		if( (i+increIndex)>=keys.length )
		{
		    byteSize = (int)(file.length() - sampleIndex); 

		    break;
		}

		if(index.get(keys[i+increIndex])>0)
		{ 
		    byteSize = (int)(index.get(keys[i+increIndex]) - sampleIndex);    
		    break;
		}

		increIndex++;
	    }

	    //byteSize = (int)(index.get(keys[i+1]) - sampleIndex);
	    bytes = new byte[byteSize];

	    file.readFully(bytes);
	    pos=0;

	    ch = (char)bytes[pos];

	    //        pos++;
	    //Remove Z, S, I, D lines
	    //System.out.println("sample");
	    while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
	    {
		while( ch != CARRIAGE_RETURN )
		{
		    pos++;
		    ch = (char)bytes[pos];
		}       

		pos++;
	    }

	    int arrSize=0;
	    for(int j=pos;j<byteSize;j++)
	    {
		if( CARRIAGE_RETURN == (char)bytes[j] )
		    arrSize++;

	    }
	    double[] massArr = new double[arrSize];
	    double[] intArr = new double[arrSize];

	    //pos++;
	    mass = new StringBuilder(10);
	    intensity = new StringBuilder(10);
	    intensity.append('0');

	    boolean isMass=true;
	    boolean isInt=true;

	    int massIndex=0;
	    //double tempMass;

	    for(int j=pos;j<byteSize;j++)
	    {
		ch = (char)bytes[j];
                //System.out.print(ch);
                
		switch(ch)
		{
		    case WINDOW_CR:
			break;
			
		    case SPACE:
			isMass=false;
			isInt=true;
			break;

		    case CARRIAGE_RETURN:
			isMass=true; 
			isInt=false;

                        //try {
			intArr[massIndex] = Long.parseLong(intensity.toString());
			massArr[massIndex++] = Double.parseDouble(mass.toString());
			mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
			intensity.delete(0, intensity.length()).append('0');
                        //} catch(Exception e) { System.out.println("-->>" + mass.toString() + " " + intensity.toString()); System.exit(0); };

			break;

		    case DOT:
			isInt=false;

		    default:
			if(isMass)
			    mass.append(ch);
			else if(isInt) //remove decimal value of intensity
			    intensity.append(ch);

                    break;
            }

        } 

        int sampleSum=0; 


        //boolean tempBool=false;
        for(int k=0;k<bioSample.length;k++)
        {
            //result[ION_START_INDEX+k] = intensitySum(massArr, intArr, bioSample[k][startMassIndex], bioSample[k][endMassIndex]);
            //result[ION_START_INDEX+ionLength+k] = intensitySum(massArr, intArr, yioSample[k][startMassIndex], yioSample[k][endMassIndex]); 


            result[ION_START_INDEX+k] = intensitySum(massArr, intArr, bioSample[k][1], bioSample[k][2]);
            result[ION_START_INDEX+ionLength+k] = intensitySum(massArr, intArr, yioSample[k][1], yioSample[k][2]); 
            
            sampleSum += result[ION_START_INDEX+k];
            sampleSum += result[ION_START_INDEX+bioSample.length+k];


            //sampleSum += intensitySum(massArr, intArr, bioSample[k][1], bioSample[k][2]);
            //sampleSum += intensitySum(massArr, intArr, yioSample[k][1], yioSample[k][2]);                  
        }   
        result[1] = sampleSum;
        
        return result;
    }

    public static double[] readSpectrumByRt(
            double[] keys, 
            int i, 
            IndexedFile iFile, 
//            Object ofile,
            MRMPeptideModel model
            ) throws IOException            
    {                       
        double[][] bionArr = model.getBionArr();
        double[][] yionArr = model.getYionArr();

        //System.out.println(bionArr.length);
        
        int ionLength = bionArr.length;
        double[] result = new double[ionLength*4+ION_START_INDEX];
        
	RandomAccessFile file = iFile.getFile();

        int byteSize;
        byte[] bytes;
        char ch;
        int pos;
        
        if(i<0 || i>= keys.length)
        {
            return result;
        }           
        
        long index = iFile.getPosByRt(keys[i]);
        
        StringBuilder mass, intensity;
        
        if(index<0)
        {
            return result;
        }                   

        result[0] = keys[i];
            
        /**********************************
         * Go to Spectrum for sample, and calculate intensity
         *********************************/
        file.seek(index);

        int increIndex=1;

        while(true)
        {
            if( (i+increIndex)>=keys.length )
            {
                byteSize = (int)(file.length() - index); 

                break;
            }

            if(iFile.getPosByRt(keys[i+increIndex])>0)
            { 
                byteSize = (int)(iFile.getPosByRt(keys[i+increIndex]) - index);    
                break;
            }

            increIndex++;
        }

        bytes = new byte[byteSize];

        file.readFully(bytes);            
        pos=0;

        ch = (char)bytes[pos];
        
        
        while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
        {
            while( ch != CARRIAGE_RETURN )
            {
                pos++;
                ch = (char)bytes[pos];
            }       

            pos++;
        }

        
            
        int arrSize=0;
        for(int j=pos;j<byteSize;j++)
        {
            if( CARRIAGE_RETURN == (char)bytes[j] )
                arrSize++;

        }
        double[] massArr = new double[arrSize];
        double[] intArr = new double[arrSize];

        //pos++;
        mass = new StringBuilder(10);
        intensity = new StringBuilder(10);
        intensity.append('0');

        boolean isMass=true;
        boolean isInt=true;
        int massIndex=0;

        for(int j=pos;j<byteSize;j++)
        {
            ch = (char)bytes[j];

            if(ch == 'S') //when we read spectra by ret time, same retention may cause to read more than one spectrum
                break;

            //System.out.print(ch);
            switch(ch)
            {
                case WINDOW_CR:
                    break;

                case SPACE:
                    isMass=false;
                    isInt=true;
                    break;

                case CARRIAGE_RETURN:
                    isMass=true; 
                    isInt=false;

                    //System.out.println("==>>" + mass.toString() + " : " + intensity.toString()); 
                    intArr[massIndex] = Long.parseLong(intensity.toString());
                    massArr[massIndex++] = Double.parseDouble(mass.toString());
                    mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
                    intensity.delete(0, intensity.length()).append('0');

                    break;

                case DOT:
                    isInt=false;

                default:
                    if(isMass)
                        mass.append(ch);
                    else if(isInt) //remove decimal value of intensity
                        intensity.append(ch);

                break;
            }
        }             

        //System.out.println("end of body====");
        int intSum=0; 

        //boolean tempBool=false;
        for(int k=0;k<bionArr.length;k++)
        {

            result[ION_START_INDEX+k] = intensitySum(massArr, intArr, bionArr[k][1], bionArr[k][2]);
            result[ION_START_INDEX+ionLength+k] = intensitySum(massArr, intArr, yionArr[k][1], yionArr[k][2]); 

            intSum += result[ION_START_INDEX+k];
            intSum += result[ION_START_INDEX+bionArr.length+k];             

        }   

        result[1] = intSum;
            

//        for(int ii=0;ii<result.length;ii++)
  //          System.out.println("==>>" + result[ii]);

        
        return result;

    }


    public static double[] readSpectrum(
            int[] keys, 
            int i, 
            TIntLongHashMap index, 
            int refIndexKey,
            Object ofile,
            double[][] bioSample, double[][] bioRef,
            double[][] yioSample, double[][] yioRef
            ) throws IOException            
    {                       
        //int[] result = new int[3];
        //ION_START_INDEX == 3
        int ionLength = bioSample.length;
        double[] result = new double[ionLength*4+ION_START_INDEX];
        
	//if( (i+diff)>=keys.length )
	//    return result;

	RandomAccessFile file = (RandomAccessFile)ofile;

        int byteSize;
        byte[] bytes;
        char ch;
        int pos;
        
        if(i<0 || i>= keys.length)
        {
            return result;
        }           
        
        long sampleIndex = index.get(keys[i]);
        
        //System.exit(1);

        StringBuilder mass, intensity;
        
        if(sampleIndex<0)
        {
            return result;
        }                   

	    result[0] = keys[i];
            //System.out.println("resssss==>>" + result[0] + " " + precursorMap.get(keys[i]));
            

	    /**********************************
	     * Go to Spectrum for sample, and calculate intensity
	     **********************************/        
	    file.seek(sampleIndex);

	    int increIndex=1;

	    while(true)
	    {
		if( (i+increIndex)>=keys.length )
		{
		    byteSize = (int)(file.length() - sampleIndex); 

		    break;
		}

		if(index.get(keys[i+increIndex])>0)
		{ 
		    byteSize = (int)(index.get(keys[i+increIndex]) - sampleIndex);    
		    break;
		}

		increIndex++;
	    }

	    //byteSize = (int)(index.get(keys[i+1]) - sampleIndex);
	    bytes = new byte[byteSize];

	    file.readFully(bytes);
	    pos=0;

	    ch = (char)bytes[pos];

	    //        pos++;
	    //Remove Z, S, I, D lines
	    //System.out.println("sample");
	    while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
	    {
		while( ch != CARRIAGE_RETURN )
		{
		    pos++;
		    ch = (char)bytes[pos];
		}       

		pos++;
	    }

	    int arrSize=0;
	    for(int j=pos;j<byteSize;j++)
	    {
		if( CARRIAGE_RETURN == (char)bytes[j] )
		    arrSize++;

	    }
	    double[] massArr = new double[arrSize];
	    double[] intArr = new double[arrSize];

	    //pos++;
	    mass = new StringBuilder(10);
	    intensity = new StringBuilder(10);
	    intensity.append('0');

	    boolean isMass=true;
	    boolean isInt=true;

	    int massIndex=0;
	    //double tempMass;

	    for(int j=pos;j<byteSize;j++)
	    {
		ch = (char)bytes[j];
		switch(ch)
		{
		    case WINDOW_CR:
			break;
			
		    case SPACE:
			isMass=false;
			isInt=true;
			break;

		    case CARRIAGE_RETURN:
			isMass=true; 
			isInt=false;

			//System.out.println(mass.toString() + " " + intensity.toString()); 
			intArr[massIndex] = Long.parseLong(intensity.toString());
			massArr[massIndex++] = Double.parseDouble(mass.toString());
			mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
			intensity.delete(0, intensity.length()).append('0');
                        //} catch(Exception e) { System.out.println("-->>" + mass.toString() + " " + intensity.toString()); System.exit(0); };

			break;

		    case DOT:
			isInt=false;

		    default:
			if(isMass)
			    mass.append(ch);
			else if(isInt) //remove decimal value of intensity
			    intensity.append(ch);

                    break;
            }

        } 

        int sampleSum=0; 

//        int startMassIndex = 3*chargeState-2;
//        int endMassIndex = startMassIndex+1;

        //boolean tempBool=false;
        for(int k=0;k<bioSample.length;k++)
        {

            result[ION_START_INDEX+k] = intensitySum(massArr, intArr, bioSample[k][1], bioSample[k][2]);
            result[ION_START_INDEX+ionLength+k] = intensitySum(massArr, intArr, yioSample[k][1], yioSample[k][2]); 
            
            sampleSum += result[ION_START_INDEX+k];
            sampleSum += result[ION_START_INDEX+bioSample.length+k];             

        }   

        result[1] = sampleSum;
        
        if(refIndexKey<0)
            return result;
        
        
        long refIndex = index.get(keys[refIndexKey]);

        if(refIndex<0)
            return result;
        
        
        file.seek(refIndex);

        //System.out.println("resssss heavy==>>" + keys[refIndexKey] + " " + precursorMap.get(keys[refIndexKey]));
        increIndex=1;

        while(true)
        {
            //if( (i+increIndex+diff)>=keys.length )
            if( (increIndex+refIndexKey)>=keys.length )
            {
                byteSize = (int)(file.length() - refIndex);    
                break;
            }

            //if(index.get(keys[i+increIndex+diff])>0)
            if(index.get(keys[refIndexKey+increIndex])>0)
            { 
                byteSize = (int)(index.get(keys[refIndexKey+increIndex]) - refIndex);    
                break;
            }

            increIndex++;
        }

        bytes = new byte[byteSize];

        file.readFully(bytes);
        
        pos=0;
        ch = (char)bytes[pos];

        /*
        //Remove S line
        while( ch != CARRIAGE_RETURN )
        {
        pos++;
        ch = (char)bytes[pos];
        }
         */
        //        pos++;
        //Remove Z lines
        //System.out.println("reference");
        while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
        {
            while( ch != CARRIAGE_RETURN )
            {
                pos++;
                ch = (char)bytes[pos];
            }       

            pos++;
        }

//        System.out.println("end print ch");


        arrSize=0;
        for(int j=pos;j<byteSize;j++)
        {
            if( CARRIAGE_RETURN == (char)bytes[j] )
                arrSize++;

        }

        massArr = new double[arrSize];
        intArr = new double[arrSize];

        //pos++;
        mass.delete(0, mass.length());
        intensity.delete(0, intensity.length()).append('0');

        isMass=true;
        isInt=true;


        massIndex=0;
        for(int j=pos;j<byteSize;j++)
        {
            ch = (char)bytes[j];

            switch(ch)
            {
		case WINDOW_CR:
		    break;
                    
                case SPACE:
                    isMass=false;
                    isInt=true;
                    break;

                case CARRIAGE_RETURN:
                    isMass=true;
                    isInt=false;

                    intArr[massIndex] = Long.parseLong(intensity.toString());
                    massArr[massIndex++] = Double.parseDouble(mass.toString());

                    mass.delete(0, mass.length());
                    intensity.delete(0, intensity.length()).append('0');

                    break;

                case DOT:
                    isInt=false;

                default:
                    if(isMass)
                        mass.append(ch);
                    else if(isInt)
                        intensity.append(ch);

                    break;
            }

        } 

        //            refPeakList.setMassList(massArr); 

        int refSum=0;

        for(int k=0;k<bioSample.length;k++)
        {                
            result[ION_START_INDEX+ionLength*2+k] = intensitySum(massArr, intArr, bioRef[k][1], bioRef[k][2]);
            result[ION_START_INDEX+ionLength*3+k] = intensitySum(massArr, intArr, yioRef[k][1], yioRef[k][2]); 

            refSum += result[ION_START_INDEX+ionLength*2+k];
            refSum += result[ION_START_INDEX+ionLength*3+k];

        }   

        result[2] = refSum;
        
        return result;
    }

    //mzxml
    public static String calculateFullMS(
            int scanNum,
            double samStartMass, double samEndMass, 
            double refStartMass, double refEndMass,
            Configuration conf,
            SpecRange range)
        throws IOException, CensusIndexOutOfBoundException
    {
        
        /*
        TIntLongHashMap index = iFile.getMsIndex();
        RandomAccessFile file = iFile.getFile();
        int[] keys = iFile.getKeys();
    
        SpectrumModel sModel = new SpectrumModel();
        sModel.setHighRes(false);
        sModel.setKeys(keys);
        sModel.setIndex(index);
        sModel.setIFile(iFile);
        sModel.setFile(file);
        sModel.setSamStartMass(samStartMass);
        sModel.setSamEndMass(samEndMass);
        sModel.setRefStartMass(refStartMass);
        sModel.setRefEndMass(refEndMass);
        
        return peakFinding(sModel, range, conf, keyIndex);
*/
return null;
	//return sModel.getResult();
    }

    /*
    //low resolution + additional mass
    public static String calculateFullMS(
            int keyIndex,
            IndexedFile iFile,
            double samStartMass, double samEndMass, 
            double refStartMass, double refEndMass,
	    double[] refAddMassArray,
            SpecRange range)
        throws IOException, CensusIndexOutOfBoundException, Exception
    {
        conf = Configuration.getInstance();
	conf.

	return calculateFullMS(keyIndex, iFile, samStartMass, samEndMass, refStartMass, refEndMass, refAddMassArray, SpecRange range);
    }
    */
    //low resolution
    public static String calculateFullMS(
            int keyIndex,
            IndexedFile iFile,
            double samStartMass, double samEndMass, 
            double refStartMass, double refEndMass,
            SpecRange range)
        throws IOException, CensusIndexOutOfBoundException, Exception
    {
        conf = Configuration.getInstance();
        TIntLongHashMap index = iFile.getMsIndex();
        RandomAccessFile file = iFile.getFile();
        MzxmlSpectrumReader mzReader = iFile.getMzreader();
        int[] keys = iFile.getKeys();

        SpectrumModel sModel = new SpectrumModel();
        sModel.setHighRes(false);
        sModel.setKeys(keys);
        sModel.setIndex(index);
        sModel.setIFile(iFile);
        sModel.setFile(file);
        sModel.setMzxmlreader(mzReader);
        sModel.setSamStartMass(samStartMass);
        sModel.setSamEndMass(samEndMass);
        sModel.setRefStartMass(refStartMass);
        sModel.setRefEndMass(refEndMass);
        
        return peakFinding(sModel, range, keyIndex);

	//return sModel.getResult();
    }
    
    //high resolution
    public static class ResultList extends ArrayList<double[][]>
    {
        public ResultList(int size, int maxWindow, int margin)
        {
            super();
            
            for(int i=0;i<size;i++)
            {
                add( new double[maxWindow*2+1+margin*2][2] );
            }
        }
        
        public void addElement(int chromIndex, int scanIndex, double scanNumber, double intensity)
        {
            double[][] arr = get(chromIndex);
            arr[0][scanIndex] = scanNumber;
            arr[1][scanIndex] = intensity;
        }
    }
    
    //for non-labeling peak finding
    public static String peakFinding(
            SpectrumModel sModel, SpecRange range, Configuration conf, int keyIndex, double[] samIsoArr)            
        throws IOException, Exception
    {
        steepRatioThreshold = conf.getSteepRatioThreshold();
    
        int maxWindow=conf.getMaxWindow();
        int margin = conf.getMargin();
        
        NonLabelMappingModel mapModel = conf.getMapModel();        
        //Hashtable<String, Hashtable> ms2ms1Ht = mapModel.getMs2ms1Ht();
                
       // System.out.println(mapModel.getMs2ms1Ht());
       // System.exit(0);
        
        Vector<String> pathFileNameList = mapModel.getPathFileNameList();

        //ResultList result = new ResultList(pathArray.length+1, maxWindow, margin);
        int resultSize = pathFileNameList.size()*2;
        int resultIntensityStart = pathFileNameList.size();
        
        double[][] result = null;
        if(conf.getQuantLevel() == 1)
            result = new double[maxWindow*2+1+margin*2][resultSize];
        else if(conf.getQuantLevel() == 2)
            result = new double[maxWindow*2+1+margin*2][pathFileNameList.size()*2*sModel.getBioSample().length+resultSize]; //scan #, sample intensity, ref intensity

//	System.out.println("=============>>" + mapModel.getFileNameHt());
//        System.out.println("=============>>" + pathFileName);
//        System.out.println("=============>>" + mapModel.getPathFileNameList());
        int maxScanIndex = mapModel.getMaxScanIndex(pathFileName);

	if(maxScanIndex<0)
	{
	    System.out.println("Error : Spectral file name in the config file is invalid : " + pathFileName);
	    throw new Exception();
	}

//	System.out.println("maxScanindex ===>>" + maxScanIndex + " " + pathFileName);
	
        //int maxScanIndex = result.length;
        
        int leftIndex=maxWindow+margin;
        int rightIndex=maxWindow+margin+1;

        double totalIntensity=0;

        int steepArea = conf.getSteepArea(); 
	
        int moveLeftKeyIndex = keyIndex;
        int moveRightKeyIndex = -1;
        //int[] keys = sModel.getKeys();
        

        if(conf.getQuantLevel() == 1)
	    moveRightKeyIndex = keyIndex+1;
        else if(conf.getQuantLevel() == 2)
	    moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), keyIndex, MOVE_RIGHT, sModel.getIFile(), conf);

        int initWin=2;
	Hashtable<Integer, double[]> resultHt = new Hashtable<Integer, double[]>();
        
        for(int i=0;i<initWin;i++)
        {
	    if(moveLeftKeyIndex<=0 || leftIndex<=0)
	    {
		if(conf.getQuantLevel() == 1)
		    moveLeftKeyIndex++;                
		else
		    moveLeftKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveLeftKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);

		leftIndex++;
		
		break;
	    }

            
            if(conf.isHighRes())
                result[leftIndex] = readFullSpectrum(moveLeftKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);//
            else                    
                result[leftIndex] = readFullSpectrum(moveLeftKeyIndex, null, null, null, mapModel, sModel, resultHt); 
            
           // System.exit(0);
                
            //result = new double[maxWindow*2+1+margin*2][4*sModel.getBioSample().length+resultSize]; //scan #, sample intensity, ref intensity

            for(int j=resultIntensityStart;j<result[leftIndex].length;j++)
                totalIntensity += result[leftIndex][j];
            
	    if(conf.getQuantLevel() == 1)
		moveLeftKeyIndex--;                
	    else
		moveLeftKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);

            //if it is null, continue without changing leftIndex value;
            if(0 == result[leftIndex][0])
            {
                i--;
                continue;
            }
	    
            leftIndex--;
        }

        for(int i=0;i<initWin;i++) //leftIndex=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
            if(moveRightKeyIndex>maxScanIndex || moveRightKeyIndex<0)
            {
		if(conf.getQuantLevel() == 1)
		    moveRightKeyIndex--;                
		else
		    moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveRightKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);

                rightIndex--;

                break;
            }
            
            if(conf.isHighRes())
                result[rightIndex] = readFullSpectrum(moveRightKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);
            else
                result[rightIndex] = readFullSpectrum(moveRightKeyIndex, null, null, null, mapModel, sModel, resultHt); 

            for(int j=resultIntensityStart;j<result[leftIndex].length;j++)
                totalIntensity += result[leftIndex][j];

	    if(conf.getQuantLevel() == 1)
		moveRightKeyIndex++;                
	    else
		moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
            
            //if it is null, continue without changing leftIndex value;
            if(0 == result[rightIndex][0])
            {
                i--;
                continue;
            }
            
            rightIndex++;
        }

	if(moveRightKeyIndex<0 && moveLeftKeyIndex<0)
	    return null;

        boolean isGoingUp=true;
        boolean isHighIntensity=true;  //if the intensity is lower than one third of average intensity, this becomes false
        double[][] arr = new double[steepArea][resultSize];
        double[][] prevArr = new double[steepArea][resultSize];
	Hashtable<Integer, double[]> tmpKeyHt = new Hashtable<Integer, double[]>();

        if(leftIndex+steepArea>=0)
        {
            //for(int i=0;i<300;i++)
	    while(true)
            {            
                double area1=0;
                double area2=0;

                if(moveLeftKeyIndex-steepArea<0)                    
                    break;                

                int steepCount=0;
                int tempKeyIndex = moveLeftKeyIndex;
                while(true)
                {
		    if(tempKeyIndex<0 || steepCount<0 || steepCount>=steepArea-1)
			break;
                    
		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<resultSize;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
			
			if(conf.getQuantLevel()==2)
			{
			    if(conf.isHighRes())
			    {
				System.out.println("Error : we do not support high resolution analysis for MSMS yet.  Email to rpark@scripps.edu");
				System.exit(0);
			    }
			    else
			    {			
				arr[steepCount] = readSpectrum(sModel, tempKeyIndex);               
			    }
			}
			else if(conf.getQuantLevel()==1)
			{
			    double[] tmpKeyArr = tmpKeyHt.get(tempKeyIndex);
			    if(null != tmpKeyArr)
				arr[steepCount] = tmpKeyArr;
			    else
			    {
				if(conf.isHighRes())
				    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);
				else
				    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, null, mapModel, sModel, resultHt); 
			    
				tmpKeyHt.put(tempKeyIndex, arr[steepCount]);
			    }
			}
		    }
		    
                    steepCount++;
		    if(conf.getQuantLevel()==2)
			tempKeyIndex = findLightKey(sModel.getIFile().getKeys(), tempKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
		    else
			tempKeyIndex--;
                }

		if(tempKeyIndex<0)
		    break;

		if(conf.getQuantLevel()==2)
		{
		    if(conf.isHighRes())
		    {
			System.out.println("Error : we do not support high resolution analysis for MSMS yet.  Email to rpark@scripps.edu");
			System.exit(0);
		    }
		    else
		    {			
			arr[steepCount] = readSpectrum(sModel, tempKeyIndex);               
		    }
		}
		else
		{
		    double[] tmpKeyArr = tmpKeyHt.get(tempKeyIndex);
		    if(null != tmpKeyArr)
			arr[steepCount] = tmpKeyArr;
		    else
		    {
			if(conf.isHighRes())
			    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);
			else
			    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, null, mapModel, sModel, resultHt); 
			
			tmpKeyHt.put(tempKeyIndex, arr[steepCount]);
		    }
		}

		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<resultSize;l++)
			prevArr[k][l] = arr[k][l];
		}

		if(conf.getQuantLevel()==2)
		{

		    if(conf.isHighRes())
		    {
			System.out.println("Error : we do not support high resolution analysis for MSMS yet.  Email to rpark@scripps.edu");
			System.exit(0);
		    }
		    else
		    {			
			for(int j=leftIndex+1;j<=leftIndex+steepCount+1;j++)
			{
			    for(int k=1;k<=resultIntensityStart;k++)                    
			    {                        
				area1 += result[j][k];
			    }
			}

			for(int j=0;j<=steepCount;j++)
			{
			    for(int k=1;k<=resultIntensityStart;k++)
			    {
				area2 += arr[j][k];
			    }
			}
		    }
		}
		else
		{

		    for(int j=leftIndex+1;j<=leftIndex+steepCount+1;j++)
		    {
			for(int k=resultIntensityStart;k<result[j].length;k++)                    
			{                        
			    area1 += result[j][k];
			}
		    }

		    for(int j=0;j<=steepCount;j++)
		    {
			for(int k=resultIntensityStart;k<result[j].length;k++)
			{
			    area2 += arr[j][k];
			}
		    }

		}

                if(area2==0 && area1==0)
                    break;
               
                double areaRatio = (double)area2/area1;

                /*****************************************
                 * AREA1 is right side area
                 * AREA2 is left side area
                 *****************************************/
		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;
        
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold ) 
                {
		    if(leftIndex<=0)
		    {
                        isGoingUp=false;
                        break;
		    }

                    result[leftIndex] = arr[0];
		    
		    if(conf.getQuantLevel()==2)
			moveLeftKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
		    else
			moveLeftKeyIndex--; // -= numIsoWindow;

		    if(0 == result[leftIndex][0])
			continue;
		    
		    leftIndex--;

                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];
                    
                    for(int j=resultIntensityStart;j<arr.length;j++)
                        totalIntensity += arr[0][j];
                    
                    continue;                    
                }
                else
                    isGoingUp=false;

                                
                if(areaRatio>steepRatioThreshold)
                {
		    for(int k=0;k<3;k++)
		    {   
			if(result[leftIndex+1][resultIntensityStart]<arr[k][resultIntensityStart] || arr[k][0]==0)
			    break;

			if(leftIndex<0)
			    break;

			result[leftIndex] = arr[k];

			if(conf.getQuantLevel()==2)
			    moveLeftKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
			else
			    moveLeftKeyIndex--; // -= numIsoWindow;

			leftIndex--;
		    }
                
                    break;
                }

                result[leftIndex--] = arr[0];
		if(conf.getQuantLevel()==2)
		    moveLeftKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
		else
		    moveLeftKeyIndex--; // -= numIsoWindow;

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }

	prevArr = new double[steepArea][resultSize]; //clean up the array
         
        isGoingUp = true;
	isHighIntensity = true;

        if(rightIndex+steepArea<result.length)
        {
            while(true)
            {            
                double area1=0;
                double area2=0;
                
                if(moveRightKeyIndex+steepArea>=maxScanIndex)                    
                    break;                

                int steepCount=0;

                int tempKeyIndex = moveRightKeyIndex;
                while(true)
                {
		    if(tempKeyIndex>=maxScanIndex || steepCount>= steepArea-1 || steepCount>=maxScanIndex)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=resultIntensityStart;m<resultSize;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
			if(conf.getQuantLevel()==2)
			{
			    if(conf.isHighRes())
			    {
				System.out.println("Error : we do not support high resolution analysis for MSMS yet.  Email to rpark@scripps.edu");
				System.exit(0);
			    }
			    else
			    {			
				arr[steepCount] = readSpectrum(sModel, tempKeyIndex);               
			    }
			}
			else if(conf.getQuantLevel()==1)
			{
			    double[] tmpKeyArr = tmpKeyHt.get(tempKeyIndex);
			    if(null != tmpKeyArr)
				arr[steepCount] = tmpKeyArr;
			    else
			    {
				if(conf.isHighRes())
				    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);			    
				else
				    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, null, mapModel, sModel, resultHt); 

				tmpKeyHt.put(tempKeyIndex, arr[steepCount]);
			    }
			}
		    }

                    steepCount++;

		    if(conf.getQuantLevel()==2)
			tempKeyIndex = findLightKey(sModel.getIFile().getKeys(), tempKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
		    else
			tempKeyIndex++; // = tempKeyIndex + 1*numIsoWindow;
                }

		if(tempKeyIndex>=maxScanIndex)
		    break;

		if(conf.getQuantLevel()==2)
		{
		    if(conf.isHighRes())
		    {
			System.out.println("Error : we do not support high resolution analysis for MSMS yet.  Email to rpark@scripps.edu");
			System.exit(0);
		    }
		    else
		    {			
			arr[steepCount] = readSpectrum(sModel, tempKeyIndex);               
		    }
		}
		else
		{
		    double[] tmpKeyArr = tmpKeyHt.get(tempKeyIndex);
		    if(null != tmpKeyArr)
			arr[steepCount] = tmpKeyArr;
		    else
		    {
			if(conf.isHighRes())
			    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);
			else
			    arr[steepCount] = readFullSpectrum(tempKeyIndex, null, null, null, mapModel, sModel, resultHt); 

			tmpKeyHt.put(tempKeyIndex, arr[steepCount]);
		    }
		}

		if(null == arr[steepCount])
		    break;

		for(int k=0;k<3;k++)
		{
		    for(int l=resultIntensityStart;l<resultSize;l++)
			prevArr[k][l] = arr[k][l];
		}


		if(conf.getQuantLevel()==2)
		{
		    if(conf.isHighRes())
		    {
			System.out.println("Error : we do not support high resolution analysis for MSMS yet.  Email to rpark@scripps.edu");
			System.exit(0);
		    }
		    else
		    {			
			for(int j=rightIndex-1;j>rightIndex-steepCount-2;j--)
			{
			    for(int k=1;k<=resultIntensityStart;k++)
			    {                        
				area1 += result[j][k];
			    }
			}

			for(int j=0;j<=steepCount;j++)
			{
			    //for(int k=resultIntensityStart;k<result[j].length;k++)
			    for(int k=1;k<=resultIntensityStart;k++)
			    {                        
				area2 += arr[j][k];
			    }
			}

		    }
		}
		else
		{
		    for(int j=rightIndex-1;j>rightIndex-steepCount-2;j--)
		    {
			for(int k=resultIntensityStart;k<result[j].length;k++)
			{                        
			    area1 += result[j][k];
			}
		    }

		    for(int j=0;j<=steepCount;j++)
		    {
			for(int k=resultIntensityStart;k<result[j].length;k++)
			{                        
			    area2 += arr[j][k];
			}
		    }

		}

                if(area2==0 && area1==0)
                    break;

                double areaRatio = (double)area2/area1;
                                          
                /*****************************************
                 * AREA1 is left side area
                 * AREA2 is right side area
                 *****************************************/

		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;

                //if( ((isGoingUp && (double)totalIntensity/(rightIndex-leftIndex-1)/3<area2/3)) || areaRatio<steepRatioThreshold )                 
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold )                 
                {
                    if((rightIndex+1)>=result.length)
                    {
                        isGoingUp=false;
                        break;
                    }
                      
                    result[rightIndex] = arr[0];
		    if(conf.getQuantLevel()==2)
			moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
		    else
			moveRightKeyIndex++; 

		    if(0 == result[rightIndex][0])
			continue;
		    
		    rightIndex++;
                    
                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];

                    //rightTotalIntensity += arr[0][1];
                    
                    
                    for(int j=resultIntensityStart;j<resultSize;j++)
                    {                        
                        totalIntensity += arr[0][j];
                    }
                    
                    //totalIntensity += arr[0][1];
                    //totalIntensity += arr[0][2];
                    
                    continue;                
                }
                else
                    isGoingUp=false;
                   
                if(area2/area1>steepRatioThreshold)
                {                    
                    for(int k=0;k<3;k++)
                    {          
                        if(result[rightIndex-1][resultIntensityStart]<arr[k][resultIntensityStart])
                            break;

			if(result.length<=rightIndex)
			    break;
                       
                        result[rightIndex] = arr[k];
                            

			if(conf.getQuantLevel()==2)
			    moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
			else
			    moveRightKeyIndex++;
                        
                        rightIndex++;
                    }
                     break;
                }
                    
                result[rightIndex++] = arr[0];
                                
		if(conf.getQuantLevel()==2)
		    moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
		else
		    moveRightKeyIndex++; 

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }

/*
        System.out.println("===============");
        for(int iii=0;iii<result.length;iii++)
        {
            //if(result[iii][0]==0)
              //  continue;
            
            for(int jjj=0;jjj<result[iii].length;jjj++)
                System.out.print(result[iii][jjj] + " ");
            
            System.out.println("");
        }
        System.out.println("===============");

         System.exit(0);
  */       
      
	int peakStart = leftIndex+1;
	int peakEnd = rightIndex-1;

        //NonLabelMappingModel conf.getMapModel();
        int dtaStart = range.getMin();
        int dtaEnd = range.getMax();

	//for(int i=0;i<result.length;i++)
	 //   for(int j=0;j<result[i].length;j++)

        int specSpace = 1; //(int)(result[peakStart+1][0]-result[peakStart][0]);

        int diff = (int)(result[peakStart][0]-dtaStart)/specSpace;
        
        int leftMargin = margin;

        int rightMargin = margin;
        if(diff>0)
            leftMargin += diff;            
     
        diff = (int)(dtaEnd-result[rightIndex-1][0])/specSpace;
        if(diff>0)
            rightMargin += diff;
        
        
	for(int i=0;i<leftMargin;i++)
        {   
            if(leftIndex<0 || moveLeftKeyIndex<=0)
                break;
  
            if(conf.getQuantLevel()==2)
	    {

		if(conf.isHighRes())
		    ;
		else
		    result[leftIndex] = readSpectrum(sModel, moveLeftKeyIndex); //, null, null); 
	    }
	    else
	    {
		if(conf.isHighRes())
		    result[leftIndex] = readFullSpectrum(moveLeftKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);
		else
		    result[leftIndex] = readFullSpectrum(moveLeftKeyIndex, null, null, null, mapModel, sModel, resultHt); 
                
	    }

            
	  
            
	    if(0 == result[leftIndex][0])
	    {
		if(conf.getQuantLevel()==2)
		    moveLeftKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
		else
		    moveLeftKeyIndex--; 

		continue;
	    }

            leftIndex--;

	    if(conf.getQuantLevel()==2)
		moveLeftKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
	    else
		moveLeftKeyIndex--;            
        }
        

        for(int i=0;i<rightMargin;i++)
        {
//        System.out.println(moveRightKeyIndex);
            if(rightIndex>=result.length || moveRightKeyIndex>=maxScanIndex || moveRightKeyIndex<0)
                break;

            if(conf.getQuantLevel()==2)
            {

                if(conf.isHighRes())
                    ;
                else
                    result[rightIndex] = readSpectrum(sModel, moveRightKeyIndex);
            }
            else
            {
                if(conf.isHighRes())
                    result[rightIndex] = readFullSpectrum(moveRightKeyIndex, null, null, samIsoArr, mapModel, null, resultHt);
                else
		    result[rightIndex] = readFullSpectrum(moveRightKeyIndex, null, null, null, mapModel, sModel, resultHt); 
            }

            if(0 == result[rightIndex][0])
            {
                if(conf.getQuantLevel()==2)
                    moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
                else
                    moveRightKeyIndex++;

                continue;
            }

            rightIndex++;

            if(conf.getQuantLevel()==2)
                moveRightKeyIndex = findLightKey(sModel.getIFile().getKeys(), moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
            else
                moveRightKeyIndex++;
        }

        
        /*
        System.out.println("===============");
        for(int iii=0;iii<result.length;iii++)
        {
            //if(result[iii][0]==0)
              //  continue;
            
            for(int jjj=0;jjj<result[iii].length;jjj++)
                System.out.print(result[iii][jjj] + " ");
            
            System.out.println("");
        }
        */
        
         
                    
	if(conf.getQuantLevel()==1)
	    return buildNLResult(peakStart, peakEnd, leftIndex, rightIndex, result, pathFileNameList.size());
	else //if(conf.getQuantLevel()==2)
	    return buildNLResult(peakStart, peakEnd, leftIndex, rightIndex, result, sModel.getBioSample().length, pathFileNameList.size());
    }

    
    
    private final static int MOVE_LEFT=1;
    private final static int MOVE_RIGHT=2;
    
    public static int findNextKeyIndex(int keys[], int keyIndex, int move, IndexedFile iFile, Configuration conf, double avgMass, boolean findHeavy) //find heavy ion or just move to next window
    {
        TIntDoubleHashMap precurMap = iFile.getPrecursorMap();
        TIntLongHashMap byteMap = iFile.getMsIndex();        

        double tolerance = conf.getIsolationWindow()/2;

        double startMass = avgMass - tolerance;
        double endMass = avgMass + tolerance; 

        int startLeftIndex = -1;
        int startRightIndex = -1;
                
        switch( conf.getExpType() )
        {
        //    case CensusConstants.MRM_EXPERIMENT :
                //System.out.println(finHeavy);
            case CensusConstants.MSMS_DATA_INDEPENDENT :
                if(findHeavy)
                {
                    startLeftIndex = keyIndex;
                    startRightIndex = keyIndex;
                }
                else
                {
                    startLeftIndex = keyIndex-1;
                    startRightIndex = keyIndex+1;
                    
                }
                break;
                
            default :
                startLeftIndex = keyIndex-1;
                startRightIndex = keyIndex+1;

                break;
        }
     
        if(move == MOVE_LEFT)
        {
            for(int i=startLeftIndex;i>=0;i--)
            {
                double prec = precurMap.get(keys[i]);  //retrieve precursor

                if(startMass<=prec && endMass>=prec)
		{

                    return i;
		}
            }

        }
        else //MOVE_RIGHT
        {
            for(int i=startRightIndex;i<keys.length;i++)
            {
                double prec = precurMap.get(keys[i]);  //retrieve precursor

                if(startMass<=prec && endMass>=prec)
                {
                    return i;
                }
            }            
        }
        
        
	return -1;      
    }
    
    public static int findHeavyKey(int keys[], int keyIndex, IndexedFile iFile, Configuration conf, double avgMass)
    {
        return findNextKeyIndex(keys, keyIndex, MOVE_RIGHT, iFile, conf, avgMass, true);
    }    

    public static int findLightKey(int keys[], int keyIndex, int move, IndexedFile iFile, Configuration conf) //throws PrecursorNotFoundException
    {
        if(conf.getQuantLevel() == 1)
            return keyIndex + 1;
        //findNextKey(keys, keyIndex, MOVE_RIGHT, sModel.getIFile(), conf, conf.getCalcSamAvgMass());                    
	
        int key = findNextKeyIndex(keys, keyIndex, move, iFile, conf, conf.getCalcSamAvgMass(), false);
      
        return key;

    }
    
    //for mrm data including iTRAQ multiple spectra
    public static int findMRMNextKey(int keys[], int keyIndex, int move, IndexedFile iFile, Configuration conf) //throws PrecursorNotFoundException
    {
	
        int key = findMRMNextKeyIndex(keys, keyIndex, move, iFile, conf);        
                       
        return key;
    }
    
    
    public static int findMRMNextKeyIndex(int keys[], int keyIndex, int move, IndexedFile iFile, Configuration conf)
    {
        if(keyIndex<0 || keyIndex>=keys.length)
            return -1;
        
        TIntDoubleHashMap precurMap = iFile.getPrecursorMap();
        TIntLongHashMap byteMap = iFile.getMsIndex();        
        
        double tolerance = conf.MRM_PRECURSOR_TOLERANCE;
        
        //double startMass = conf.getCalcSamAvgMass() - tolerance;
        //double endMass = conf.getCalcSamAvgMass() + tolerance; 
        
        double precursorMass = precurMap.get(keys[keyIndex]);
        double startMass = precursorMass - tolerance;
        double endMass = precursorMass + tolerance; 
        
        if(move == MOVE_LEFT)
        {
            for(int i=keyIndex-1;i>=0;i--)
            {
                double prec = precurMap.get(keys[i]);  //retrieve precursor
                
                if(startMass<=prec && endMass>=prec)
                    return i;
            }
            
        }
        else //MOVE_RIGHT
        {
            for(int i=keyIndex+1;i<keys.length;i++)
            {
                double prec = precurMap.get(keys[i]);  //retrieve precursor
            
                
                if(startMass<=prec && endMass>=prec)
                    return i;
            }            
            
        }
         
	return -1;      
    }
    
    public static int findMRMNextKeyIndexByPrecursor(double rtArr[], int keyIndex, int move, IndexedFile iFile, Configuration conf, double pCursor)
    {
        if(keyIndex<0 || keyIndex>=rtArr.length)
            if(MOVE_RIGHT==move)
                return rtArr.length;
            else                
                return -1;
        
        TDoubleDoubleHashMap precurMap = iFile.getRtPrecursorMap();
        
        //double startMass = conf.getCalcSamAvgMass() - tolerance;
        //double endMass = conf.getCalcSamAvgMass() + tolerance; 
        
        double precursorMass = precurMap.get(rtArr[keyIndex]);
        //double startMass = precursorMass - tolerance;

        if(move == MOVE_LEFT)
        {
            for(int i=keyIndex-1;i>=0;i--)
            {
                double prec = precurMap.get(rtArr[i]);  //retrieve precursor
                
                if(pCursor == prec) //startMass<=prec && endMass>=prec)
                    return i;
            }
        }
        else //MOVE_RIGHT
        {
            for(int i=keyIndex+1;i<rtArr.length;i++)
            {
                double prec = precurMap.get(rtArr[i]);  //retrieve precursor
            
                if(pCursor == prec) //if(startMass<=prec && endMass>=prec)
                    return i;
            }                        
        }         
        
        if(MOVE_RIGHT==move)
            return rtArr.length;
        
	return -1;      
    }
    
    
    //MSMS peak finding for iTRAQ
    public static String peakFindingMSMSMultipleSpecific(SpectrumModel sModel, SpecRange range, Configuration conf, int keyIndex) 
        throws PrecursorNotFoundException, IOException, CensusIndexOutOfBoundException
    {
               
	TIntLongHashMap index = sModel.getIndex();
        
	RandomAccessFile file = sModel.getFile();        
        steepRatioThreshold = conf.getSteepRatioThreshold();

//	int numIsoWindow = conf.getNumOfIsolationWindow();
        int maxWindow=conf.getMaxWindow();
        int margin = conf.getMargin();
        List massList = sModel.getMsmsSpecificMassList();
        
	double[][] result = new double[maxWindow*2+1+margin*2][massList.size()+1];

        int leftIndex=maxWindow+margin;
        int rightIndex=maxWindow+margin+1;
        
        
        double totalIntensity=0;
        int[] keys = sModel.getKeys();        
        int initWin=2;
       
        int steepArea = conf.getSteepArea(); 
	
        int moveLeftKeyIndex = keyIndex;        
        int moveRightKeyIndex = findMRMNextKey(keys, keyIndex, MOVE_RIGHT, sModel.getIFile(), conf);

        IndexedFile iFile = sModel.getIFile();
        
        for(int i=0;i<initWin;i++) ///Index=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
	    if(moveLeftKeyIndex<=0 || leftIndex<=0)
	    {
                //move back to right because it cannot move to left any more
                moveLeftKeyIndex = findMRMNextKey(keys, moveLeftKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
		leftIndex++;
		
		break;
	    }

            result[leftIndex] = readSpectrumSpecificPeaks(moveLeftKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());
                        
            for(int j=0;j<result[leftIndex].length;j++)
                totalIntensity += result[leftIndex][j];
            
            moveLeftKeyIndex = findMRMNextKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);            
            
            leftIndex--;
        }
        
        for(int i=0;i<initWin;i++) //leftIndex=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
            //System.out.println(moveRightKeyIndex + " " + keys.length + " ---" + i);
            if(moveRightKeyIndex>=keys.length || moveRightKeyIndex<0)
            {
          //      System.out.println(moveRightKeyIndex + " " + keys.length + " " + i);
            //    System.out.println(moveRightKeyIndex + " " + keys.length + " " + i);
              //  System.out.println(moveRightKeyIndex + " " + keys.length + " " + i);
              //  System.out.println(moveRightKeyIndex + " " + keys.length + " " + i);
                
                
		moveRightKeyIndex = findMRMNextKey(keys, moveRightKeyIndex, MOVE_LEFT, sModel.getIFile(), conf); 
		
                rightIndex--;

                break;
            }

            result[rightIndex] = readSpectrumSpecificPeaks(moveRightKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());

            for(int j=0;j<result[rightIndex].length;j++)
                totalIntensity += result[rightIndex][j];
                

            //moveRightKeyIndex += numIsoWindow;
	    moveRightKeyIndex = findMRMNextKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf); 
            rightIndex++;
        }
      
	if(moveRightKeyIndex<0 && moveLeftKeyIndex<0)
	    return null;
        
        boolean isGoingUp=true;
        boolean isHighIntensity=true;  //if the intensity is lower than one third of average intensity, this becomes false
        

        double[][] arr = new double[steepArea][massList.size()+1];
        double[][] prevArr = new double[steepArea][massList.size()+1];

        //steepRatioThreshold = 0.1f;  //give very strigent threshold for iTRAQ
        if(leftIndex+steepArea>=0)
        {
            //for(int i=0;i<300;i++)
	    while(true)
            {            
                double area1=0;
                double area2=0;

                if(moveLeftKeyIndex-steepArea<0)                    
                {
                    break;                
                }

                int steepCount=0;
                int tempKeyIndex = moveLeftKeyIndex;
                while(true)
                {
		    if(tempKeyIndex<0 || steepCount<0 || steepCount>=steepArea-1 )
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
                        {
          //                  arr[l] = prevArr[l+1];
          		    for(int m=0;m<3;m++)
                            {    
				arr[l][m] = prevArr[l+1][m];
                                
                            }
                        }
		    }
		    else
		    {
                        arr[steepCount] = readSpectrumSpecificPeaks(tempKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());
                        //arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, findHeavyKey(keys, tempKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());         
		    }
		    
                    steepCount++;
		    tempKeyIndex = findMRMNextKey(keys, tempKeyIndex, MOVE_LEFT, sModel.getIFile(), conf); 
                }

		if(tempKeyIndex<0)
		    break;

                arr[steepCount] = readSpectrumSpecificPeaks(tempKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());
                //readSpectrum(keys, tempKeyIndex, index, findHeavyKey(keys, tempKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());

		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<massList.size()+1;l++)
			prevArr[k][l] = arr[k][l];
		}

                for(int j=leftIndex+1;j<=leftIndex+steepCount+1;j++)
                {
                    for(int k=1;k<result[j].length;k++)
                    {
                        area1 += result[j][k];              
                    }
                }
                        
                for(int j=0;j<=steepCount;j++)
                {
                    for(int k=1;k<result[j].length;k++)
                    {
                        area2 += arr[j][k];                   
                    }
                }
    //            System.out.println("");
      //          System.out.println(area2 + " " + area1 + " " + (double)area2/area1);
        //        System.out.println("");        
                
                if(area2==0 && area1==0)
                    break;
                
                double areaRatio = (double)area2/area1;

                //System.out.println("==>>" + area1 + " " + area2 + " " + areaRatio + " " + steepRatioThreshold);
                /*****************************************
                 * AREA1 is right side area
                 * AREA2 is left side area
                 *****************************************/
                double intHeight = (double)totalIntensity/(rightIndex-leftIndex-1)/1.5;
                
                if(isHighIntensity && (intHeight>area2/3))		
		    isHighIntensity = false;

                
                if(areaRatio<0.01)
                    isGoingUp = false;
                                    
                //This is comparison between most intensive peak vs. new peak
                double heightRatio = area2/steepArea/intHeight;
                    
                //if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold ) 
                if( heightRatio>0.01 && ((isGoingUp || isHighIntensity) || areaRatio<steepRatioThreshold ) )
                {
    //                System.out.println("2222");
		    if(leftIndex<=0)
		    {
                        isGoingUp=false;
                        break;
		    }

                    result[leftIndex] = arr[0];
		    moveLeftKeyIndex = findMRMNextKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf); 

		    if(0 == result[leftIndex][0])
			continue;
		    
		    leftIndex--;

                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];
                    
                    for(int j=1;j<arr[0].length;j++)
                    {
                        totalIntensity += arr[0][j];
                    }
        //            System.out.print("\n");
                    continue;                    
                }
                else
                    isGoingUp=false;

          //      System.out.println("00000000000 " + areaRatio + " " + steepRatioThreshold + " " + isGoingUp);                                
                if(areaRatio>steepRatioThreshold && !isGoingUp)
                {
                    for(int k=0;k<3;k++)
                    {   
                        if(result[leftIndex+1][1]<arr[k][1] || arr[k][0]==0)
                            break;

			if(leftIndex<0)
			    break;

                        result[leftIndex] = arr[k];
                            
			//moveLeftKeyIndex -= numIsoWindow;
			moveLeftKeyIndex = findMRMNextKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
                                
                        leftIndex--;
                    }
                
                    break;
                }

                //System.out.println("000000000000");
                                
                result[leftIndex--] = arr[0];
		moveLeftKeyIndex = findMRMNextKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
                        
                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
                
                //System.out.println("000000000000");
            }
        }

        isGoingUp = true;
	isHighIntensity = true;

        prevArr = new double[steepArea][massList.size()+1]; //clean up the array
        
        if(rightIndex+steepArea<result.length)
        {
            //for(int i=0;i<500;i++)
            while(true)
            {            
                double area1=0;
                double area2=0;
                
                if(moveRightKeyIndex+steepArea>=keys.length)                    
                    break;                

                int steepCount=0;

                int tempKeyIndex = moveRightKeyIndex;
                while(true)
                {
		    if(tempKeyIndex>=keys.length || steepCount>= steepArea-1 || steepCount>=keys.length || tempKeyIndex<0)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<3;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
                        //arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, findHeavyKey(keys, tempKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
                        
                        arr[steepCount] = readSpectrumSpecificPeaks(tempKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());                        
		    }

                    steepCount++;
		    //tempKeyIndex = tempKeyIndex + 1*numIsoWindow;
                    
		    tempKeyIndex = findMRMNextKey(keys, tempKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
                    //tempKeyIndex++;
                }

		if(tempKeyIndex>=keys.length)
		    break;

                arr[steepCount] = readSpectrumSpecificPeaks(tempKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());                        
                
		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<massList.size()+1;l++)
			prevArr[k][l] = arr[k][l];
		}

                                
                for(int j=rightIndex-1;j>rightIndex-steepCount-2;j--)
                {
                    for(int k=1;k<result[j].length;k++)
                    {
                        area1 += result[j][k];              
                    }                        
                }
                            
                for(int j=0;j<=steepCount;j++)
                {
                    for(int k=1;k<result[j].length;k++)
                    {
                        area2 += arr[j][k];                
                    }
                }

                if(area2==0 && area1==0)
                    break;

                double areaRatio = (double)area2/area1;
                                          
                /*****************************************
                 * AREA1 is left side area
                 * AREA2 is right side area
                 *****************************************/

                double intHeight = (double)totalIntensity/(rightIndex-leftIndex-1)/1.5;
		if(isHighIntensity && (intHeight>area2/3))
		    isHighIntensity = false;

                //if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold )                 
                    
                //System.out.println("==>>" + isGoingUp + " " + isHighIntensity + " " + totalIntensity + " " + areaRatio + " >>" + area1 + " " + area2 + "<< " + steepRatioThreshold + " " + intHeight);        

                if(areaRatio<0.01)
                    isGoingUp = false;
                                    
                //This is comparison between most intensive peak vs. new peak
                double heightRatio = area2/steepArea/intHeight;
                if( heightRatio>0.01 && ((isGoingUp || isHighIntensity) || areaRatio<steepRatioThreshold ) )                
                {
                    if((rightIndex+1)>=result.length || moveRightKeyIndex<0)
                    {
                        isGoingUp=false;
                        break;
                    }
                      
                    result[rightIndex] = arr[0];
                    //System.out.println("000>>" + arr[0][0]);
                    
//		    moveRightKeyIndex += numIsoWindow;
		    moveRightKeyIndex = findMRMNextKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);                    


		    if(0 == result[rightIndex][0])
			continue;
		    
		    rightIndex++;
                    
                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];

                    for(int j=0;j<arr[0].length;j++)
                        totalIntensity += arr[0][j];

                    
                    continue;                
                }
                else
                    isGoingUp=false;
                   
                if(area2/area1>steepRatioThreshold)
                {                    
                    for(int k=0;k<3;k++)
                    {          
                        if(result[rightIndex-1][1]<arr[k][1])
                            break;

			if(result.length<=rightIndex)
			    break;
                       
                        result[rightIndex] = arr[k];
                            
                        //System.out.println(arr[0][1] + " " + arr[1][1] + " " + arr[2][1] + " " + result[rightIndex-1][1]);

			//moveRightKeyIndex += numIsoWindow;
			moveRightKeyIndex = findMRMNextKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);                                            
                                
                        rightIndex++;
                    }
                     break;
                }
                    
                result[rightIndex++] = arr[0];
                                
		//moveRightKeyIndex += numIsoWindow;
		moveRightKeyIndex = findMRMNextKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);                                            

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }

        

	int peakStart = leftIndex+1;
	int peakEnd = rightIndex-1;
//System.out.println("peak start ===>>" + peakStart + " " + peakEnd);
//lSystem.out.println("peak start ===>>" + result[peakStart][0] + " " + result[peakEnd][0]);
        int dtaStart = range.getMin();
        int dtaEnd = range.getMax();
        
        
        int specSpace = (int)(result[peakStart+1][0]-result[peakStart][0]);
        
        if(specSpace==0)
            specSpace = (int)(result[peakStart][0]-result[peakStart-1][0]);
            
        int diff = (int)(result[peakStart][0]-dtaStart)/specSpace;
        int leftMargin = margin;

        int rightMargin = margin;
        if(diff>0)
            leftMargin += diff;            
     
        diff = (int)(dtaEnd-result[rightIndex-1][0])/specSpace;

        if(diff>0)
            rightMargin += diff;

        
	for(int i=0;i<leftMargin;i++)
        {   
            if(leftIndex<0 || moveLeftKeyIndex<0)
                break;

	    //if(conf.isDataIndependent()) //data independent
            result[leftIndex] = readSpectrumSpecificPeaks(moveLeftKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());                                    
	    
	    if(0 == result[leftIndex][0])
	    {
		//moveLeftKeyIndex -= numIsoWindow;                
                moveLeftKeyIndex = findMRMNextKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);                                            

		continue;
	    }

            
	    //moveLeftKeyIndex -= numIsoWindow;
            moveLeftKeyIndex = findMRMNextKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);                                            
            
            if(moveLeftKeyIndex<0)
                break;
            
            leftIndex--;
        }
        for(int i=0;i<rightMargin;i++)
        {
            if(rightIndex>=result.length || moveRightKeyIndex>=keys.length || moveRightKeyIndex<0)
                break;
                        
            result[rightIndex] = readSpectrumSpecificPeaks(moveRightKeyIndex, sModel.getIFile(), massList, conf.getMsmsSpecificTolerance());                                    
	    
	    if(0 == result[rightIndex][0])
	    {
		//moveRightKeyIndex += numIsoWindow;
                moveRightKeyIndex = findMRMNextKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);                                            

		continue;
	    }

            moveRightKeyIndex = findMRMNextKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
                                                                        
            if(moveRightKeyIndex<0)
                break;
            
            rightIndex++;
        }
        
        
        /*
        for(int i=0;i<result.length;i++)
        {
            for(int j=0;j<result[i].length;j++)
            {
                System.out.print(result[i][j] + " ");
                
            }
         
            System.out.println(" ");
        }

        
*/
        
        return buildMsmsSpecificResult(peakStart, peakEnd, leftIndex, rightIndex, result, massList);
    }
    
    //e.g. iTRAQ throughout the time
    private static String buildMsmsSpecificResult(int peakStart, int peakEnd, int leftIndex, int rightIndex, double[][] result, List massList)
    {
        StringBuffer sb = new StringBuffer();
        sb.append("P ").append((long)result[peakStart][0]).append(" ").append((long)result[peakEnd][0]).append(";");
        
        for(Iterator itr=massList.iterator(); itr.hasNext(); )
        {
            sb.append( itr.next() ).append(" ");
        }
        
        sb.setCharAt(sb.length()-1, ';');
          
        for(int i=leftIndex+1;i<rightIndex-1;i++)
	{
            //spectrum number
            sb.append((int)result[i][0]).append(" ");
            
            for(int j=1;j<result[i].length-1;j++)
            {
                sb.append((long)result[i][j]).append(" ");
            }
            
            sb.append( (long)result[i][result[i].length-1] ).append(";");            
	}

	return sb.toString();
    }

    //MSMS peak finding for MRM
    public static String peakFindingMRM(MRMPeptideModel model, Configuration conf, IndexedFile iFile) 
        throws PrecursorNotFoundException, IOException, CensusIndexOutOfBoundException, Exception
    {
        RandomAccessFile file = iFile.getFile();
        steepRatioThreshold = conf.getSteepRatioThreshold();
        int maxWindow=conf.getMaxWindow();
        int margin = conf.getMargin();
        
        double[][] result = new double[maxWindow*2+1+margin*2][4*model.getBionArr().length+3]; //scan #, sample intensity, ref intensity
        int leftIndex=maxWindow+margin;
        int rightIndex=maxWindow+margin+1;

        double totalIntensity=0;
        int[] keys = iFile.getKeys(); //sModel.getKeys();        
        int initWin=2;
       
        int steepArea = conf.getSteepArea(); 
        
        int keyIndex = model.getKeyIndex();
            
        //iFile.getPrecursorMap()
        int moveLeftKeyIndex = keyIndex;
        double[] rtArr = iFile.getRtArr();
        
        for(int i=0;i<initWin;i++) ///Index=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {            
	    if(moveLeftKeyIndex<=0 || leftIndex<=0)
	    {
                //move back to right because it cannot move to left any more
                //= findLightKey(keys, moveLeftKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
                moveLeftKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, keyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());
                
		leftIndex++;
		
		break;
	    }
            
            result[leftIndex] = readSpectrumByRt(rtArr, moveLeftKeyIndex, iFile, model);
            //readSpectrum(keys, moveLeftKeyIndex, index, findHeavyKey(keys, moveLeftKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());                                
            totalIntensity += result[leftIndex][1];
            System.out.println(iFile.getScanNumByRtIndex(moveLeftKeyIndex) + " " + totalIntensity + " " + result[leftIndex][1]);
            
            moveLeftKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveLeftKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass());
            
            leftIndex--;
        }

        int moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, keyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());
        
        for(int i=0;i<initWin;i++) //leftIndex=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
            if(moveRightKeyIndex>=rtArr.length || moveRightKeyIndex<0)
            {
		moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveRightKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass()); 
                rightIndex--;
                break;
            }

            result[rightIndex] = readSpectrumByRt(rtArr, moveRightKeyIndex, iFile, model); 
	    
            totalIntensity += result[rightIndex][1];
            //totalIntensity += result[rightIndex][2];

//System.out.println(iFile.getScanNumByRtIndex(moveRightKeyIndex) + " " + totalIntensity + " " + result[rightIndex][1]);            
	    moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveRightKeyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass()); 
            rightIndex++;
        }

	if(moveRightKeyIndex<0 && moveLeftKeyIndex<0)
	    return null;        
                  
        boolean isGoingUp=true;
        boolean isHighIntensity=true;  //if the intensity is lower than one third of average intensity, this becomes false
        double[][] arr = new double[steepArea][3];
        double[][] prevArr = new double[steepArea][3];

        if(leftIndex+steepArea>=0)
        {
            //for(int i=0;i<300;i++)
	    while(true)
            {            
                double area1=0;
                double area2=0;

                if(moveLeftKeyIndex-steepArea<0)                    
                {
                    break;                
                }

                int steepCount=0;
                int tempKeyIndex = moveLeftKeyIndex;
                while(true)
                {
		    if(tempKeyIndex<0 || steepCount<0 || steepCount>=steepArea-1)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<3;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
                        arr[steepCount] = readSpectrumByRt(rtArr, tempKeyIndex, iFile, model); 			
		    }
		    
                    steepCount++;
                    
		    tempKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, tempKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass()); 
                }

		if(tempKeyIndex<0)
		    break;

                arr[steepCount] = readSpectrumByRt(rtArr, tempKeyIndex, iFile, model);
		
		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<3;l++)
			prevArr[k][l] = arr[k][l];
		}

                for(int j=leftIndex+1;j<=leftIndex+steepCount+1;j++)
                {
                    area1 += result[j][1];                    
                    area1 += result[j][2];                    
                }

                for(int j=0;j<=steepCount;j++)
                {
                    area2 += arr[j][1];                    
                    area2 += arr[j][2];                    
                }

                if(area2==0 && area1==0)
                    break;
                
                double areaRatio = (double)area2/area1;

                /*****************************************
                 * AREA1 is right side area
                 * AREA2 is left side area
                 *****************************************/
		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;
        
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold ) 
                {
		    if(leftIndex<=0)
		    {
                        isGoingUp=false;
                        break;
		    }

                    result[leftIndex] = arr[0];
                    
                    //System.out.println("old==>>" + moveLeftKeyIndex + "\t" + rtArr[moveLeftKeyIndex]);
		    moveLeftKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveLeftKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass());                     
                    //System.out.println("new==>>" + moveLeftKeyIndex + "\t" + rtArr[moveLeftKeyIndex]);        
                    
		    if(0 == result[leftIndex][0])
			continue;
		    
		    leftIndex--;

                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];
                    
                    totalIntensity += arr[0][1];
                    totalIntensity += arr[0][2];
                    
                    continue;                    
                }
                else
                    isGoingUp=false;

                                
                if(areaRatio>steepRatioThreshold)
                {
                    for(int k=0;k<3;k++)
                    {   
                        if(result[leftIndex+1][1]<arr[k][1] || arr[k][0]==0)
                            break;

			if(leftIndex<0)
			    break;

                        result[leftIndex] = arr[k];
                        
                      //  System.out.println("old==>>" + moveLeftKeyIndex + "\t" + rtArr[moveLeftKeyIndex]);
			moveLeftKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveLeftKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass());
                        //System.out.println("new==>>" + moveLeftKeyIndex + "\t" + rtArr[moveLeftKeyIndex]);        
                        leftIndex--;
                    }
                
                    break;
                }

                result[leftIndex--] = arr[0];
                
                //System.out.println("old==>>" + moveLeftKeyIndex + "\t" + rtArr[moveLeftKeyIndex]);
		moveLeftKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveLeftKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass());
                //System.out.println("new==>>" + moveLeftKeyIndex + "\t" + rtArr[moveLeftKeyIndex]);        

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }

        isGoingUp = true;
	isHighIntensity = true;
        
        prevArr = new double[steepArea][3]; //clean up the array
                  
        if(rightIndex+steepArea<result.length)
        {
            //for(int i=0;i<500;i++)
            while(true)
            {            
                
                double area1=0;
                double area2=0;
                
                if(moveRightKeyIndex+steepArea>=rtArr.length)                    
                    break;                

                int steepCount=0;

                int tempKeyIndex = moveRightKeyIndex;
                while(true)
                {
		    if(tempKeyIndex>=rtArr.length || steepCount>= steepArea-1 || steepCount>=rtArr.length)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<3;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {                        
                        arr[steepCount] = readSpectrumByRt(rtArr, tempKeyIndex, iFile, model);
		    }

                    steepCount++;
		    //tempKeyIndex = tempKeyIndex + 1*numIsoWindow;
		    tempKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, tempKeyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());                 
                    //tempKeyIndex++;
                }

		if(tempKeyIndex>=rtArr.length)
		    break;

                arr[steepCount] = readSpectrumByRt(rtArr, tempKeyIndex, iFile, model);

		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<3;l++)
			prevArr[k][l] = arr[k][l];
		}

                for(int j=rightIndex-1;j>rightIndex-steepCount-2;j--)
                {
                    area1 += result[j][1];
                    area1 += result[j][2];
                }

                for(int j=0;j<=steepCount;j++)
                {
                    area2 += arr[j][1];
                    area2 += arr[j][2];
                }

                if(area2==0 && area1==0)
                    break;

                double areaRatio = (double)area2/area1;
                                          
                /*****************************************
                 * AREA1 is left side area
                 * AREA2 is right side area
                 *****************************************/

		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;

                //if( ((isGoingUp && (double)totalIntensity/(rightIndex-leftIndex-1)/3<area2/3)) || areaRatio<steepRatioThreshold )                 
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold )                 
                {
                    if((rightIndex+1)>=result.length)
                    {
                        isGoingUp=false;
                        break;
                    }
                      
                    result[rightIndex] = arr[0];
		    moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveRightKeyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());
                    
		    if(0 == result[rightIndex][0])
			continue;
		    
		    rightIndex++;
                    
                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];

                    //rightTotalIntensity += arr[0][1];
                    totalIntensity += arr[0][1];
                    totalIntensity += arr[0][2];
                    
                    continue;                
                }
                else
                    isGoingUp=false;
                   
                if(area2/area1>steepRatioThreshold)
                {                    
                    for(int k=0;k<3;k++)
                    {          
                        if(result[rightIndex-1][1]<arr[k][1])
                            break;

			if(result.length<=rightIndex)
			    break;
                       
                        result[rightIndex] = arr[k];
                            
                        //System.out.println(arr[0][1] + " " + arr[1][1] + " " + arr[2][1] + " " + result[rightIndex-1][1]);

			//moveRightKeyIndex += numIsoWindow;
			moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveRightKeyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());
                        
                        rightIndex++;
                    }
                     break;
                }
                    
                result[rightIndex++] = arr[0];
                                
		//moveRightKeyIndex += numIsoWindow;
		moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveRightKeyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
                
                  //System.exit(0);
                  
            }
        }
	int peakStart = leftIndex+1;
	int peakEnd = rightIndex-1;

        int leftMargin = margin;
        int rightMargin = margin;
   
        
	for(int i=0;i<leftMargin;i++)
        {   
            if(leftIndex<0 || moveLeftKeyIndex<0)
                break;
        
            result[leftIndex] = readSpectrumByRt(rtArr, moveLeftKeyIndex, iFile, model);
	    
	    if(0 == result[leftIndex][0])
	    {
		//moveLeftKeyIndex -= numIsoWindow;                
                moveLeftKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveLeftKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass());
		continue;
	    }

	    //moveLeftKeyIndex -= numIsoWindow;
            moveLeftKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveLeftKeyIndex, MOVE_LEFT, iFile, conf, model.getParentMass());
                    
            if(moveLeftKeyIndex<0)
                break;
            
            leftIndex--;
        }
        for(int i=0;i<rightMargin;i++)
        {
            if(rightIndex>=result.length || moveRightKeyIndex>=rtArr.length)
                break;
                        
            result[rightIndex] = readSpectrumByRt(rtArr, moveRightKeyIndex, iFile, model);            
	    
	    if(0 == result[rightIndex][0])
	    {
		//moveRightKeyIndex += numIsoWindow;
                moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveRightKeyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());
		continue;
	    }

	    //moveRightKeyIndex += numIsoWindow;
            moveRightKeyIndex = findMRMNextKeyIndexByPrecursor(rtArr, moveRightKeyIndex, MOVE_RIGHT, iFile, conf, model.getParentMass());
            
            if(moveRightKeyIndex<0)
                break;
            
            rightIndex++;
        }
 
  /*
        for(int i=leftIndex;i<=rightIndex;i++)
        {
            for(int j=0;j<5;j++)
                System.out.print(result[i][j] + "\t");
            
            System.out.println("");
        }

            System.out.println("");
        for(int i=peakStart;i<=peakEnd;i++)
        {
            for(int j=0;j<5;j++)
                System.out.print(result[i][j] + "\t");
            
            System.out.println("");
        }
*/
                    
        return buildMRMResult(peakStart, peakEnd, leftIndex, rightIndex, result, model.getBionArr().length);
    }
    
        
    //MSMS peak finding.  labeled. data independent
    public static String peakFindingMSMS(SpectrumModel sModel, SpecRange range, Configuration conf, int keyIndex) 
        throws PrecursorNotFoundException, IOException, CensusIndexOutOfBoundException, Exception
    {
	TIntLongHashMap index = sModel.getIndex();
	RandomAccessFile file = sModel.getFile();        
        steepRatioThreshold = conf.getSteepRatioThreshold();

//	int numIsoWindow = conf.getNumOfIsolationWindow();
        int maxWindow=conf.getMaxWindow();
        int margin = conf.getMargin();

	double[][] result = null;
        //conf.getQuantLevel()
        
	if(conf.getQuantLevel()==2)
	    result = new double[maxWindow*2+1+margin*2][4*sModel.getBioSample().length+3]; //scan #, sample intensity, ref intensity
	else
	    result = new double[maxWindow*2+1+margin*2][3];

        int leftIndex=maxWindow+margin;
        int rightIndex=maxWindow+margin+1;
        
        //double leftTotalIntensity=0;
        //double rightTotalIntensity=0;
        double totalIntensity=0;
        int[] keys = sModel.getKeys();        
        int initWin=2;
       
        int steepArea = conf.getSteepArea(); 
	
        int moveLeftKeyIndex = keyIndex;
        int moveRightKeyIndex = findLightKey(keys, keyIndex, MOVE_RIGHT, sModel.getIFile(), conf);

        IndexedFile iFile = sModel.getIFile();
        
        for(int i=0;i<initWin;i++) ///Index=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
	    if(moveLeftKeyIndex<=0 || leftIndex<=0)
	    {
                //move back to right because it cannot move to left any more
                moveLeftKeyIndex = findLightKey(keys, moveLeftKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
		leftIndex++;
		
		break;
	    }
/////	    
	    if(conf.getQuantLevel()==2)
	    {
                
		//result[leftIndex] = readSpectrum(keys, moveLeftKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());                
                result[leftIndex] = readSpectrum(keys, moveLeftKeyIndex, index, findHeavyKey(keys, moveLeftKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());                                
	    }	
	    else //data dependent
	    {
		if(sModel.isHighRes())
		    result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		else
		    result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());

	    }
            totalIntensity += result[leftIndex][1];
            totalIntensity += result[leftIndex][2];

            moveLeftKeyIndex = findLightKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
            
            leftIndex--;
        }

        for(int i=0;i<initWin;i++) //leftIndex=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
            if(moveRightKeyIndex>=keys.length || moveRightKeyIndex<0)
            {
	//	moveRightKeyIndex -= 1*numIsoWindow;
		moveRightKeyIndex = findLightKey(keys, moveRightKeyIndex, MOVE_LEFT, sModel.getIFile(), conf); 
		
                rightIndex--;

                break;
            }

	    //if(conf.isDataIndependent()) //data independent
	    if(conf.getQuantLevel()==2)
	    {
                //System.out.println("222===>>" + moveLeftKeyIndex + " " + findHeavyKey(keys, moveLeftKeyIndex, iFile, conf, conf.getCalcRefAvgMass()));                
		result[rightIndex] = readSpectrum(keys, moveRightKeyIndex, index, findHeavyKey(keys, moveRightKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
	    }
	    else //data dependent
	    {
		if(sModel.isHighRes())
		    result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		else
		    result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
	    }

            totalIntensity += result[rightIndex][1];
            totalIntensity += result[rightIndex][2];

            //moveRightKeyIndex += numIsoWindow;
	    moveRightKeyIndex = findLightKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf); 
            rightIndex++;
        }
      
	if(moveRightKeyIndex<0 && moveLeftKeyIndex<0)
	    return null;

        boolean isGoingUp=true;
        boolean isHighIntensity=true;  //if the intensity is lower than one third of average intensity, this becomes false
        double[][] arr = new double[steepArea][3];
        double[][] prevArr = new double[steepArea][3];

        if(leftIndex+steepArea>=0)
        {
            //for(int i=0;i<300;i++)
	    while(true)
            {            
                double area1=0;
                double area2=0;

                if(moveLeftKeyIndex-steepArea<0)                    
                {
                    break;                
                }

                int steepCount=0;
                int tempKeyIndex = moveLeftKeyIndex;
                while(true)
                {
		    if(tempKeyIndex<0 || steepCount<0 || steepCount>=steepArea-1)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<3;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
			if(conf.getQuantLevel()==2)
			    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, findHeavyKey(keys, tempKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
			else
			{
			    if(sModel.isHighRes())
				arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
			    else
				arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
			}            
		    }
		    
                    steepCount++;
                    //tempKeyIndex--;
//		    tempKeyIndex = tempKeyIndex - 1*numIsoWindow;
		    tempKeyIndex = findLightKey(keys, tempKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
                }

		if(tempKeyIndex<0)
		    break;

	//	if(conf.isDataIndependent()) //data independent
		if(conf.getQuantLevel()==2)
		    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, findHeavyKey(keys, tempKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
		else
		{
		    if(sModel.isHighRes())
			arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		    else
			arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
		}

		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<3;l++)
			prevArr[k][l] = arr[k][l];
		}


                for(int j=leftIndex+1;j<=leftIndex+steepCount+1;j++)
                {
                    area1 += result[j][1];                    
                    area1 += result[j][2];                    
                }

                for(int j=0;j<=steepCount;j++)
                {
                    area2 += arr[j][1];                    
                    area2 += arr[j][2];                    
                }

                if(area2==0 && area1==0)
                    break;
                
                double areaRatio = (double)area2/area1;

                /*****************************************
                 * AREA1 is right side area
                 * AREA2 is left side area
                 *****************************************/
		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;
        
                //if( (isGoingUp && (float)leftTotalIntensity/(rightIndex-leftIndex-1)/3<area2/3) || areaRatio<steepRatioThreshold ) 
                //if( (isGoingUp && (float)totalIntensity/(rightIndex-leftIndex-1)/3<area2/3) || areaRatio<steepRatioThreshold ) 
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold ) 
                {
		    if(leftIndex<=0)
		    {
                        isGoingUp=false;
                        break;
		    }

                    result[leftIndex] = arr[0];
		    moveLeftKeyIndex = findLightKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);

		    if(0 == result[leftIndex][0])
			continue;
		    
		    leftIndex--;

                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];
                    
                    totalIntensity += arr[0][1];
                    totalIntensity += arr[0][2];
                    
                    continue;                    
                }
                else
                    isGoingUp=false;

                                
                if(areaRatio>steepRatioThreshold)
                {
                    for(int k=0;k<3;k++)
                    {   
                        if(result[leftIndex+1][1]<arr[k][1] || arr[k][0]==0)
                            break;

			if(leftIndex<0)
			    break;

                        result[leftIndex] = arr[k];
                            
			//moveLeftKeyIndex -= numIsoWindow;
			moveLeftKeyIndex = findLightKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
                        leftIndex--;
                    }
                
                    break;
                }

                result[leftIndex--] = arr[0];
		moveLeftKeyIndex = findLightKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }

        isGoingUp = true;
	isHighIntensity = true;
        
        prevArr = new double[steepArea][3]; //clean up the array
        
        if(rightIndex+steepArea<result.length)
        {
            //for(int i=0;i<500;i++)
            while(true)
            {            
                double area1=0;
                double area2=0;
                
                if(moveRightKeyIndex+steepArea>=keys.length)                    
                    break;                

                int steepCount=0;

                int tempKeyIndex = moveRightKeyIndex;
                while(true)
                {
		    if(tempKeyIndex<0|| tempKeyIndex>=keys.length || steepCount>= steepArea-1 || steepCount>=keys.length)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<3;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
			if(conf.getQuantLevel()==2)
			//if(conf.isDataIndependent()) //data independent
			    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, findHeavyKey(keys, tempKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
			else if(sModel.isHighRes())
			    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
			else
			    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
		    }

                    steepCount++;
		    //tempKeyIndex = tempKeyIndex + 1*numIsoWindow;
		    tempKeyIndex = findLightKey(keys, tempKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
                    //tempKeyIndex++;
                }

		if(tempKeyIndex>=keys.length || tempKeyIndex<0)
		    break;

		//if(conf.isDataIndependent()) //data independent
		if(conf.getQuantLevel()==2)
		    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, findHeavyKey(keys, tempKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
		else if(sModel.isHighRes())
		    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		else
		    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());

		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<3;l++)
			prevArr[k][l] = arr[k][l];
		}

                for(int j=rightIndex-1;j>rightIndex-steepCount-2;j--)
                {
                    area1 += result[j][1];
                    area1 += result[j][2];
                }

                for(int j=0;j<=steepCount;j++)
                {
                    area2 += arr[j][1];
                    area2 += arr[j][2];
                }

                if(area2==0 && area1==0)
                    break;

                double areaRatio = (double)area2/area1;
                                          
                /*****************************************
                 * AREA1 is left side area
                 * AREA2 is right side area
                 *****************************************/

		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;

                //if( ((isGoingUp && (double)totalIntensity/(rightIndex-leftIndex-1)/3<area2/3)) || areaRatio<steepRatioThreshold )                 
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold )                 
                {
                    if((rightIndex+1)>=result.length)
                    {
                        isGoingUp=false;
                        break;
                    }
                      
                    result[rightIndex] = arr[0];
//		    moveRightKeyIndex += numIsoWindow;
		    moveRightKeyIndex = findLightKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);

		    if(0 == result[rightIndex][0])
			continue;
		    
		    rightIndex++;
                    
                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];

                    //rightTotalIntensity += arr[0][1];
                    totalIntensity += arr[0][1];
                    totalIntensity += arr[0][2];
                    
                    continue;                
                }
                else
                    isGoingUp=false;
                   
                if(area2/area1>steepRatioThreshold)
                {                    
                    for(int k=0;k<3;k++)
                    {          
                        if(result[rightIndex-1][1]<arr[k][1])
                            break;

			if(result.length<=rightIndex)
			    break;
                       
                        result[rightIndex] = arr[k];
                            
                        //System.out.println(arr[0][1] + " " + arr[1][1] + " " + arr[2][1] + " " + result[rightIndex-1][1]);

			//moveRightKeyIndex += numIsoWindow;
			moveRightKeyIndex = findLightKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
                        rightIndex++;
                    }
                     break;
                }
                    
		//System.out.println("2-->>peak gogo" + " " + rightIndex + " " + moveRightKeyIndex + " " + index + " " + sModel.getDiff());
                result[rightIndex++] = arr[0];
                                
		//moveRightKeyIndex += numIsoWindow;
		moveRightKeyIndex = findLightKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }
	int peakStart = leftIndex+1;
	int peakEnd = rightIndex-1;

        int dtaStart = range.getMin();
        int dtaEnd = range.getMax();
        
        
        int specSpace = (int)(result[peakStart+1][0]-result[peakStart][0]);
        
        if(specSpace==0)
            specSpace = (int)(result[peakStart][0]-result[peakStart-1][0]);
            
        int diff = (int)(result[peakStart][0]-dtaStart)/specSpace;
        int leftMargin = margin;

        int rightMargin = margin;
        if(diff>0)
            leftMargin += diff;            
     
        diff = (int)(dtaEnd-result[rightIndex-1][0])/specSpace;

        if(diff>0)
            rightMargin += diff;

        
        
	for(int i=0;i<leftMargin;i++)
        {   
            if(leftIndex<0 || moveLeftKeyIndex<0)
                break;

	    //if(conf.isDataIndependent()) //data independent
            if(conf.getQuantLevel()==2)
		result[leftIndex] = readSpectrum(keys, moveLeftKeyIndex, index, findHeavyKey(keys, moveLeftKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
	    else if(sModel.isHighRes())
		result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
	    else
		result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());

	    if(0 == result[leftIndex][0])
	    {
		//moveLeftKeyIndex -= numIsoWindow;                
                moveLeftKeyIndex = findLightKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
		continue;
	    }

            
	    //moveLeftKeyIndex -= numIsoWindow;
            moveLeftKeyIndex = findLightKey(keys, moveLeftKeyIndex, MOVE_LEFT, sModel.getIFile(), conf);
            
            if(moveLeftKeyIndex<0)
                break;
            
            leftIndex--;
        }
        for(int i=0;i<rightMargin;i++)
        {
            if(rightIndex>=result.length || moveRightKeyIndex>=keys.length || moveRightKeyIndex<0)
                break;
                        
	    //if(conf.isDataIndependent()) //data independent
            if(conf.getQuantLevel()==2)    
		result[rightIndex] = readSpectrum(keys, moveRightKeyIndex, index, findHeavyKey(keys, moveRightKeyIndex, iFile, conf, conf.getCalcRefAvgMass()), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
	    else if(sModel.isHighRes())
		result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr()); 
	    else
		result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
            
	    if(0 == result[rightIndex][0])
	    {
		//moveRightKeyIndex += numIsoWindow;
                moveRightKeyIndex = findLightKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
		continue;
	    }

            
	    //moveRightKeyIndex += numIsoWindow;
            moveRightKeyIndex = findLightKey(keys, moveRightKeyIndex, MOVE_RIGHT, sModel.getIFile(), conf);
            if(moveRightKeyIndex<0)
                break;
            
            rightIndex++;
        }
	
        
        //if(conf.isDataIndependent())
        if(conf.getQuantLevel()==2)                
	    return buildDIResult(peakStart, peakEnd, leftIndex, rightIndex, result, sModel.getBioSample().length);
	else
	    return buildDDResult(peakStart, peakEnd, leftIndex, rightIndex, result);
        
    }
    
    //peak finding for labeling + high + low res
    public static String peakFinding(SpectrumModel sModel, SpecRange range, int keyIndex)
        throws IOException, CensusIndexOutOfBoundException, Exception
    {
               
	TIntLongHashMap index = sModel.getIndex();
        Object file = sModel.getGenericIndexFile(conf);
        
        steepRatioThreshold = conf.getSteepRatioThreshold();

	int numIsoWindow = conf.getNumOfIsolationWindow();
        int maxWindow=conf.getMaxWindow();
        int margin = conf.getMargin();

	double[][] result = null;
        //conf.getQuantLevel()

	if(conf.isDataIndependent())
	    result = new double[maxWindow*2+1+margin*2][4*sModel.getBioSample().length+3]; //scan #, sample intensity, ref intensity
	else
	    result = new double[maxWindow*2+1+margin*2][3];

        int leftIndex=maxWindow+margin;
        int rightIndex=maxWindow+margin+1;
        
        
        //double leftTotalIntensity=0;
        //double rightTotalIntensity=0;
        double totalIntensity=0;

        int steepArea = conf.getSteepArea(); 
	
        int moveLeftKeyIndex = keyIndex;
               
        int moveRightKeyIndex = keyIndex+1*numIsoWindow;
        
        int[] keys = sModel.getKeys();
        int initWin=2;
       
        for(int i=0;i<initWin;i++) ///Index=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
	    if(moveLeftKeyIndex<=0 || leftIndex<=0)
	    {
		moveLeftKeyIndex += 1*numIsoWindow;
		leftIndex++;
		
		break;
	    }	
            
	    if(conf.isDataIndependent()) //data independent
	    {
		result[leftIndex] = readSpectrum(keys, moveLeftKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());

	    }	
	    else //data dependent
	    {
		if(sModel.isHighRes())
		    result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		else
		    result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());

	    }
            totalIntensity += result[leftIndex][1];
            totalIntensity += result[leftIndex][2];
            
	   // if(moveLeftKeyIndex<=0 || leftIndex<=0)
	//	break;

	    moveLeftKeyIndex -= numIsoWindow;
            leftIndex--;
        }

        for(int i=0;i<initWin;i++) //leftIndex=maxWindow;keys[leftPeakIndex]>=leftMinValue; )
        {
            if(moveRightKeyIndex>=keys.length)
            {
		moveRightKeyIndex -= 1*numIsoWindow;
                rightIndex--;

                break;
            }

	    if(conf.isDataIndependent()) //data independent
	    {
		result[rightIndex] = readSpectrum(keys, moveRightKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
	    }
	    else //data dependent
	    {
		if(sModel.isHighRes())
		    result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		else
		    result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
	    }

            totalIntensity += result[rightIndex][1];
            totalIntensity += result[rightIndex][2];

            moveRightKeyIndex += numIsoWindow;
            rightIndex++;
        }
       
        boolean isGoingUp=true;
        boolean isHighIntensity=true;  //if the intensity is lower than one third of average intensity, this becomes false
        double[][] arr = new double[steepArea][3];
        double[][] prevArr = new double[steepArea][3];

        if(leftIndex+steepArea>=0)
        {
            //for(int i=0;i<300;i++)
	    while(true)
            {            
                double area1=0;
                double area2=0;

                if(moveLeftKeyIndex-steepArea<0)                    
                {
                    break;                
                }

                int steepCount=0;
                int tempKeyIndex = moveLeftKeyIndex;
                while(true)
                {
		    if(tempKeyIndex<0 || steepCount<0 || steepCount>=steepArea-1)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<3;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
			if(conf.isDataIndependent()) //data independent
			    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
			else
			{
			    if(sModel.isHighRes())
				arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
			    else
				arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
			}            
		    }
		    
                    steepCount++;
                    //tempKeyIndex--;
		    tempKeyIndex = tempKeyIndex - 1*numIsoWindow;
                }

		if(tempKeyIndex<0)
		    break;

		if(conf.isDataIndependent()) //data independent
		    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
		else
		{
		    if(sModel.isHighRes())
			arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		    else
			arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
		}

		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<3;l++)
			prevArr[k][l] = arr[k][l];
		}


                for(int j=leftIndex+1;j<=leftIndex+steepCount+1;j++)
                {
                    area1 += result[j][1];                    
                    area1 += result[j][2];                    
                }

                for(int j=0;j<=steepCount;j++)
                {
                    area2 += arr[j][1];                    
                    area2 += arr[j][2];                    
                }

                if(area2==0 && area1==0)
                    break;
                
                double areaRatio = (double)area2/area1;

                /*****************************************
                 * AREA1 is right side area
                 * AREA2 is left side area
                 *****************************************/
		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;
        
//		System.out.println("left area==>>" + area1 + " " + area2 + " " + totalIntensity + " "  + ((double)totalIntensity/(rightIndex-leftIndex-1)/3) + " " + (rightIndex-leftIndex-1) +  " " + area2/3 + " " + isHighIntensity + " " + areaRatio + " " + isGoingUp + " " + isHighIntensity + " " + (areaRatio<steepRatioThreshold)  + " " + result[leftIndex+1][0]);
                //if( (isGoingUp && (float)leftTotalIntensity/(rightIndex-leftIndex-1)/3<area2/3) || areaRatio<steepRatioThreshold ) 
                //if( (isGoingUp && (float)totalIntensity/(rightIndex-leftIndex-1)/3<area2/3) || areaRatio<steepRatioThreshold ) 
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold ) 
                {
		    if(leftIndex<=0)
		    {
                        isGoingUp=false;
                        break;
		    }

		    //System.out.println("peak gogo" + " " + leftIndex + " " + moveLeftKeyIndex + " " + index + " " + sModel.getDiff());
                    result[leftIndex] = arr[0];
		    moveLeftKeyIndex -= numIsoWindow;

		    if(0 == result[leftIndex][0])
			continue;
		    
		    leftIndex--;

                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];
                    
                    totalIntensity += arr[0][1];
                    totalIntensity += arr[0][2];
                    
                    continue;                    
                }
                else
                    isGoingUp=false;

                                
                if(areaRatio>steepRatioThreshold)
                {
                    for(int k=0;k<3;k++)
                    {   
                        if(result[leftIndex+1][1]<arr[k][1] || arr[k][0]==0)
                            break;

			if(leftIndex<0)
			    break;

                        result[leftIndex] = arr[k];
                            
			moveLeftKeyIndex -= numIsoWindow;
                        leftIndex--;
                    }
                
                    break;
                }

                result[leftIndex--] = arr[0];

		moveLeftKeyIndex -= numIsoWindow;

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }

	prevArr = new double[steepArea][3]; //clean up the array

        isGoingUp = true;
	isHighIntensity = true;
        if(rightIndex+steepArea<result.length)
        {
            //for(int i=0;i<500;i++)
            while(true)
            {            
                double area1=0;
                double area2=0;
                
                if(moveRightKeyIndex+steepArea>=keys.length)                    
                    break;                

                int steepCount=0;

                int tempKeyIndex = moveRightKeyIndex;
                while(true)
                {
		    if(tempKeyIndex>=keys.length || steepCount>= steepArea-1 || steepCount>=keys.length)
			break;

		    if(prevArr[0][0]!=0)
		    {
			for(int l=0;l<2;l++)
			    for(int m=0;m<3;m++)
				arr[l][m] = prevArr[l+1][m];
		    }
		    else
		    {
			if(conf.isDataIndependent()) //data independent
			    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
			else if(sModel.isHighRes())
			    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
			else
			    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
		    }

                    steepCount++;
		    tempKeyIndex = tempKeyIndex + 1*numIsoWindow;
                    //tempKeyIndex++;
                }

		if(tempKeyIndex>=keys.length)
		    break;

		if(conf.isDataIndependent()) //data independent
		    arr[steepCount] = readSpectrum(keys, tempKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
		else if(sModel.isHighRes())
		    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
		else
		    arr[steepCount] = readFullSpectrum(keys, tempKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());

		for(int k=0;k<3;k++)
		{
		    for(int l=0;l<3;l++)
			prevArr[k][l] = arr[k][l];
		}

                for(int j=rightIndex-1;j>rightIndex-steepCount-2;j--)
                {
                    area1 += result[j][1];
                    area1 += result[j][2];
                }

                for(int j=0;j<=steepCount;j++)
                {
                    area2 += arr[j][1];
                    area2 += arr[j][2];
                }

                if(area2==0 && area1==0)
                    break;

                double areaRatio = (double)area2/area1;
                                          
                /*****************************************
                 * AREA1 is left side area
                 * AREA2 is right side area
                 *****************************************/

		if(isHighIntensity && ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5>area2/3))
		    isHighIntensity = false;

		//System.out.println("right area==>>" + area1 + " " + area2 + " " + totalIntensity + " "  + ((double)totalIntensity/(rightIndex-leftIndex-1)/1.5) + " " + (rightIndex-leftIndex-1) +  " " + area2/3 + " " + isHighIntensity + " " + areaRatio + " " + isGoingUp + " " + isHighIntensity + " " + (areaRatio<steepRatioThreshold) );

                //if( ((isGoingUp && (double)totalIntensity/(rightIndex-leftIndex-1)/3<area2/3)) || areaRatio<steepRatioThreshold )                 
                if( (isGoingUp && isHighIntensity) || areaRatio<steepRatioThreshold )                 
                {
                    if((rightIndex+1)>=result.length)
                    {
                        isGoingUp=false;
                        break;
                    }
                      
                    result[rightIndex] = arr[0];
		    moveRightKeyIndex += numIsoWindow;

		    if(0 == result[rightIndex][0])
			continue;
		    
		    rightIndex++;
                    
                    for(int j=0;j<steepCount;j++)
                        arr[j] = arr[j+1];

                    //rightTotalIntensity += arr[0][1];
                    totalIntensity += arr[0][1];
                    totalIntensity += arr[0][2];
                    
                    continue;                
                }
                else
                    isGoingUp=false;
                   
                if(area2/area1>steepRatioThreshold)
                {                    
                    for(int k=0;k<3;k++)
                    {          
                        if(result[rightIndex-1][1]<arr[k][1])
                            break;

			if(result.length<=rightIndex)
			    break;
                       
                        result[rightIndex] = arr[k];
                            
                        //System.out.println(arr[0][1] + " " + arr[1][1] + " " + arr[2][1] + " " + result[rightIndex-1][1]);

			moveRightKeyIndex += numIsoWindow;
                        rightIndex++;
                    }
                     break;
                }
                    
                result[rightIndex++] = arr[0];
                                
		moveRightKeyIndex += numIsoWindow;

                for(int j=0;j<steepCount;j++)
                    arr[j] = arr[j+1];
            }
        }
	int peakStart = leftIndex+1;
	int peakEnd = rightIndex-1;

        int dtaStart = (range==null?0:range.getMin());
        int dtaEnd = (range==null?0:range.getMax());
        int specSpace = (int)(result[peakStart+1][0]-result[peakStart][0]);

//System.out.println( result[peakStart+1][0] + " " + result[peakStart][0] );
        int diff = (int)(result[peakStart][0]-dtaStart)/specSpace;
        int leftMargin = margin;

        int rightMargin = margin;
        if(diff>0)
            leftMargin += diff;            
     
        diff = (int)(dtaEnd-result[rightIndex-1][0])/specSpace;

        if(diff>0)
            rightMargin += diff;
        
	for(int i=0;i<leftMargin;i++)
        {   
            if(leftIndex<0 || moveLeftKeyIndex<0)
                break;

	    if(conf.isDataIndependent()) //data independent
		result[leftIndex] = readSpectrum(keys, moveLeftKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
	    else if(sModel.isHighRes())
		result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr());
	    else
		result[leftIndex] = readFullSpectrum(keys, moveLeftKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());

	    if(0 == result[leftIndex][0])
	    {
		moveLeftKeyIndex -= numIsoWindow;
		continue;
	    }

            leftIndex--;
	    moveLeftKeyIndex -= numIsoWindow;
        }
        for(int i=0;i<rightMargin;i++)
        {
            if(rightIndex>=result.length || moveRightKeyIndex>=keys.length)
                break;
            
	    if(conf.isDataIndependent()) //data independent
		result[rightIndex] = readSpectrum(keys, moveRightKeyIndex, index, sModel.getDiff(), file, sModel.getBioSample(), sModel.getBioRef(), sModel.getYioSample(), sModel.getYioRef());
	    else if(sModel.isHighRes())
		result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamIsoArr(), sModel.getRefIsoArr()); 
	    else
		result[rightIndex] = readFullSpectrum(keys, moveRightKeyIndex, index, file, sModel.getSamStartMass(), sModel.getSamEndMass(), sModel.getRefStartMass(), sModel.getRefEndMass());
            
	    if(0 == result[rightIndex][0])
	    {
		moveRightKeyIndex += numIsoWindow;
		continue;
	    }

            rightIndex++;
	    moveRightKeyIndex += numIsoWindow;
        }
	if(conf.isDataIndependent())
	    return buildDIResult(peakStart, peakEnd, leftIndex, rightIndex, result, sModel.getBioSample().length);
	else
	    return buildDDResult(peakStart, peakEnd, leftIndex, rightIndex, result);
    }

    
    //non-labeling for low resolution and full ms
    public static String calculateNonlabelMS(
            int keyIndex,
            String fileName,
            Hashtable<String, IndexedFile> htInput,
            int[][][] pathArrayInput,
            double startMass,
            double endMass,
            SpecRange range,
            String pathInput)            
        throws IOException, Exception
    {
        ht = htInput;
        
        conf = Configuration.getInstance();
        align = conf.isAlign();

        massTolerance = conf.getMassTolerance();
        pathArray = pathArrayInput;
        pathFileName = pathInput + fileName;        
        
        SpectrumModel sModel = new SpectrumModel();
        sModel.setHighRes(false);
        sModel.setSamStartMass(startMass);
        sModel.setSamEndMass(endMass);
	
        return peakFinding(sModel, range, conf, keyIndex, null);   
    }

    //non-labeling for full ms
    public static String calculateNonlabelMS(
            int keyIndex,
            String fileName,
            Hashtable<String, IndexedFile> htInput,
            int[][][] pathArrayInput,
            double[] samIsoArr,
            SpecRange range,
            String pathInput)            
        throws IOException, Exception
    {
        ht = htInput;
        
        conf = Configuration.getInstance();
        align = conf.isAlign();

        
        massTolerance = conf.getMassTolerance();
        pathArray = pathArrayInput;
        pathFileName = pathInput + fileName;        
        
        return peakFinding(null, range, conf, keyIndex, samIsoArr);   
    }
    
    //non-labeling for tandem scans
    public static String calculateNonlabelMS(
            int keyIndex,
            String fileName,
            Hashtable<String, IndexedFile> htInput,
            int[][][] pathArrayInput,
            double[] samIsoArr,
            SpecRange range,
            String pathInput,
            double[][] bionSample,
//            double[][] bionRef,
            double[][] yionSample,
//            double[][] yionRef,
            IndexedFile iFile)                        
        throws IOException, Exception
    {
        ht = htInput;
                
        conf = Configuration.getInstance();
        align = conf.isAlign();

        
        massTolerance = conf.getMassTolerance();
        pathArray = pathArrayInput;
        pathFileName = pathInput + fileName;                
                
        SpectrumModel sModel = new SpectrumModel();
	sModel.setHighRes(false);
    
	//sModel.setKeys(keys);
	//sModel.setIndex(index);
	sModel.setIFile(iFile);
	//sModel.setFile(file);
  /*    
      for(int i=0;i<bionSample.length;i++)
      {
	  for(int j=0;j<bionSample[i].length;j++)
	      System.out.print(" " + bionSample[i][j]);

	  System.out.println("");
      }
*/
        sModel.setBioSample(bionSample);
        sModel.setYioSample(yionSample);
 //       sModel.setBioRef(bionRef);
 //       sModel.setYioRef(yionRef);
        
        //sModel.setDiff(diff);
        	
        return peakFinding(sModel, range, conf, keyIndex, samIsoArr);   
        //return null;
        

        
    }
    
    public static String calculateFullMS(
            int keyIndex,
            IndexedFile iFile,
            double[] samIsoArr, 
	    double[] refIsoArr, 
            SpecRange range)
            
        throws IOException, CensusIndexOutOfBoundException, Exception
    {
        TIntLongHashMap index = iFile.getMsIndex();
        RandomAccessFile file = iFile.getFile();
        MzxmlSpectrumReader mzReader = iFile.getMzreader();
        int[] keys = iFile.getKeys();
        conf = Configuration.getInstance();
        massTolerance = conf.getMassTolerance();
        
        SpectrumModel sModel = new SpectrumModel();
        sModel.setHighRes(true);
        sModel.setKeys(keys);
        sModel.setIndex(index);
        sModel.setIFile(iFile);
        sModel.setFile(file);
        sModel.setMzxmlreader(mzReader);
        sModel.setSamIsoArr(samIsoArr);
        sModel.setRefIsoArr(refIsoArr);
        
        return peakFinding(sModel, range, keyIndex);
    }

    public static void getSpectrumArr(int[] keys, int curIndex, TIntLongHashMap index, Object ofile) throws IOException, CensusIndexOutOfBoundException
    {
	RandomAccessFile file = (RandomAccessFile)ofile;
       
	if(keys.length<=curIndex)
	    throw new CensusIndexOutOfBoundException();

        long startPos = index.get(keys[curIndex]);
        long endPos;

        file.seek(startPos);
       
        if( (curIndex+1)>=keys.length )
            endPos = file.length();
        else
            endPos = index.get(keys[curIndex+1]);        

        int byteSize = (int)(endPos-startPos);
        
        byte[] bytes = new byte[byteSize];
        file.readFully(bytes);

        char ch;
        int pos=0;
        
        ch = (char)bytes[pos];

        //Remove Z, S, I, D lines
        while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
        {            
            while( ch != CARRIAGE_RETURN )
            {
                pos++;
                ch = (char)bytes[pos];
            }

            pos++;
        }

        StringBuilder mass = new StringBuilder(10);
        StringBuilder intensity = new StringBuilder(10);
	intensity.append('0');

        boolean isMass=true;
        boolean isInt=true;

        int arrSize=0;
        for(int j=pos;j<byteSize;j++)
        {
            if( CARRIAGE_RETURN == (char)bytes[j] )
                arrSize++;
        }
        
        massArr = new double[arrSize];
        intArr = new double[arrSize];
        int massIndex=0;
       
	int spaceCount=0;

        for(int i=pos;i<byteSize;i++)
        {
            ch = (char)bytes[i];

            switch(ch)
            {
		case WINDOW_CR:
		    break;
                    
                case SPACE:
		    spaceCount++;
                    isMass=false;
                    isInt=true;
                    break;

                case CARRIAGE_RETURN:
		    spaceCount=0;
                    isMass=true;
                    isInt=true;

                    intArr[massIndex] = Long.parseLong(intensity.toString());
                    massArr[massIndex++] = Double.parseDouble(mass.toString());

                    mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
                    intensity.delete(0, intensity.length()).append('0');

                    break;

                case DOT:
                    isInt=false;
                    
                default:
		    if(spaceCount>=2)
			break;

                    if(isMass)
                        mass.append(ch);
                    else if(isInt) //remove decimal value of intensity
                        intensity.append(ch);

                    break;
            }
        }   

    }


    //Low resolution for label free only for now
    //for both full and tandem
    //
    public static double[] readSpectrum(
            SpectrumModel sModel,
            //int[] keys, 
            int curIndex
            //TIntLongHashMap index
            //int diff, 
            //int refIndexKey,
            //RandomAccessFile file
            
            ) throws IOException, CensusIndexOutOfBoundException
    {   
	if(curIndex<0)
	    return null;

        double[][] bioSample = sModel.getBioSample();
        double[][] yioSample = sModel.getYioSample();

        NonLabelMappingModel mapModel = conf.getMapModel();        
        Vector<String> arr = mapModel.getPathFileNameList();
        
        int ionLength = bioSample.length;
        double[] tmpArr = null;
        
        Hashtable<String, Set> childHt = null;	
	double precursor=-1;
	IndexedFile iFile = null;

	//ION_START_INDEX = arr.size();
	
        
        if(conf.getQuantLevel()==2)
	{
            childHt = mapModel.getChildHashtableByMS2(pathFileName, curIndex);
            ION_START_INDEX = arr.size();
	
                    
	    tmpArr = new double[ionLength*2*arr.size()+ION_START_INDEX*2]; //scan arr, intsum arr, sam1 b y arr, sam2 by arr, ..; repeat
            
	    iFile = sModel.getIFile();
	    precursor = iFile.getPrecursorMap().get(iFile.getKeys()[curIndex]);
	}
        else
	{
            childHt = mapModel.getChildHashtable(pathFileName, curIndex);
            
	    tmpArr = new double[arr.size()*2];
	}
        
        if(null == childHt)
            return tmpArr;

        int refIndex = mapModel.getRefIndex();

       // for(int i=0;i<samIsoArr.length;i++)
       //     System.out.println("-->> " + samIsoArr[i]);

        int tmpIndex=0;
        int targetIndex=1;

        for(Iterator<String> itr=arr.iterator(); itr.hasNext(); )
        {
            String eachName = itr.next();

	//    if(conf.getQuantLevel()==2)
	//	eachName = eachName.replace(".ms2", ".ms1");

            Set<Integer> tmpSet = childHt.get(eachName);


            IndexedFile tmpIndexFile = ht.get(eachName);
            int[] keys = tmpIndexFile.getKeys();
            RandomAccessFile file = tmpIndexFile.getFile();
            TIntLongHashMap index = tmpIndexFile.getMsIndex();
	    TIntDoubleHashMap p = tmpIndexFile.getPrecursorMap();

            int count=0;
            double intensity=0;

            int firstIndex=0;
            int firstScanIndex=0;
           
	    int ms2MapIndex = -1; // for tandem quant
            
	    
            for(Iterator<Integer> indItr = tmpSet.iterator(); indItr.hasNext(); )
            {
                Integer eachIndex = indItr.next();
    
		//if(tandem)
		if(conf.getQuantLevel()==2)
		{
		    if(firstIndex ==0)
		    {
			firstScanIndex = eachIndex.intValue()-1;
			if(eachIndex<=0)
			    firstScanIndex=0;
			                                                                                    
			firstScanIndex = mapModel.getMs2Index(eachName, firstScanIndex, precursor, conf.getMassTolerance(), ht.get(eachName)); //index
                        if(firstScanIndex<0)
                            return tmpArr;
                        
			firstIndex = ht.get(eachName).getKeys()[firstScanIndex]; //scan number
                        
                        //System.out.println(eachIndex.intValue()  + " " + firstScanIndex);
		    }

		    ms2MapIndex = mapModel.getMs2Index(eachName, eachIndex.intValue(), precursor, conf.getMassTolerance(), ht.get(eachName));

                    tmpArr[tmpIndex] = keys[ms2MapIndex]; //scan number
                    //System.out.println(keys[ms2MapIndex]);
                    
		    //update massarr
		    getSpectrumArr(keys, ms2MapIndex, index, file);
		}
		else
		{
		    if(firstIndex ==0)
		    {
			firstScanIndex = eachIndex.intValue()-1;

			firstIndex = keys[firstScanIndex];
		    }

                    //update massarr
		    getSpectrumArr(keys, eachIndex.intValue(), index, file);
		}
                
		//System.out.println("each name--" + mapModel.getMs2Index(eachName, eachIndex.intValue(),  );

		//                intensity += intensitySum(massArr, intArr, samIsoArr);
		//System.out.println(intensity);

		count++;
	    }


	    count++;

	    long sampleSum=0;
	    if(tmpIndex==refIndex)
            {
		int tmpScanIndex;
		if(conf.getQuantLevel()==2)
		    tmpScanIndex = ms2MapIndex;
		else
		    tmpScanIndex = tmpSet.iterator().next().intValue()-1;
		
		//System.out.println("each name-------" + tmpScanIndex + " " + keys[tmpScanIndex]);
                

		if(conf.getQuantLevel()==2)
		{
		    if(conf.isAlign())
		    {
			//tmpArr[0] = keys[tmpScanIndex];  


                //        System.out.println(tmpScanIndex + " ----"  + keys[tmpScanIndex]);
                            
			for(int k=0;k<bioSample.length;k++)
			{                
                            //tmpArr[k] = keys[tmpScanIndex];  //scan number
                            
                            int bIndex = ION_START_INDEX*2+k;
                            int yIndex = ION_START_INDEX*2+ionLength+k;
                            
			    tmpArr[bIndex] = intensitySum(massArr, intArr, bioSample[k][1], bioSample[k][2]);
			    sampleSum += tmpArr[bIndex];
			    tmpArr[yIndex] = intensitySum(massArr, intArr, yioSample[k][1], yioSample[k][2]); 
			    sampleSum += tmpArr[yIndex];

                            
//System.out.println("==11== " + bIndex + " " + yIndex);
			    //	sampleSum += tmpArr[ION_START_INDEX+bioSample.length+k];
			}   

			tmpArr[ION_START_INDEX] = sampleSum;
  //                      System.out.println("sample1--" + ION_START_INDEX + " " + sampleSum);
		    }
		    else
		    {
			System.out.println("non alignment for tandem spectra is not supported yet. contact to rpark@scripps.edu");
		    }

		}
		else
		{
		    if(conf.isAlign())
		    {
			tmpArr[0] = keys[tmpScanIndex];
		    }
		    else
		    {
			tmpArr[0] = conf.getRetArr()[tmpIndex][tmpScanIndex]*100;

		    }

		}
            }
            else
            {
		if(conf.getQuantLevel()==2)
		{
		    for(int k=0;k<bioSample.length;k++)
		    {       
                        
                        int bIndex = ION_START_INDEX*2+k+ionLength*(targetIndex*2);
                        int yIndex = ION_START_INDEX*2+k+ionLength*(targetIndex*2+1);

			tmpArr[bIndex] = intensitySum(massArr, intArr, bioSample[k][1], bioSample[k][2]);
			sampleSum += tmpArr[bIndex];
			tmpArr[yIndex] = intensitySum(massArr, intArr, yioSample[k][1], yioSample[k][2]); 
			sampleSum += tmpArr[yIndex];
//System.out.println("==22== " + bIndex + " " + yIndex + " " + targetIndex);

		    }   
		    
                    
		    tmpArr[ION_START_INDEX+ targetIndex] = sampleSum;                    
                    //System.out.println("sample--" + (ION_START_INDEX+ targetIndex) + " " + sampleSum);
		}
		else
		{
		    if(conf.isAlign())
		    {
			tmpArr[targetIndex] = firstIndex;
                        
                        System.out.println(firstIndex);

		    }
		    else
		    {
			tmpArr[targetIndex] = conf.getRetArr()[tmpIndex][firstScanIndex]*100;
		    }

		}

		targetIndex++;
            }

            tmpArr[tmpArr.length/2 + tmpIndex] = intensity/count;
            tmpIndex++;
        }


        return tmpArr;        
    }   
    
    //High resolution for non-labeling only 
    //Low resolution, too now.
    //There is no reference
    public static double[] readFullSpectrum(
            int curIndex, 
            TIntLongHashMap nouseindex, 
            RandomAccessFile nousefile,
            double[] samIsoArr,
            NonLabelMappingModel mapModel,
            SpectrumModel sModel,
	    Hashtable<Integer, double[]> resultHt 
            ) throws IOException, CensusIndexOutOfBoundException
    {                               
        //populate massarr field
        
//	getSpectrumArr(keys, curIndex, index, file);
        Vector<String> arr = mapModel.getPathFileNameList();

        double[] tmpArr = new double[arr.size()*2];
                
        Hashtable<String, Set> childHt = mapModel.getChildHashtable(pathFileName, curIndex);
        
        if(null == childHt)
            return tmpArr;
        
        int refIndex = mapModel.getRefIndex();

//	System.out.println( "11--->>" + arr.get(refIndex) );
//	System.out.println( "22--->>" + childHt.get(arr.get(refIndex)) );

	int hashCode = childHt.get(arr.get(refIndex)).hashCode();
	double[] setArr = resultHt.get(hashCode);
	if(null != setArr)
	    return setArr;

       // for(int i=0;i<samIsoArr.length;i++)
       //     System.out.println("-->> " + samIsoArr[i]);
        
        int tmpIndex=0;
        int targetIndex=1;
        
        for(Iterator<String> itr=arr.iterator(); itr.hasNext(); )
        {
            String eachName = itr.next();
            Set<Integer> tmpSet = childHt.get(eachName);        

//	    System.out.println("===>>" + tmpSet);
//	    System.out.println("ref ===>>" + tmpSet);

            
	    IndexedFile tmpIndexFile = ht.get(eachName); 

	    int[] keys = tmpIndexFile.getKeys();
            
	    RandomAccessFile file = tmpIndexFile.getFile();
	    TIntLongHashMap index = tmpIndexFile.getMsIndex();

            int count=0;
            double intensity=0;
                        
            int firstIndex=0;
            int firstScanIndex=0;
	    for(Iterator<Integer> indItr = tmpSet.iterator(); indItr.hasNext(); )
	    {
		Integer eachIndex = indItr.next();
                
                if(firstIndex ==0)
                {
                    firstScanIndex = eachIndex.intValue()-1;

		    if(firstScanIndex>=keys.length)
			firstIndex = keys[keys.length-1];
		    else
			firstIndex = keys[firstScanIndex];
                }
               
		
		if(eachIndex>=keys.length)
		    continue;

		getSpectrumArr(keys, eachIndex.intValue(), index, file);

                   
                //double[] tempArr = null;
                
                if(conf.isHighRes())
                {
                    double[] tempArr = intensitySum(massArr, intArr, samIsoArr);                
                    intensity += tempArr[0];  
                }
                else
                    intensity += intensitySum(massArr, intArr, sModel.getSamStartMass(), sModel.getSamEndMass());                
                    
                //
                //System.out.println(intensity);
                
                count++;
	    }                 
           
            if(tmpIndex==refIndex)
            {                
		int tmpScanIndex = tmpSet.iterator().next().intValue()-1;

		if(tmpScanIndex>=keys.length)
		    continue;

                if(conf.isAlign())
                    tmpArr[0] = keys[tmpScanIndex];
                else
                    tmpArr[0] = conf.getRetArr()[tmpIndex][tmpScanIndex]*100; 
            }
            else
            {
                if(conf.isAlign())
                {
                    tmpArr[targetIndex] = firstIndex;
                    
                }
                else
                {                    
                    tmpArr[targetIndex] = conf.getRetArr()[tmpIndex][firstScanIndex]*100;
                }
                
                targetIndex++;
                
            }
                        
            tmpArr[tmpArr.length/2 + tmpIndex] = intensity/count;
            tmpIndex++;                        
	    //if(true)
	//	throw new CensusIndexOutOfBoundException();

        }
            
	resultHt.put(hashCode, tmpArr);

        return tmpArr;        
    }

   
    //High resolution //lalebling data 
    public static double[] readFullSpectrum(
            int[] keys, 
            int curIndex, 
            TIntLongHashMap index, 
            //RandomAccessFile file,
            Object reader,
            double[] samIsoArr, 
	    double[] refIsoArr
            ) throws IOException, CensusIndexOutOfBoundException, Exception
    {                       

	double result[] = new double[9];
	if(curIndex<0)
	    return result;
        
	if(reader instanceof RandomAccessFile)
	{
	    getSpectrumArr(keys, curIndex, index, reader);
	}
	else if(reader instanceof MzxmlSpectrumReader)
	{
	    MzxmlSpectrumReader mzReader = (MzxmlSpectrumReader)reader;
	    readFullSpectrumMzXml(keys, curIndex, mzReader); 
	}
        
	result[0] = keys[curIndex];
	double[] tempArr = intensitySum(massArr, intArr, samIsoArr);        
        result[1] = tempArr[0];     //intensity
        result[3] = samIsoArr.length;
        result[5] = tempArr[1];      //Found iso num 
        result[7] = tempArr[2];	     //tolerance
               
	if(null != refIsoArr) {
	    tempArr = intensitySum(massArr, intArr, refIsoArr);
	    result[2] = tempArr[0];
	    result[4] = refIsoArr.length;
	    result[6] = tempArr[1];
	    result[8] = tempArr[2];
	}
      
      /*
    System.out.println("============");
    System.out.println("============");
    System.out.println("============");
    System.out.println("============");
    System.out.println("============");
    System.out.println("============");
    System.out.println("============" + keys[curIndex]);

    if(keys[curIndex]==4294) {
    for(double d : result)
	System.out.println(d);

    System.exit(0);
}
*/

	return result;
    }    

    //high resolution
    public static void readFullSpectrumMzXml(
            int[] keys, 
            int curIndex, 
            MzxmlSpectrumReader mzReader
            ) throws IOException, Exception 
    {               
        double result[] = new double[3];

	MzxmlPeakList pList = mzReader.scanNum2PeakList(keys[curIndex], false);

	MZXmlHandler.NativePeakList nPeakList = MZXmlHandler.decode32ToArr(pList.getEncodedM2zAndIntensities());

	intArr = nPeakList.getIntArr();
	massArr = nPeakList.getMassArr();

    }

    //Low resolution
    public static double[] readFullSpectrum(
            int[] keys, 
            int curIndex, 
            TIntLongHashMap index, 
//           RandomAccessFile file,
            Object reader,
            double samStartMass, double samEndMass, 
            double refStartMass, double refEndMass
            ) throws IOException, Exception
    {                       
	if(reader instanceof RandomAccessFile)
	{
	    RandomAccessFile rFile = (RandomAccessFile)reader;
	    return readFullSpectrumMS(keys, curIndex, index, rFile, samStartMass, samEndMass, refStartMass, refEndMass); 
	}
	else if(reader instanceof MzxmlSpectrumReader)
	{
	    MzxmlSpectrumReader mzReader = (MzxmlSpectrumReader)reader;

	    return readFullSpectrumMzXml(keys, curIndex, mzReader, samStartMass, samEndMass, refStartMass, refEndMass); 
	}

	return null;
    }

    //Low resolution
    public static double[] readFullSpectrumMzXml(
            int[] keys, 
            int curIndex, 
            MzxmlSpectrumReader mzReader,
            double samStartMass, double samEndMass, 
            double refStartMass, double refEndMass
            ) throws IOException, Exception 
    {               

        double result[] = new double[3];

	if(curIndex<0)
	    return result;

	MzxmlPeakList pList = mzReader.scanNum2PeakList(keys[curIndex], false);

	MZXmlHandler.NativePeakList nPeakList = MZXmlHandler.decode32ToArr(pList.getEncodedM2zAndIntensities());

	double[] intArr = nPeakList.getIntArr();
	double[] massArr = nPeakList.getMassArr();

        result[0] = keys[curIndex];
        result[1] = intensitySum(massArr, intArr, samStartMass, samEndMass);
        result[2] = intensitySum(massArr, intArr, refStartMass, refEndMass);
       
       return result;
    }

    //Low resolution
    public static double[] readFullSpectrumMS(
            int[] keys, 
            int curIndex, 
            TIntLongHashMap index, 
            RandomAccessFile file,
            double samStartMass, double samEndMass, 
            double refStartMass, double refEndMass
            ) throws IOException            
    {                       
	    
//	RandomAccessFile file = (RandomAccessFile)ofile;
        
        double result[] = new double[3];

	if(curIndex<0)
	    return result;

        long startPos = index.get(keys[curIndex]);
        long endPos;
        //System.out.println("keys==>>>" + curIndex + " "  + keys.length + " "  + keys[curIndex] + " " + startPos);

        file.seek(startPos);

        if( (curIndex+1)>=keys.length )
            endPos = file.length();
        else
            endPos = index.get(keys[curIndex+1]);        

        int byteSize = (int)(endPos-startPos);
        byte[] bytes = new byte[byteSize];

        file.readFully(bytes);

        char ch;
        int pos=0;

        ch = (char)bytes[pos];

        //Remove Z, S, I, D lines
        while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
        {
            while( ch != CARRIAGE_RETURN )
            {
                pos++;
                ch = (char)bytes[pos];
            }

            pos++;
        }

        int arrSize=0;
        for(int j=pos;j<byteSize;j++)
        {
            if( CARRIAGE_RETURN == (char)bytes[j] )
                arrSize++;
        }

    
        buildSpec(arrSize, byteSize, bytes, pos);
        
        
        result[0] = keys[curIndex];        
        result[1] = intensitySum(massArr, intArr, samStartMass, samEndMass);
        result[2] = intensitySum(massArr, intArr, refStartMass, refEndMass);
        
        if(conf.isUseProline()) {
            double[] addArr = conf.getAddtionalRefMassArr();
            if(null != addArr) {                
                for(int i=0;i<addArr.length;i+=2) {
                    result[2] += intensitySum(massArr, intArr, addArr[i], addArr[i+1]);
                    
                    //System.out.println(i + " " + (i+1) + " " + addArr[i] +  " " + addArr[i+1]);
                }
            }
        }
        
        return result;
        
    }    
    
    private static void buildSpec(int arrSize, int byteSize, byte[] bytes, int pos)
    {
        
        massArr = new double[arrSize];
        intArr = new double[arrSize];
        int massIndex=0;
        char ch;

        StringBuilder mass = new StringBuilder(10);
        StringBuilder intensity = new StringBuilder(10);
	intensity.append('0');
        
        boolean isMass=true;
        boolean isInt=true;
        
        int spaceCount=0;
	
        if( hasChargeCol )
        {
            for(int i=pos;i<byteSize;i++)
            {
                ch = (char)bytes[i];

                switch(ch)
                {
                    case WINDOW_CR:
                        break;

                    case SPACE:
                        spaceCount++;
                        isMass=false;
                        isInt=true;
                        break;

                    case CARRIAGE_RETURN:
                        spaceCount=0;
                        isMass=true;
                        isInt=true;

                        intArr[massIndex] = Long.parseLong(intensity.toString());
                        massArr[massIndex++] = Double.parseDouble(mass.toString());

                        mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
                        intensity.delete(0, intensity.length()).append('0');

                        break;

                    case DOT:
                        isInt=false;

                    default:
                        if(spaceCount>=2)
                            break;

                        if(isMass)
                            mass.append(ch);
                        else if(isInt) //remove decimal value of intensity
                            intensity.append(ch);

                        break;
                }
            }   
        }
        else
        {        
            for(int i=pos;i<byteSize;i++)
            {
                ch = (char)bytes[i];

                switch(ch)
                {
                    case WINDOW_CR:
                        break;

                    case SPACE:
                        isMass=false;
                        isInt=true;
                        break;

                    case CARRIAGE_RETURN:
                        isMass=true;
                        isInt=true;

                        intArr[massIndex] = Long.parseLong(intensity.toString());
                        massArr[massIndex++] = Double.parseDouble(mass.toString());

                        mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
                        intensity.delete(0, intensity.length()).append('0');

                        break;

                    case DOT:
                        isInt=false;

                    default:
                        if(isMass)
                            mass.append(ch);
                        else if(isInt) //remove decimal value of intensity
                            intensity.append(ch);

                        break;
                }
            }    
        }
    }
    
    public static double intensitySum(double[] massArr, double[] intArr, double startMass, double endMass)
    {
        double sumIntensity=0;
      
        
            //System.out.println("b-->>" + bioSample[k][1] + " " + bioSample[k][2]);
            //System.out.println("y-->>" + yioSample[k][1] + " " + yioSample[k][2]);
            
            
        //Sum sample intensity
        int start = Arrays.binarySearch(massArr, startMass);        
        int end = Arrays.binarySearch(massArr, endMass);        

        //System.out.println(startMass + " " + endMass);
        if(start<0)
            start = -start -1;

        if(end<0)
            end = -end -2;

        for(int i=start;i<=end;i++)
        {
            sumIntensity += intArr[i];
          //  System.out.println(intArr[i]);
        }
        
        //System.out.println("sum---" + sumIntensity);
        
        return sumIntensity;
    }

    //return arr of intensity from spectrum
    public static double[] intensityArr(double[] massArr, double[] intArr, double[] isoArr, double massTolerance)
    {
        double[] resultArr = new double[isoArr.length];
        
        int foundIsoNum=0; 
        int totalPeakFound=0;
        double toleranceSum=0;

	int isoIndex=0;
        
	for(int i=0;i<isoArr.length;i++)
	{
            double tempTolerance = isoArr[i]/1000*massTolerance*0.001;
//            double tempTolerance = massTolerance;
            
	    int start = Arrays.binarySearch(massArr, isoArr[i]-tempTolerance);
	    if(start<0)
		start = -start -1;

	    int j=0;
	    double small=100;
	    double massSmall=-1;
	    double highinten=0;
	    
            boolean isFound = false;
            
	    while(true)
	    {
		if(start>=massArr.length)
		    break;

		double temp = isoArr[i]-massArr[start];
		if(temp<0)
		    temp = -temp;

		if(temp<tempTolerance)
		{
                    totalPeakFound++;
                    toleranceSum += temp;
	//	    System.out.println("==" + resultArr[i] +"\t" + isoArr[i] + "\t" + massArr[start] + "\t" + intArr[start] +"\t" + tempTolerance);

		    resultArr[i] += intArr[start];
	//	    System.out.println("--" + resultArr[i] +"\t" + isoArr[i] + "\t" + massArr[start] + "\t" + intArr[start]);

                    isFound = true;
                    
		    double diff = (massArr[start] - isoArr[i]);
		    //if(diff<0)
			//diff = -diff;
		    if(Math.abs(diff)<Math.abs(small))
		    {
			small = massArr[start] - isoArr[i];
			massSmall = massArr[start];
			highinten = intArr[start];
		    }

		}

		if(massArr[start]>isoArr[i])
		    break;

		start++;
	    }
            
            if(isFound)
                foundIsoNum++;
	}

/*
	for(int i1=0;i1<isoArr.length;i1++)
	    System.out.println("==" + isoArr[i1] + "\t" + massTolerance);
	for(int i1=0;i1<resultArr.length;i1++)
	    System.out.println("==" + resultArr[i1]);
	for(int i1=0;i1<massArr.length;i1++)
	    System.out.println(massArr[i1] + "\t" + intArr[i1]);

System.exit(0);
*/
        return resultArr;
    }
  
    public static double[] intensitySum(double[] massArr, double[] intArr, double[] isoArr)
    {

        double[] resultArr = new double[3];
        
        double sumIntensity=0;
        int foundIsoNum=0; 
        int totalPeakFound=0;
        double toleranceSum=0;
        
	for(int i=0;i<isoArr.length;i++)
	{
            //double tempTolerance = isoArr[i]/1000*massTolerance;
            //double tempTolerance = isoArr[i]/1000*massTolerance*0.001;
            double tempTolerance = isoArr[i]/1000*massTolerance;
	    int start = Arrays.binarySearch(massArr, isoArr[i]-tempTolerance);
	    if(start<0)
		start = -start -1;

	    int j=0;
	    double small=100;
	    double massSmall=-1;
	    double highinten=0;
	    
            boolean isFound = false;
            
	    while(true)
	    {
		if(start>=massArr.length)
		    break;

		double temp = isoArr[i]-massArr[start];
		if(temp<0)
		    temp = -temp;

		if(temp<tempTolerance)
		{
		    sumIntensity+=intArr[start];
                    totalPeakFound++;
                    toleranceSum += temp;
                    
                    isFound = true;
                    
		    double diff = (massArr[start] - isoArr[i]);
		    //if(diff<0)
			//diff = -diff;
		    if(Math.abs(diff)<Math.abs(small))
		    {
			small = massArr[start] - isoArr[i];
			massSmall = massArr[start];
			highinten = intArr[start];
		    }

		}

		if(massArr[start]>isoArr[i])
		    break;

		start++;
	    }
            
            if(isFound)
                foundIsoNum++;
	}

        resultArr[0] = sumIntensity;
        resultArr[1] = foundIsoNum;
        resultArr[2] = (totalPeakFound>0)?(toleranceSum/totalPeakFound):(-1);
        
	return resultArr;
    }

    public static void getPeaks(ChroPeptide peptide, int startWindow, int endWindow, int threshold)
    {
        //Point point= null;
        double prev = peptide.getData(startWindow).getSampleIntensity();
        double current;
        
        double peakValue=peptide.getData(startWindow).getSampleIntensity();
        int peakIndex=startWindow;
        double prevPeakValue;
        int prevPeakIndex;
        int chroCenter = peptide.getChroCenter();
        
        for(int i=startWindow;i<=endWindow;i++)
        {
            ChroData data = peptide.getData(i);
            
            if(data.getSampleIntensity()<threshold)
                continue;
            
            current = data.getSampleIntensity();

            if( current>peakValue && (Math.abs(peakIndex-chroCenter)>Math.abs(i-chroCenter)) )
            {
                    peakValue = current;
                    peakIndex = i;                    
            }                            
        }
    }

    public static FragIonList getBestFragIons(long[][] bsTempArr, long[][] ysTempArr, long[][] brTempArr, long[][] yrTempArr, int startPeakIndex, int endPeakIndex, int maxShift)            
    {
        PostOptions options = PostOptions.getInstance();

        double[] bsRegArr = getRegressArr(bsTempArr, startPeakIndex, endPeakIndex, maxShift); 
        double[] ysRegArr = getRegressArr(ysTempArr, startPeakIndex, endPeakIndex, maxShift); 
        double[] brRegArr = getRegressArr(brTempArr, startPeakIndex, endPeakIndex, maxShift); 
        double[] yrRegArr = getRegressArr(yrTempArr, startPeakIndex, endPeakIndex, maxShift); 

        List<FragIon> iList = new Vector<FragIon>();

        int index=0;
        boolean isBion=true;
        
        for(int i=0;i<bsRegArr.length;i++)
        {
            iList.add( new FragIon(i+1, bsTempArr[i], brTempArr[i], bsRegArr[i] + brRegArr[i], true) ); //bion sample + ref
            iList.add( new FragIon(bsRegArr.length-i, ysTempArr[i], yrTempArr[i], ysRegArr[i] + yrRegArr[i], false) ); //yion sample + ref
        }


        Object[] fArr = iList.toArray();
        Arrays.sort(fArr);

        iList.clear();

        iList.add( (FragIon)fArr[fArr.length-1] );

        long[] samArr = new long[iList.get(0).getSArr().length];
        long[] refArr = new long[samArr.length];        
        
        
        int bestIndex=1;
        double bestReg=0;
        int tempIndex=0;
        FragIonList fList = new FragIonList();
        
        for(int i=fArr.length-1;i>=0;i--)
        {
            FragIon eachIon = ((FragIon)fArr[i]);
            fList.add(eachIon);
            
            long[] tempSArr = eachIon.getSArr();
            long[] tempRArr = eachIon.getRArr();
                        
            for(int j=0;j<tempSArr.length;j++)
            {
                samArr[j] += tempSArr[j];
                refArr[j] += tempRArr[j];
            }
            
            LinearRegression reg = new LinearRegression(samArr, refArr, startPeakIndex, (endPeakIndex!=0)?endPeakIndex:samArr.length, maxShift);
            
            if(bestReg<reg.getCorr())
            {
                bestReg = reg.getCorr();
                bestIndex=tempIndex;
            }
            
            tempIndex++;            
        }
        
        fList.setBestIndex(bestIndex);

        return fList;
          
    }

    private static double[] getRegressArr(long[][] arr, int startPeakIndex, int endPeakIndex, int maxShift)
    {
        double[] regArr = new double[arr.length];

        for(int i=0;i<arr.length;i++)
        {
            double sum=0;
            for(int j=0;j<arr.length;j++)
            {
                if(j==i)
                    continue;
                
                LinearRegression reg = new LinearRegression(arr[i], arr[j], startPeakIndex, endPeakIndex, maxShift);

                if(reg.getCorr()>0)
                    sum += reg.getCorr();
            }

            regArr[i] = sum;
        }

        return regArr;
    }


    public static double calculateSNRatio(long[] samArr, long[] refArr, int startIndex, int endIndex)
    {
        /*
         long[] snData = new long[samArr.length * 2]; // data for signal to noise calculation

        for(int i=0;i<samArr.length;i++)
        {
            snData[i] = samArr[i];
            snData[samArr.length + i] = refArr[i];
        }

        Arrays.sort(snData);
         **/
        
        
        startIndex = (startIndex>=0)?startIndex:0;
        endIndex = (endIndex<samArr.length)?endIndex:samArr.length-1;
        
        long noise=0;
        long signal=0;
        
        for(int i=startIndex;i<=endIndex;i++)
        {
            signal += samArr[i];
            signal += refArr[i];
        }
        
        int peakWidth = (endIndex - startIndex + 1);
        signal = signal / peakWidth;
        
        //Arrays.sort(samArr);
        //Arrays.sort(refArr);
        
        //int sampleSize = (int)(snData.length*0.05);
        

        int noiseStart = startIndex - peakWidth;
        noiseStart = (noiseStart>=0)?noiseStart:0;
        
        int noiseEnd = endIndex + peakWidth;
        noiseEnd = (noiseEnd>=samArr.length)?(samArr.length-1):noiseEnd;
        
        long[] tempSamData = new long[noiseEnd-noiseStart+1];
        long[] tempRefData = new long[tempSamData.length];
        
        int index=0;
        for(int i=noiseStart;i<=noiseEnd;i++)
        {
            tempSamData[index] = samArr[i];
            tempRefData[index] = refArr[i];                   
            index++;
        }
        
        Arrays.sort(tempSamData);
        Arrays.sort(tempRefData);
        
        int sampleSize = (int)(tempSamData.length*0.3);
        
        for(int i=0;i<sampleSize;i++)
        {
            //noise += snData[i];
            //signal += snData[snData.length-i-1];
            
            noise += tempSamData[i];
            noise += tempRefData[i];
            
        //    signal += samArr[samArr.length-i-1];
        //    signal += refArr[refArr.length-i-1];
            
        }

        
        noise = noise / (sampleSize*2);
        //signal = signal / (sampleSize*2);

        //System.out.println("signal==>>" + signal + "\t" + noise);
        
        double snRatio;
        if(noise==0)
            snRatio = Math.log10(signal);
        else
            snRatio = Math.log10(signal/noise);
        
        return snRatio;
                                            
    }
    
    private static class SpectrumModel
    {
        private boolean highRes;
        
        private IndexedFile iFile;
        private double samStartMass;
        private double samEndMass;
        private double refStartMass;
        private double refEndMass;

        private double[] samIsoArr;
        private double[] refIsoArr;

        private double[][] bioSample;
        private double[][] yioSample;
        private double[][] bioRef;
        private double[][] yioRef;
                
        private int[] keys;
        private int diff;

        private TIntLongHashMap index;
        private RandomAccessFile file;

        private int steepArea;
	private String result;
        private List msmsSpecificMassList;
        
        private MzxmlSpectrumReader mzxmlreader;

	public int getDiff()
	{
	    return this.diff;
	}

	public void setDiff(int diff)
	{
	    this.diff = diff;
	}

        public Object getGenericIndexFile(Configuration conf) {
            if(conf.getSpectrumFormat() == conf.MS_FILE_FORMAT)
                return file;
            else if(conf.getSpectrumFormat() == conf.MZXML_FILE_FORMAT)
                return mzxmlreader;
            else 
                return null;
            
        }
        
        public IndexedFile getIFile() {
            return iFile;
        }

        public void setIFile(IndexedFile iFile) {
            this.iFile = iFile;
        }

        public int[] getKeys() {
            return keys;
        }

        public void setKeys(int[] keys) {
            this.keys = keys;
        }

        public double getSamStartMass() {
            return samStartMass;
        }

        public void setSamStartMass(double samStartMass) {
            this.samStartMass = samStartMass;
        }

        public double getSamEndMass() {
            return samEndMass;
        }

        public void setSamEndMass(double samEndMass) {
            this.samEndMass = samEndMass;
        }

        public double getRefStartMass() {
            return refStartMass;
        }

        public void setRefStartMass(double refStartMass) {
            this.refStartMass = refStartMass;
        }

        public double getRefEndMass() {
            return refEndMass;
        }

        public void setRefEndMass(double refEndMass) {
            this.refEndMass = refEndMass;
        }

        public boolean isHighRes() {
            return highRes;
        }

        public void setHighRes(boolean highRes) {
            this.highRes = highRes;
        }

        public TIntLongHashMap getIndex() {
            return index;
        }

        public void setIndex(TIntLongHashMap index) {
            this.index = index;
        }

        public RandomAccessFile getFile() {
            return file;
        }

        public void setFile(RandomAccessFile file) {
            this.file = file;
        }

        public int getSteepArea() {
            return steepArea;
        }

        public void setSteepArea(int steepArea) {
            this.steepArea = steepArea;
        }

        public double[] getSamIsoArr() {
            return samIsoArr;
        }

        public void setSamIsoArr(double[] samIsoArr) {
            this.samIsoArr = samIsoArr;
        }

        public double[] getRefIsoArr() {
            return refIsoArr;
        }

        public void setRefIsoArr(double[] refIsoArr) {
            this.refIsoArr = refIsoArr;
        }

	public String getResult() {
	    return this.result;
	}

	public void setResult(String result) {
	    this.result = result;
	}

        public double[][] getBioSample() {
            return bioSample;
        }

        public void setBioSample(double[][] bioSample) {
            this.bioSample = bioSample;
        }

        public double[][] getYioSample() {
            return yioSample;
        }

        public void setYioSample(double[][] yioSample) {
            this.yioSample = yioSample;
        }

        public double[][] getBioRef() {
            return bioRef;
        }

        public void setBioRef(double[][] bioRef) {
            this.bioRef = bioRef;
        }

        public double[][] getYioRef() {
            return yioRef;
        }

        public void setYioRef(double[][] yioRef) {
            this.yioRef = yioRef;
        }

        public List getMsmsSpecificMassList() {
            return msmsSpecificMassList;
        }

        public void setMsmsSpecificMassList(List msmsSpecificMassList) {
            this.msmsSpecificMassList = msmsSpecificMassList;
        }

        public MzxmlSpectrumReader getMzxmlreader() {
            return mzxmlreader;
        }

        public void setMzxmlreader(MzxmlSpectrumReader mzxmlreader) {
            this.mzxmlreader = mzxmlreader;
        }

    }

    //calculate weighted standard deviation for the labeled data
    public static double getWeightedStdev(double corr)
    {
        double rsqrtLog = Math.log( corr*corr );
        double stdevLog = -0.84 * rsqrtLog + 0.43;
        //double invStdev = Math.exp(stdevLog);
        
        return Math.exp(stdevLog);

    }
    
    
	public static void main(String[] args) throws Exception
	{
		//CalcUtil.calculateMass(new RandomAccessFile(args[0], "r"), Long.parseLong(args[1]), Long.parseLong(args[2]),
		//	Double.parseDouble(args[3]), Double.parseDouble(args[4]));
	}


    public static double[][] readSpectrumOnly(
            int i,
            IndexedFile iFile
            ) throws IOException            
    {
	RandomAccessFile file = iFile.getFile();
        TIntLongHashMap index = iFile.getMsIndex();

        int[] keys = iFile.getKeys();
        
        int byteSize;
        byte[] bytes;
        char ch;
        int pos;
        
        if(i<0)
	    return null;
        
        long sampleIndex = index.get(keys[i]);
        
        StringBuilder mass, intensity;
        
        if(sampleIndex<0)
	    return null;


        file.seek(sampleIndex);

        int increIndex=1;

        while(true)
        {
            if( (i+increIndex)>=keys.length )
            {
                byteSize = (int)(file.length() - sampleIndex); 

                break;
            }

            if(index.get(keys[i+increIndex])>0)
            { 
                byteSize = (int)(index.get(keys[i+increIndex]) - sampleIndex);    
                break;
            }

            increIndex++;
        }

        //byteSize = (int)(index.get(keys[i+1]) - sampleIndex);
        bytes = new byte[byteSize];

        file.readFully(bytes);
        pos=0;

        ch = (char)bytes[pos];

        //        pos++;
        //Remove Z, S, I, D lines
        //System.out.println("sample");
        while( (ch=(char)bytes[pos]) == 'Z' || ch == 'S' || ch == 'I' || ch == 'D')
        {
            while( ch != CARRIAGE_RETURN )
            {
                pos++;
                ch = (char)bytes[pos];
            }       

            pos++;
        }

     
	    int arrSize=0;
	    for(int j=pos;j<byteSize;j++)
	    {
		if( CARRIAGE_RETURN == (char)bytes[j] )
		    arrSize++;

	    }
	    double[] massArr = new double[arrSize];
	    double[] intArr = new double[arrSize];

	    //pos++;
	    mass = new StringBuilder(10);
	    intensity = new StringBuilder(10);
	    intensity.append('0');

	    boolean isMass=true;
	    boolean isInt=true;

	    int massIndex=0;
	    //double tempMass;

	    for(int j=pos;j<byteSize;j++)
	    {
		ch = (char)bytes[j];
                //System.out.print(ch);
                
		switch(ch)
		{
		    case WINDOW_CR:
			break;
			
		    case SPACE:
			isMass=false;
			isInt=true;
			break;

		    case CARRIAGE_RETURN:
			isMass=true; 
			isInt=false;

                        //try {
			intArr[massIndex] = Long.parseLong(intensity.toString());
			massArr[massIndex++] = Double.parseDouble(mass.toString());
			mass.delete(0, mass.length());  //This is faster than creating new StringBuilder object
			intensity.delete(0, intensity.length()).append('0');
                        //} catch(Exception e) { System.out.println("-->>" + mass.toString() + " " + intensity.toString()); System.exit(0); };

			break;

		    case DOT:
			isInt=false;

		    default:
			if(isMass)
			    mass.append(ch);
			else if(isInt) //remove decimal value of intensity
			    intensity.append(ch);

                    break;
            }

        } 

	double[][] massIntArr = new double[2][];
	massIntArr[0] = massArr;
	massIntArr[1] = intArr;


//	for(int i1=0;i1<massArr.length;i1++)
//	    System.out.println(massArr[i1] + "\t" + intArr[i1]);

//	System.exit(0);
	
	return massIntArr;
    }

    public static double[] getMassArr() {
	return massArr;
    }

    public static double[] getIntArr() {
	return intArr;
    }

	public static long[] smooth(long[] input) {
		//long[] input = {3, 4, 5, 2, 3, 4, 5, 6, 7, 4, };
		int size=3;
		long[] out = new long[input.length-2];

		for(int i=0;i<input.length-size+1;i++) {
			long sum = input[i+0];
			sum += input[i+1];
			sum += input[i+2];

			long average = sum / size;

			out[i] = average;
		}

		return out;

	}

}
