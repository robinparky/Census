package edu.scripps.pms.census.chroalign;

import java.io.*;
import java.util.*;
import java.text.DecimalFormat;
import edu.scripps.pms.util.io.*;
import edu.scripps.pms.util.spectrum.*;
import edu.scripps.pms.census.model.*;
import edu.scripps.pms.census.chroalign.Elements;
import edu.scripps.pms.census.util.BasePeakFinder;
import edu.scripps.pms.census.ChroProgressDialog;
import org.jdom.*;
import org.jdom.output.*;
import edu.scripps.pms.census.conf.Configuration;

import javax.swing.*;

public class chroalign {
	//int             maxTimeElements; //5000
        private double[][][]    dataarray; 
        private int             bandConstraint;
        //Elements[][] 	matrix;
	private Elements[][] diaArray;
        private int[][][]       pathArray;
        private double[][]       retArray;
        
        private boolean         useBasePeak = false;
        private int fileNumber=0;        

        private double[][][] binSpectra = null;        
        private double[][][] info = null;        

//        private JProgressBar progress;
        private ChroProgressDialog progress;
        private int alignNumber = 0; //increase this number as alignment proceeds
        private String[]        targetMS1Files = null;
        private String          referenceMS1File;
        private double percentDone;

        private Object[] filenames;
        private int masterfile;
        private int[][] mappingArr;
        int[][] scanArr;
       
	private String workFolder;
        private Hashtable[] htArr;
        private Hashtable[] indexArr;

        private ChroProgressDialog chroProgress;
        public void setConstraint (int constraint) {
            this.bandConstraint = constraint;
        }
        
        public int getConstraint () {
            return this.bandConstraint;
        }
        
        /*
        public void setNumElements (int numElements) {
            this.maxTimeElements= numElements;
        }
        
        public int getNumElements () {
            return this.maxTimeElements;
        }
        */
        
        public void setAlignType (boolean uesBasePeak) {
            this.useBasePeak= useBasePeak;
        }
        
        public boolean getAlignType () {
            return this.useBasePeak;
        }
        
        public static void main(String args[]) throws Exception {
                chroalign           appObject = new chroalign();
                String[]            datasetnames = new String[3];
                int                 masterfile = 0;
		System.out.println("Starting Chroalign...");
                //ChroProgressDialog.addMessageWithLine(progress, "Starting Chroalign...");
                
                
                ArrayList<Element>  rootElements;
                //appObject.setConstraint(500);
                
                /*
		if(args.length<2) {
                        appObject.usage();
                        System.exit(0);
                }
                datasetnames[0] = "reference";
                datasetnames[1] = "target1";
                datasetnames[2] = "target2";
                
                //int bandConstraint = 2001;//must be odd number
		rootElements = appObject.alignChro(args, datasetnames, masterfile, appObject.getAlignType(), appObject.getNumElements(), appObject.getConstraint());
                */
                
                String[] files = new String[3];
                files[0] = "/data/2/jvenable/Orbitrap/16ProMix/IsotopeFreeQuant/testFiles/test1.ms1";
                files[1] = "/data/2/jvenable/Orbitrap/16ProMix/IsotopeFreeQuant/testFiles/test2.ms1";
                files[2] = "/data/2/jvenable/Orbitrap/16ProMix/IsotopeFreeQuant/testFiles/test3.ms1";
                
                String[] names = new String[3];
                names[0] = "reference";
                names[1] = "sample";
                names[2] = "sample1";
                
                
                
                //rootElements = appObject.alignChro(null, files, names, masterfile, appObject.getAlignType(), 500);
        }

        public int[][][] noAlignChro(                
                ChroProgressDialog progress,
                Object[] args, 
                Object[] datasetnamesObj, 
                String workFolder                
                ) throws IOException 
        {        
            this.workFolder = workFolder; 
            this.progress = progress;
            this.chroProgress = chroProgress;
            
            this.filenames = args;
            
            targetMS1Files = new String[args.length];
            String[]        tempnames = new String[args.length];
            Element         chroRoot;
            Element         pathRoot;
            Element         alignedRoot;
            ArrayList<Element>  results = new ArrayList<Element>();
            SpectrumReader  ms1;
            int             cnt;
            int             refNum;
            int[]           tarNum = new int[args.length];

            this.fileNumber = args.length;

            referenceMS1File = args[0].toString();
            
            //this.datasetnames = new String[datasetnames.length];
            String[] datasetnames = new String[datasetnamesObj.length];
                
            //AlignNode.rotateNew(500, 1000, 1000);
            try {
                    ArrayList<SpectrumReader>  data = new ArrayList(); 
                    //read reference file first
                    //refNum = SpectrumReader.getNumSpectra(referenceMS1File, "ms1");
                    SpectrumReader sReader;
                    
                    int size=0;

                    for(int i=0;i<args.length;i++) {
                        long start = System.currentTimeMillis();
                        targetMS1Files[i] = args[i].toString();
                        datasetnames[i] = datasetnamesObj[i].toString();
                        System.out.println("Reading Target MS1 File # " + (i+1) + " ...");
                        ChroProgressDialog.addMessageWithLine(progress, "Reading Target MS1 File # " + (i+1) + " ...");
                        //chroProgress.addMessageWithLine("Reading Target MS1 File # " + (i+1) + " ...");
                        //chroProgress.addMessageWithLine(targetMS1Files[i]);
                        System.out.println(targetMS1Files[i]);
                        ChroProgressDialog.addMessageWithLine(progress, targetMS1Files[i]);
                        sReader = new SpectrumReader(targetMS1Files[i], "ms1");
                        
                        tarNum[i] = sReader.getNumSpectra();

                        //System.out.println("===>"+ (System.currentTimeMillis()-start));
                        
                        System.out.println("size===" + size + " " + tarNum[i] + " " + args[i].toString());
                        
                        if(tarNum[i]>size)
                            size = tarNum[i];

                        //System.out.println(tarNum[i]);
                        ms1 = new SpectrumReader(targetMS1Files[i], "ms1");

                        data.add(ms1);
                        System.out.println("===>"+ (System.currentTimeMillis()-start));
                    }
                        
                    dataarray = new double[this.fileNumber][2][size];//stores bp chromatograms for output
                    pathArray = new int[this.fileNumber][2][2*size];
                    retArray = new double[this.fileNumber][size];

                    this.populateNoAlignDataArray(data, size);

                    /*
                    for(int i=0;i<retArray.length;i++)
                    {
                        for(int j=0;j<retArray[i].length;j++)
                            System.out.print(retArray[i][j] + "\t");
                    
                        System.out.println();
                    }
                    */
            

                    
                    double maxRet =0;
                    
                    for(int i=0;i<retArray.length;i++)
                    {
                        double tmp = retArray[i][retArray[i].length-1];
                        
                        
                        //if(tmp>maxRet)
                        //    maxRet = tmp;
                        
                        System.out.println("ret time== " + maxRet);
                        
                        int tmp1 = retArray[i].length-1;
                        
                        
                        while(true)
                        {
                            double tmpRet = retArray[i][tmp1--];
                            
                            if(tmp1<0)
                                break;
                            
                            if(tmpRet>0)
                            {
                                //System.out.println("--ret" + retArray[i][tmp1+1] );
                                
                                if(tmpRet>maxRet)
                                    maxRet = tmpRet;
                                
                                //System.out.println("--ret" + retArray[i][tmp1+1] );
                                break;
                            }
                            
                        }
                    }
                    
                    
                    //int[][] binArr = new int[pathArray.length][(int)(maxRet*100)];
                    int[][] binArr = new int[this.fileNumber][(int)((maxRet+1)*100)];                    
                    pathArray = new int[this.fileNumber][2][binArr[0].length];
                    
                    
                    for(int i=0;i<retArray.length;i++)
                    {
                        for(int j=0;j<retArray[i].length;j++)
                        {
                            if(retArray[i][j]>0)
			    {
                                binArr[i][(int)(retArray[i][j]*100)] = j; //retArray[i][j]; //scan index;                       
			    }
                        }
                    }   
                    
                    for(int i=0;i<binArr.length;i++)
                    {
			int prev=-1;

                        for(int j=0;j<binArr[i].length;j++)
			{
			    if(binArr[i][j] == 0 && j>0)
			    {
				binArr[i][j] = binArr[i][j-1]; 
			    }

//			    if(j<50)
  //                          System.out.print(binArr[i][j] + "\t");
			}
                    
    //                    System.out.println("---------------");
                    }
                    
//		  System.exit(0);
                            
                    int tmpInd=0;
                   
		   int k=0; //last Index
                    for(int i=0;i<binArr[0].length;i++)
                    {
                        
                        
                        for(int j=0;j<binArr.length;j++)
                        {
//                            System.out.print(binArr[j][i] + "\t");
                            if(0<binArr[j][i])
                            {
                                for(k=0;k<binArr.length;k++)
                                {                                    
                                    //System.out.print(binArr[k][i] + "\t");
                                    
                                    if(binArr[k][i]<=0 && tmpInd>0 && pathArray[k][1][tmpInd-1]>0) {
                                        pathArray[k][0][tmpInd] = pathArray[k][1][tmpInd-1];
                                        pathArray[k][1][tmpInd] = pathArray[k][1][tmpInd-1];   
                                    }
                                    else {
                                        pathArray[k][0][tmpInd] = binArr[k][i];
                                        pathArray[k][1][tmpInd] = binArr[k][i];
                                    }
                              //      System.out.print(binArr[k][i] + "\t");
                                }
                                
                                tmpInd++;       
                                
                                break;
                            }
                        }
                    }                    

		    System.out.println(pathArray.length +  " " + k + " " + tmpInd);
		    System.out.println(pathArray[0][0].length +  " " + k + " " + tmpInd);
                  
		    //fill up all zero values with last filled value 

		    for(int i=0;i<pathArray.length;i++)
		    {
			for(int j=tmpInd;j<pathArray[0][0].length;j++)
			{
			    pathArray[i][0][j] = pathArray[i][0][tmpInd-1];
			    pathArray[i][1][j] = pathArray[i][1][tmpInd-1];
			}
		    }


                    Configuration conf = Configuration.getInstance();
                    conf.setRetArr(retArray);
                    
                    System.out.println("Outputting results ...");
                    ChroProgressDialog.addMessageWithLine(progress, "Outputting results ...");
                    
                    //paths (path_out.xml)
                    pathRoot = createXmlPlotHeader();
                    pathRoot = createPathdata(pathRoot, dataarray, datasetnames, data.size());
                    writeOutputFile(pathRoot, "path_out.xml");
                    //results.add(chroRoot);
                    //results.add(alignedRoot);
                    //results.add(pathRoot);
                    
            } catch(IOException failure) {
                    System.out.println("Error while reading MS1 files");
                    ChroProgressDialog.addMessageWithLine(progress, "Error while reading MS1 files");
                    System.out.println(failure.toString());
                    ChroProgressDialog.addMessageWithLine(progress, failure.toString());
            }

/*
            System.out.println("retrun...");
                    //for(int i=0;i<pathArray[0][0].length;i++)
                    for(int i=12000;i<pathArray[0][0].length;i++)
                    {
                        for(int j=0;j<pathArray.length;j++)
                            System.out.print(pathArray[j][0][i] + "-" + pathArray[j][1][i] + "\t");
                    
                        System.out.println();
                    }
          */ 
            return this.pathArray;
        
        }
        
	//returns ArrayList of three XML root Elements 1) chromatograms before alignment, 2) chromatograms after alignment, 3)paths  
        public int[][][] alignChro(                
                ChroProgressDialog progress, 
                Object[] args, 
                Object[] datasetnames, 
                int masterfile, 
                boolean useBasePeak, 
                int bandConstraint, 
                String workFolder                
                ) throws IOException, Exception {
            
                        //System.out.println(args.length + " " + datasetnames.length + " " + masterfile + " " + useBasePeak + " " + bandConstraint);
            
		this.workFolder = workFolder; 
                this.progress = progress;
                        
                                
                this.filenames = args;
                this.masterfile = masterfile;
                
		targetMS1Files = new String[args.length];
                String[]        tempnames = new String[args.length];
                Element         chroRoot;
                Element         pathRoot;
                Element         alignedRoot;
                ArrayList<Element>  results = new ArrayList<Element>();
                SpectrumReader  ms1;
                int             cnt;
                int             refNum;
                int[]           tarNum = new int[args.length];
                
                this.bandConstraint = bandConstraint;
                //this.maxTimeElements = maxTimeElements;
                this.fileNumber = args.length;
               
		
                //matrix = new Elements[maxTimeElements][maxTimeElements];//finding path
                //dataarray = new double[args.length][2][maxTimeElements];//stores bp chromatograms for output
                //pathArray = new int[args.length][2][2*maxTimeElements];
                referenceMS1File = args[masterfile].toString();
                tempnames[0] = datasetnames[masterfile].toString();
                cnt = 0;
                for(int i=0;i<args.length;i++) {
                    if(i != masterfile) {
                        targetMS1Files[cnt] = args[i].toString();
                        cnt++;
                        tempnames[cnt] = datasetnames[i].toString();
                    }
                }
                datasetnames = tempnames;
                
                //AlignNode.rotateNew(500, 1000, 1000);
		try {
			ArrayList<SpectrumReader>  data = new ArrayList(); 
                        //read reference file first
                        System.out.println("Reading Reference MS1 ...");
                        ChroProgressDialog.addMessageWithLine(progress, "Reading Reference MS1 ...");
                        //refNum = SpectrumReader.getNumSpectra(referenceMS1File, "ms1");
                        SpectrumReader sReader = new SpectrumReader(referenceMS1File, "ms1");
                        refNum = sReader.getNumSpectra();
                        

                        //double[][] binRefSpectra = new double[refNum][2];
                        //double[][] refinfo = new double[refNum][4];
                        ms1 = new SpectrumReader(referenceMS1File, "ms1");   
                        data.add(ms1);

                        //read target files next
                        
                        int size=0;
                        
                        for(int i=0;i<args.length-1;i++) {
                            long start = System.currentTimeMillis();
                            System.out.println("Reading Target MS1 File # " + (i+1) + " ...");
                            ChroProgressDialog.addMessageWithLine(progress, "Reading Target MS1 File # " + (i+1) + " ...");
                            System.out.println(targetMS1Files[i]);
                            ChroProgressDialog.addMessageWithLine(progress, targetMS1Files[i]);
                            sReader = new SpectrumReader(targetMS1Files[i], "ms1");
                            tarNum[i] = sReader.getNumSpectra();
                            
                            if(tarNum[i]>size)
                                size = tarNum[i];
                            
                            
                            ms1 = new SpectrumReader(targetMS1Files[i], "ms1");

                            data.add(ms1);
                           // System.out.println("===>"+ (System.currentTimeMillis()-start));
                        }
                        
                        
                        //System.out.println(refNum + " " + tarNum);
                        //matrix = new Elements[maxTimeElements][maxTimeElements];//finding path
                        size = refNum>size?refNum:size;
                        size += 2; // add margin


		    
                        //matrix = new Elements[size][size];//finding path
                        dataarray = new double[this.fileNumber][2][size];//stores bp chromatograms for output
                        pathArray = new int[this.fileNumber][2][2*size];
                        
                        mappingArr = new int[this.fileNumber][size];
                
                        
                        this.populateDataArray(data, size);
                        
                        //process each pair of chromatograms sequentially
			//initialize diagonal array
                        
			int height = bandConstraint*2;
			diaArray = new Elements[size][height];                        
			for(int i=0;i<size;i++) 
			{
			    for(int j=0;j<height;j++)
				diaArray[i][j] = new Elements();
			}
                            
                        int progressValue = (int)(10.0/data.size()) + 5;
                        ChroProgressDialog.updateProgress(progress,  progressValue + 1 );
                        
                        for (int i=1;i<data.size();i++) {
                            System.out.println("Working on matrix #" + i);
                            ChroProgressDialog.addMessageWithLine(progress, "Working on matrix #" + i);
                            
                            if(useBasePeak) {                                
                                ChroProgressDialog.addMessageWithLine(progress, "Alignment Mode = BasePeak");
                                System.out.println("Alignment Mode = BasePeak");
                            } else {
                                ChroProgressDialog.addMessageWithLine(progress, "Alignment Mode = Pearson Correlation @ Spectral Level");                                        
                                System.out.println("Alignment Mode = Pearson Correlation @ Spectral Level");
                            }
                            
                            alignNumber = i;
                            //System.out.println("==============>>" + this.fileNumber + " " + data.size());
                            
                            genCostMatrix(data.get(0), data.get(i), i, refNum, tarNum[i-1], useBasePeak);
                            
                            //progressValue += (int)10/data.size();
                            
                            //System.out.println("Generating cumulative distance matrix ...");
                            //genCumCostMatrix(i, refNum, tarNum[i-1], useBasePeak);
                            
                            findPath(i, refNum, tarNum[i-1]);
                            
                            //this.initializeMatrix(size);
                            System.out.println("Finished with this matrix ...");
                            ChroProgressDialog.addMessageWithLine(progress, "Finished with this matrix ...");
                            
                            
                            progressValue += (int)10.0/data.size();
                            //progressValue = (int)(10.0*(i+1)/data.size() + 1);
                            System.out.println("" + progressValue);
                            ChroProgressDialog.updateProgress(progress,  progressValue );
                        }
                        
			System.out.println("Outputting results ...");
                        ChroProgressDialog.addMessageWithLine(progress, "Outputting results ...");
                        //unalligned chromatograms (chro_out.xml)
                        chroRoot = createXmlChroHeader();
                        chroRoot = createChrodata(chroRoot, dataarray, datasetnames, data.size(), false);
			writeOutputFile(chroRoot, "chro_out.xml");
                        //alligned chromatograms (aligned_out.xml)
                        alignedRoot = createXmlChroHeader();
                        alignedRoot = createChrodata(alignedRoot, dataarray, datasetnames, data.size(), true);
			writeOutputFile(alignedRoot, "aligned_out.xml");
                        //paths (path_out.xml)
                        pathRoot = createXmlPlotHeader();
                        pathRoot = createPathdata(pathRoot, dataarray, datasetnames, data.size());
			writeOutputFile(pathRoot, "path_out.xml");
                        results.add(chroRoot);
                        results.add(alignedRoot);
                        results.add(pathRoot);
                        
                        //rearrangeData(data.size(), size, refNum);
                        System.out.println(data.size() + " " + size + " " + refNum);
                        System.out.println("Ref    Tar1     Tar2");
                        for(int i=0;i<size;i++){
                            ;//System.out.println(mappingArr[0][i] + " " + mappingArr[1][i] + " " + mappingArr[2][i]);
                        }
		} catch(IOException failure) {
                        System.out.println("Error while reading MS1 files");
                        ChroProgressDialog.addMessageWithLine(progress, "Error while reading MS1 files");
                        ChroProgressDialog.addMessageWithLine(progress, failure.toString());
                        System.out.println(failure.toString());
                        
                        throw new IOException();
		} catch(Exception e) {
                    if(null != progress)
                        ChroProgressDialog.addMessageWithLine(progress, "Error : " + e);
                    
                    System.out.println("Error : " + e);
		    e.printStackTrace();

                    
                    throw new Exception();
                }
                
               
                return this.pathArray;
        }
        
        public void rearrangeData(int listSize, int size, int refNum)
        {
            
            //add reference file to mapping 
            for (int scanIndex=0;scanIndex<refNum;scanIndex++) {
                mappingArr[0][scanIndex] = scanIndex;
            }
            
            for (int fileIndex=0;fileIndex<listSize-1;fileIndex++) {
                //for (int mapIndex=0;mapIndex<size;mapIndex++) {
                for(int scanIndex=0;scanIndex<size;scanIndex++) {
                    
                    int tmpScan = pathArray[fileIndex][0][scanIndex];
                    
                    //if(scanIndex<100)
                        //System.out.println("tmpscan-- " + tmpScan + " " + pathArray[fileIndex][1][scanIndex] + " " +  fileIndex + " " + scanArr[fileIndex+1][ pathArray[fileIndex][1][scanIndex] ]);
                    
                    //mappingArr[fileIndex+1][tmpScan] = scanArr[fileIndex+1][ pathArray[fileIndex][1][scanIndex] ];
                    mappingArr[fileIndex+1][tmpScan] = pathArray[fileIndex][1][scanIndex];   
                }
                    
            }
            
            
        }
        
        public void populateNoAlignDataArray(ArrayList<SpectrumReader> readerList, int size) throws IOException
        {
            System.out.println("Generating Chromatogram Arrays ...");
            ChroProgressDialog.addMessageWithLine(progress, "Generating Chromatogram Arrays ...");
            //Iterator<PeakList> tarList = readerList.getSpectra();
            
            int listSize = readerList.size();
            info = new double[listSize][size][4];
            scanArr = new int[listSize][size];
            
            //double[][] binRefSpectra = new double[refNum][2];
            //double[][] refinfo = new double[refNum][4];

            int readerIndex=0;
            
            htArr = new Hashtable[readerList.size()];
            
            for(int i=0;i<htArr.length;i++)
            {
                htArr[i] = new Hashtable<Integer, Double>();
            }
            
            for(Iterator<SpectrumReader> itr=readerList.iterator(); itr.hasNext(); )
            {
                SpectrumReader reader = itr.next();
                
                int cnt=0;    
                for(Iterator<PeakList> peakItr=reader.getSpectra(); peakItr.hasNext(); )
                {
                    PeakList pList = peakItr.next();
                    scanArr[readerIndex][cnt] = pList.getLoscan();
                    
                    List<String> rtList = pList.getIlines();
                    
                    double rt=-1;
                    
                    for(Iterator<String> rtItr=rtList.iterator(); rtItr.hasNext(); )
                    {
                        String eachI = rtItr.next();
                        
                        if(eachI.startsWith("I\tRetTime"))
                        {
                            String[] arr = eachI.split("\t");
                            String retTime = arr[2];
                        
                            rt  = Double.parseDouble(retTime);
                            this.retArray[readerIndex][cnt] = rt;
                            
                            break;
                        }
                    }

                    //htArr[readerIndex].put(pList.getHiscan(), rt);
                    htArr[readerIndex].put(cnt, rt);
                    
                    cnt++;                    
                }
             
                readerIndex++;
            }

            
        }
        
        //ArrayList<SpectrumReader>  data = new ArrayList(); 
        public void populateDataArray(ArrayList<SpectrumReader> readerList, int size) throws IOException
        {
            
            System.out.println("Generating Chromatogram Arrays ...");
            ChroProgressDialog.addMessageWithLine(progress, "Generating Chromatogram Arrays ...");
            //Iterator<PeakList> tarList = readerList.getSpectra();
            
            int listSize = readerList.size();
            binSpectra = new double[listSize][size][2];
            info = new double[listSize][size][4];
            scanArr = new int[listSize][size];
            
            //double[][] binRefSpectra = new double[refNum][2];
            //double[][] refinfo = new double[refNum][4];

            int readerIndex=0;
            
            int progressValue=1;
                        
            for(Iterator<SpectrumReader> itr=readerList.iterator(); itr.hasNext(); )
            {
                SpectrumReader reader = itr.next();
                
                int cnt=0;    
                for(Iterator<PeakList> peakItr=reader.getSpectra(); peakItr.hasNext(); )
                {
                    PeakList pList = peakItr.next();
                    scanArr[readerIndex][cnt] = pList.getLoscan();
                    
                    List<String> rtList = pList.getIlines();
                    String[] content = rtList.get(0).split("\t");
                    double rt = new Double(content[2]).doubleValue();
                    Iterator peaks = pList.getPeaks();
                    
                    //get info from spectra
                    binSpectra[readerIndex][cnt] = binSpectrum(peaks, 1, pList.getMaxM2z(), 2000);
                    info[readerIndex][cnt] = getSpectrumInfo(binSpectra[readerIndex][cnt]);
                    dataarray[readerIndex][0][cnt] = rt;
                    dataarray[readerIndex][1][cnt] = info[readerIndex][cnt][0];//base peak

                    cnt++;                    
                }
             
                readerIndex++;
                
                progressValue += (int)(5.0/readerList.size());
                ChroProgressDialog.updateProgress(progress,  progressValue + 1 );
                
                ChroProgressDialog.addMessage(progress, ".");
                        
            }
            
        }
        
        
        //public void genCostMatrix (SpectrumReader refms1, SpectrumReader tarms1, int filenum, int refNum, int tarNum, double[][]binRefSpectra, double[][] refinfo, boolean useBasePeak, int size) {
        public void genCostMatrix (SpectrumReader refms1, SpectrumReader tarms1, int filenum, int refNum, int tarNum, boolean useBasePeak) {

            BasePeakFinder  bpf;
            double          temp;
            

            double  dmin = 0.0;

            int     index = 0;
            double  tt;
            double	dd = 0;
            double  dd1 = 0;
            double	dd2 = 0;
            double	dd3 = 0;
            String tstr;
            String  TString = "0.###";
            DecimalFormat    formatter = new DecimalFormat(TString);
            double[][]	tempLocalCostArray = new double[2][tarNum+2];

	    System.out.println("Calculating Local Distances ...");
            ChroProgressDialog.addMessageWithLine(progress, "Calculating Local Distances ...");

            //initialize temporary array and first two columns of matrix array with local score
            Elements[][] accCostArray = new Elements[3][tarNum+2];
            for(int i=0;i<3;i++)
                for(int j=0;j<tarNum+2;j++)
                    accCostArray[i][j] = new Elements();
                                
	    for (int i=2;i<4;i++) {
		for (int j=2;j<tarNum+2;j++) {
		    if(!checkConstraint(refNum, tarNum, 2, j)) 
		    {
			if (useBasePeak) 
			    tempLocalCostArray[i-2][j] = euclidianDis(dataarray[0][1][i-2], dataarray[filenum][1][j-2]);
			else
			    // Oops it may bomb!!
			    tempLocalCostArray[i-2][j] = spectrumDis(binSpectra[0][i-2], binSpectra[filenum][j-2], info[0][i-2], info[filenum][j-2], false); 
		    }                    
                    accCostArray[i-1][j].score = tempLocalCostArray[i-2][j];                    
		}
	    }

                        
	    for (int i=4;i<refNum;i++) {
		percentDone = (double)i/(double)refNum/(this.fileNumber-1) + (double)(this.alignNumber-1)/(this.fileNumber-1);                

		//System.out.print(i + "\t" + refNum + "\t" + percentDone + "\n");
                //this.progress.setValue((int)(percentDone*100));      
                //System.out.print(percentDone + "\r");
                
		for (int j=2;j<tarNum+1;j++) {
                    
		    dd = tempLocalCostArray[1][j+1];
                    
                    dd1 = accCostArray[1][j].score+2*dd;
		    dd2 = accCostArray[0][j].score + 2*tempLocalCostArray[0][j+1] + dd;
		    dd3 = accCostArray[1][j-1].score + 2*tempLocalCostArray[1][j] + dd;
            
                    tempLocalCostArray[0][j] = tempLocalCostArray[1][j];
                    
		    if (useBasePeak)
		    {
                        tempLocalCostArray[1][j] = euclidianDis(dataarray[0][1][i-2], dataarray[filenum][1][j-2]);
                        
			if (dd2 < dd1 && dd2 < dd3) {

			    index = 2;
			    dmin = dd2;
			} else if (dd3 < dd1 && dd3 < dd2) {

			    index = 3;
			    dmin = dd3;
			} else {

			    //choose diagonal
			    index = 1;
			    dmin = dd1;
			}
		    }                                
		    else
		    {
			// Oops it may bomb!!
                        tempLocalCostArray[1][j] = spectrumDis(binSpectra[0][i-2], binSpectra[filenum][j-2], info[0][i-2], info[filenum][j-2], false);
                        //System.out.printl(i + " " + j + " " + bandConstraint + " " + AlignNode.checkWithinBound(bandConstraint, i, j));
			if (dd2 > dd1 && dd2 > dd3) {
			    index = 2;
			    dmin = dd2;
			} else if (dd3 > dd1 && dd3 > dd2) {
			    index = 3;
			    dmin = dd3;
			} else {                              
			    index = 1;
			    dmin = dd1;
			}
		    }

		    //matrix[i-1][j+1].score = dmin; //assigns cumlulative cost to matrix(i,j)
                    
                    //System.out.print(",");
                    if(AlignNode.checkWithinBound(this.bandConstraint, i-1, j+1))
                    {
                        int[] newCor = AlignNode.rotateOrigin(this.bandConstraint, i-1, j+1);
                        this.diaArray[newCor[0]][newCor[1]].score = dmin;
                    //    this.diaArray[newCor[0]][newCor[1]].index = index;                                               
                    }
                    
                    if(AlignNode.checkWithinBound(this.bandConstraint, i-2, j))
                    {
                        int[] newCor = AlignNode.rotateOrigin(this.bandConstraint, i-2, j);
                        this.diaArray[newCor[0]][newCor[1]].index = index;                                               
                    }
                    
                    
                    accCostArray[2][j].score = dmin; 
                    
		    tt = (double)((double)tarNum/(double)j);
		    tt = (double)(refNum / tt);
		    tt = i-2-tt;

		}
                
                //shift accCostArray + 1
                accCostArray[0] = accCostArray[1];
                accCostArray[1] = accCostArray[2];

	    }
          
        }

        
        public boolean checkConstraint(int refNum, int tarNum, int i, int j) {
            
            boolean b = false;
            double  tt;
            
            tt = (double)((double)tarNum/(double)j);
            tt = (double)(refNum / tt);
            tt = i-tt;
            if (Math.abs(tt) > bandConstraint) {
                b = true;
            }
            return b;
        }
        
        public void findPath(int numfile, int refNum, int tarNum) {
		//int 	i = refNum+1;
		//int 	j = tarNum+1;
		int	index = 0;
		int	cnt = 0;
                int     ind;
		double	temp;
                boolean exportMatrix = false;
		
		//start at top right hand corner of matrix and find path down to bottom left corner
                //if(exportMatrix) {
                 //   printMatrix(numfile, true, refNum, tarNum);
                //}
                
                System.out.println("Finding Path Through Matrix ...");
                ChroProgressDialog.addMessageWithLine(progress, "Finding Path Through Matrix ...");
                int i = refNum;
                int j = tarNum;
		//i--;
		//j--;
                ind = numfile - 1;
		while (i > 2 || j > 2 ) {
                        //System.out.println("i = " + i + "\tj = " + j);
                    
                        int[] newCor = AlignNode.rotateOrigin(this.bandConstraint, i, j);
                                                
			//index = matrix[i][j].index;
                        index = this.diaArray[newCor[0]][newCor[1]].index;
                        
                        //System.out.println("============>>" + matrix[i][j].index + "\t" + this.diaArray[newCor[0]][newCor[1]].index);
			temp = 0;
                        //System.out.print(index);
  			if (index == 1) {
			//	System.out.println("index = 1");
    				i = i-1;
    				j = j-1;
                                pathArray[ind][0][cnt] = (i<2)?2:i;
                                pathArray[ind][1][cnt] = (j<2)?2:j;
                                
  			} else if (index == 2) {
			//	System.out.println("index = 2");
    				i = i-2;
                                j = j-1;
                                pathArray[ind][0][cnt] = (i<2)?2:i+1;
                                pathArray[ind][1][cnt] = (j<2)?2:j;
                                cnt++;
                                pathArray[ind][0][cnt] = (i<2)?2:i;
                                pathArray[ind][1][cnt] = (j<2)?2:j;
				
				//i = i-1;
  			} else if (index == 3) {
			//	System.out.println("index = 3");
				i = i-1;
				j = j-2;
                                pathArray[ind][0][cnt] = (i<2)?2:i;
                                pathArray[ind][1][cnt] = (j<2)?2:j+1;
                                cnt++;
                                pathArray[ind][0][cnt] = (i<2)?2:i;
                                pathArray[ind][1][cnt] = (j<2)?2:j;
                                
                                
                                //pathArray[ind][0][cnt] = (i<2)?2:i;
                                //pathArray[ind][1][cnt] = (j<2)?2:j;
				//j = j-1;
			} else if (index == 4) {
			//	System.out.println("index = 4");
				temp =(double)((double)tarNum/(double)j);
				temp = (double)refNum/temp;
				temp = i - temp;
				if(temp <= -bandConstraint + 10) {
					j = j-1;
				} else if (temp >= bandConstraint - 10) {
					i = i-1;
				} else {
					System.out.println("> BANDCONSTRAINT: temp=" + temp);
					System.exit(0);
				}
                                pathArray[ind][0][cnt] = (i<2)?2:i;
                                 pathArray[ind][1][cnt] = (j<2)?2:j;
                        } else {    
    				System.out.println("error finding path!");
                                ChroProgressDialog.addMessageWithLine(progress, "error finding path!");
				System.exit(0);
  			}
                                                
                        //pathArray[ind][0][cnt] = (i<2)?2:i;
                        //pathArray[ind][1][cnt] = (j<2)?2:j;
                        
                        //this.masterfile;
                        
                        //this.mappingArr[numfile-1][cnt] = pathArray[ind][1][cnt];
                        //create 2 dim 
                        cnt++;
		}	
	}

        private static Element createXmlChroHeader()
    {
            
        Element root = new Element("plot");
        
        Element title = new Element("title");
        title.setText("Chromatogram");
        root.addContent(title);

        Element xLabel = new Element("xLabel");
        xLabel.setText("Retention Time");
        root.addContent(xLabel);

        Element yLabel = new Element("yLabel");
        yLabel.setText("Intensity");
        root.addContent(yLabel);

        Element grid = new Element("noGrid");
        root.addContent(grid);

        Element size = new Element("size");
        size.setAttribute("width", "1000");
        size.setAttribute("height", "300");
        root.addContent(size);

        return root;
    }
        
        private static Element createXmlPlotHeader()
    {
            
        Element root = new Element("plot");
        
        Element title = new Element("title");
        title.setText("Paths");
        root.addContent(title);

        Element xLabel = new Element("xLabel");
        xLabel.setText("Reference Chromatogram");
        root.addContent(xLabel);

        Element yLabel = new Element("yLabel");
        yLabel.setText("Target Chromatogram");
        root.addContent(yLabel);

        Element grid = new Element("noGrid");
        root.addContent(grid);

        Element size = new Element("size");
        size.setAttribute("width", "750");
        size.setAttribute("height", "750");
        root.addContent(size);

        return root;
    }
        //first file in array is master
        public Element createChrodata(Element root, double[][][] files, Object[] datasetnames, int numfiles, boolean aligned) {
            int             j;
            int             i;
	    int             k;
	    int             tickLength = 500;
            String          TString = "0.##";
            DecimalFormat   formatter = new DecimalFormat(TString);
            double[][]      arr;
            int[][]         alignedarr;
            int             index = 0;
            
            //master file is first
            arr = files[0];
            Element xTicks = new Element("" +
                    "xTicks");
            root.addContent(xTicks);
            k=0;
            for(j=0;j<arr[1].length;j++) {
                if(arr[1][j] > 0) {
                    if (k == tickLength) {
                        Element tick = new Element("tick");
                        tick.setAttribute("label", formatter.format(arr[0][j]));
                        tick.setAttribute("position",formatter.format(arr[0][j]));
                        root.addContent(tick);
			k = 0;
                    }
                }
                k++;
            }
            
            //targetMS1Files[index]
            
            
                    
            while(index < numfiles) {
                
                Element dataset = new Element("dataset");
                //dataset.setAttribute("name", datasetnames[index].toString());
                
                dataset.setAttribute("name", filenames[index].toString());                
                dataset.setAttribute("marks", "none");
                dataset.setAttribute("connected", "yes");
                dataset.setAttribute("stems", "no");

                k=0;
                if (aligned) {
                    alignedarr = pathArray[(int)index/2];
                    System.out.println("index = " + index + "\t" + "length = " + alignedarr[1].length);
                    for(j=0;j<alignedarr[1].length;j++) {
                        if(alignedarr[0][j] > 0) {
                            Element point = new Element("p");
                            point.setAttribute("x", formatter.format(files[0][0][alignedarr[0][j]]));
                            if (index == 0) {
                                point.setAttribute("y", formatter.format(arr[1][alignedarr[0][j]]));
                                //point.setAttribute("alignedarr", formatter.format(alignedarr[0][j]));
                                //point.setAttribute("j", formatter.format(j));
                            } else {
                                point.setAttribute("y", formatter.format(arr[1][alignedarr[1][j]]));
                            }
                            dataset.addContent(point);
                        }
                    }
                } else {
                    System.out.println("array length = " + arr.length + " " + arr[1].length);
                    for(j=0;j<arr[1].length;j++) {
                        if(arr[1][j] > 0) {
                            Element point = new Element("p");
                            point.setAttribute("x", formatter.format(arr[0][j]));
                            point.setAttribute("y", formatter.format(arr[1][j]));
                            dataset.addContent(point);
                        }
                       // else {System.out.println("."); }
                    }
                    k++;
                }
                
                root.addContent(dataset);
                                
                index++;
                if (index < numfiles) {
                    arr = files[index];
                }
            }
            return root;
        }
        
        //first file in array is master
        public Element createPathdata(Element root, double[][][] files, Object[] datasetnames, int numfiles) {
            int             j;
            int             i;
	    int             k;
	    int             tickLength = 500;
            String          TString = "0.##";
            DecimalFormat   formatter = new DecimalFormat(TString);
            int[][]      arr;
            int             index = 0;
            
            //master file is first
            //arr = pathArray[0];
            arr = pathArray[0];
            Element xTicks = new Element("xTicks");
            root.addContent(xTicks);
            k=0;
            for(j=0;j<arr[1].length;j++) {
                if(arr[0][j] > 0) {
                    if (k == tickLength) {
                        Element tick = new Element("tick");
                        tick.setAttribute("label", formatter.format(arr[0][j]));
                        tick.setAttribute("position",formatter.format(arr[0][j]));
                        root.addContent(tick);
			k = 0;
                    }
                }
                k++;
            }
            Element yTicks = new Element("yTicks");
            root.addContent(yTicks);
            k=0;
            for(j=0;j<arr[1].length;j++) {
                if(arr[0][j] > 0) {
                    if (k == tickLength) {
                        Element tick = new Element("tick");
                        tick.setAttribute("label", formatter.format(arr[1][j]));
                        tick.setAttribute("position",formatter.format(arr[1][j]));
                        root.addContent(tick);
			k = 0;
                    }
                }
                k++;
            }
            
            while(index < numfiles-1) {
                
                Element dataset = new Element("dataset");
                //dataset.setAttribute("name", datasetnames[index].toString());
                
                if(index>=this.masterfile)
                    dataset.setAttribute("name", filenames[index+1].toString());
                else
                    dataset.setAttribute("name", filenames[index].toString());

                dataset.setAttribute("sample", datasetnames[index+1].toString());
                dataset.setAttribute("marks", "none");
                dataset.setAttribute("connected", "yes");
                dataset.setAttribute("stems", "no");
                
                k=0;
                for(j=0;j<arr[1].length;j++) {
                    if(arr[0][j] > 0) {
                        Element point = new Element("p");
                        point.setAttribute("x", formatter.format(arr[0][j]));
                        point.setAttribute("y", formatter.format(arr[1][j]));
                        dataset.addContent(point);
                    }
                    k++;
                }
                
                root.addContent(dataset);
                
                index++;
                arr = pathArray[index];
                //arr = newpathArray[index];
            }
            return root;
        }
        
        public void writeOutputFile(Element root, String filename) {
            //output xml file
            try {
                Document doc = new Document(root);
		
                OutputStream os = null;
		if( this.workFolder.endsWith("/") || this.workFolder.endsWith("\\") )
		    os = new FileOutputStream(this.workFolder + filename);
		else
		    os = new FileOutputStream(this.workFolder + File.separator + filename);

                XMLOutputter outputter = new XMLOutputter();
                outputter.setFormat(Format.getPrettyFormat());
                outputter.output(doc, os);
                os.close();
            } catch (IOException e)
            {
                System.out.println("IO Error while generating " + filename + " file : " + e);
                e.printStackTrace();
            }
        }
        
	public void writeOutputLine(String Filename, StringBuffer Data, boolean OverWrite) {
                try {
                        File             OutputFile = new File(Filename);
                        FileWriter       OutputFileWriter = new FileWriter(OutputFile, OverWrite);
                        BufferedWriter   Outgoing = new BufferedWriter(OutputFileWriter);
                        Outgoing.write(Data.toString());
                        Outgoing.close();
                } catch (IOException failure) {
                        System.out.println("IO Error while writing " + Filename);
                        System.exit(0);
                }
        }	

        /*
	public void printBPChro(double[][] array) {
                int i;
                int j;

                for(j=0;j<array[1].length;j++) {
			if(array[1][j] > 0) {
                        	StringBuffer sb = new StringBuffer(maxTimeElements);
                        	sb.append(array[0][j] + "\t" + array[1][j]);
                        	System.out.println(sb);
			}
                }
        }
*/

	public Peak basePeak(Iterator<Peak> peaks) {
		Peak	tpeak;
		Peak	bpeak = new Peak(0,0);
		double	maxint = 0.0;

		while (peaks.hasNext()) {
			tpeak = peaks.next();
			if (tpeak.getIntensity() > maxint) {
				maxint = tpeak.getIntensity();
				bpeak  = tpeak;
			}
		}
		return bpeak;
	}
        
        public double[] getSpectrumInfo(double[] peaks) {
		double	maxint = 0.0;
                double[]    info = new double[4];
                double      sum = 0;
                double      avg = 0;
                int         cnt = 0;
                double      sumOfDiff = 0;
                double      stdev = 0;

		//calculate average intensity and sum of intensities and base peak in binned spectrum
                for (int i=0;i<peaks.length;i++) {
                    sum += peaks[i];
                    if (peaks[i] > maxint) {
                            maxint = peaks[i];
                    }
                    cnt++;
		}
                
                avg = sum / peaks.length;
                
                //calculate standard deviation of peak intensities for binned spectrum
                for (int i=0;i<peaks.length;i++) {
                    sumOfDiff += (peaks[i] - avg) * (peaks[i] - avg);
		}
                stdev = sumOfDiff / (peaks.length - 1);
                stdev = Math.sqrt(stdev);
                
                //output info as 1D array 
                info[0] = maxint; //base peak intensity
                info[1] = sum;  //sum of intensities
                info[2] = avg;  //average intensity
                info[3] = stdev;  //stdev of intensity
                
                //System.out.println("bpeak= " + maxint + "\tsumofint= " + sum + "\tavg= " + avg + "\tstdev = " + stdev);
                
		return info;
        }

	//pearson correlation between two binned spectra
	public double spectrumDis(double[] binRefSpectra, double[] binTarSpectra, double[] refinfo, double[] tarinfo,  boolean DotProduct) {
		int	i;
                double  sumOfDiff=0;
                double  answer = 0;

                for(i=0;i<binRefSpectra.length;i++) {
                    sumOfDiff += (binRefSpectra[i] - refinfo[2]) * (binTarSpectra[i] - tarinfo[2]);
                } 

                answer = sumOfDiff / (binRefSpectra.length * refinfo[3] * tarinfo[3]);
                    /*
                    if(binRefSpectra.length * refinfo[3] * tarinfo[3] <= 0) {
                        System.out.println("--" + binRefSpectra.length + "\t" + refinfo[3] + "\t" + tarinfo[3] + "\t"  + ((double)binRefSpectra.length * refinfo[3] * tarinfo[3]) + "\t" + answer);
                        System.out.println("Avg Ref = " + refinfo[2] + "\tAvg Tar = " + tarinfo[2] + "\tStDev Ref = " + refinfo[3] + "\tStDev Tar = " + tarinfo[3] + "\tSumOfDiff = " + sumOfDiff + "\tNum = " + binRefSpectra.length + "\tPcorrelation = " + answer);
                    }
                */
                    
                return answer;
        }
        
        double[] binSpectrum(Iterator<Peak> peaks, double precision, double max, int maxSize) {
		double[]    arr = new double[(int)(maxSize/precision) + 1];
                Peak        p;
                while(peaks.hasNext()) {
                    p = peaks.next();
                    if((int)(p.getM2z()/precision) < (int)(maxSize/precision)) {
                        //System.out.println((int)max/precision + "\t" + (int)(p.getM2z()/precision) + "\t" + (int)(maxSize/precision));
                        arr[(int)(p.getM2z()/precision)] += p.getIntensity();
                    } else {
                        System.out.println("Peak " + p.getM2z() + " is bigger than " + maxSize);
                    }
                }
		return arr;
	}
        
	public double euclidianDis(double q, double c) {
		double d;
		d = (q - c);
		d = d*d;
		return d;
	}

        public double correlation (double[] abun1, double[] abun2, double tolerance) {
            	double r = 0;
                double  delta;
            	int index;
            	double Sumx, Sumy, Sumxy, Sumx2, Sumy2, x, y;
                int cnt = 0;
                int number;
                
                if(abun1.length >= abun2.length) {
                    number = abun1.length;
                } else {
                    number = abun2.length;
                }

            	Sumx = 0; Sumy = 0; Sumx2 = 0; Sumy2 = 0; Sumxy = 0;
            	for (index = 0; index < abun1.length; index++) {
                    cnt = 0;
                    delta = abun1[index]/1000000*tolerance;
                    x = abun1[index];
                    while (abun2[cnt] < abun1[index] - delta && cnt < abun2.length) {
                        cnt++;
                    }
                    if(abun2[cnt] >= abun1[index] - delta && abun2[cnt] < abun1[index] + delta && cnt < abun2.length) {
                        y = abun2[cnt];
                    } else {
                        y = 0;
                    }
                    Sumx += x;
                    Sumy += y;
                    Sumx2 += x*x;
                    Sumy2 += y*y;
                    Sumxy += x*y;
            	}
                
            	r = (Sumxy - Sumx*Sumy/number)/((double) Math.sqrt((Sumx2 - Sumx*Sumx/number) * (Sumy2 - Sumy*Sumy/number)));
		return r;
        }
        
	public void usage() {
		System.out.println("\nUSAGE: chroalign [target MS1File] [reference MS1File]");
	}

    public String[] getTargetMS1Files() {
        return targetMS1Files;
    }

    public String getReferenceMS1File() {
        return referenceMS1File;
    }
}
