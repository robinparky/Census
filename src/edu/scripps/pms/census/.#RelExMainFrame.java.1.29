/*
 * RelaxMainFrame.java
 *
 * Created on March 18, 2005, 3:52 PM
 */

package edu.scripps.pms.census;

import edu.scripps.pms.census.dialog.*;
import javax.swing.*;
import java.io.*;
import edu.scripps.pms.util.stat.StatCalc;

import java.awt.Container;
import java.awt.Color;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Font;
import java.awt.Dimension;

import java.awt.event.*;
import javax.swing.table.*;

import java.util.*;
import java.text.DecimalFormat;
import java.text.NumberFormat;

import edu.scripps.pms.census.util.SimpleFileNameFilter;
import edu.scripps.pms.census.io.parse.ChroXMLParser;
import edu.scripps.pms.census.io.*;
        
import edu.scripps.pms.census.hash.*;
import edu.scripps.pms.census.util.RelExFileFilter;
import edu.scripps.pms.census.util.PostCalculation;
import edu.scripps.pms.census.util.CalcUtil;

import edu.scripps.pms.util.io.DTASelectFilterReader;
import edu.scripps.pms.util.dtaselect.Protein;
import edu.scripps.pms.util.dtaselect.Peptide;

import edu.scripps.pms.util.io.*;
import edu.scripps.pms.util.spectrum.*;

import edu.scripps.pms.census.model.*;

import javax.swing.table.DefaultTableModel;

import ptolemy.plot.*;
import org.jdom.*;
import org.jdom.input.SAXBuilder;

import ptolemy.plot.plotml.PlotBoxMLParser;
import ptolemy.plot.plotml.PlotMLParser;
import edu.scripps.pms.census.plot.*;

import edu.scripps.pms.census.util.LinearRegression;
import edu.scripps.pms.census.conf.PostOptions;
import edu.scripps.pms.census.conf.Configuration;

import edu.scripps.pms.census.chroalign.*;
import gnu.trove.TIntLongHashMap;
import gnu.trove.TIntDoubleHashMap;

import edu.scripps.pms.stats.STDev;

/**
 *
 * @author  Robin Park
 * @version $Id: RelExMainFrame.java,v 1.29 2007/03/30 06:29:58 rpark Exp $
 */

public class RelExMainFrame extends javax.swing.JFrame {

    private static String version;
    private boolean chroFileOpen=false;
    
    /** Creates new form RelaxMainFrame */
    public RelExMainFrame() {

        Configuration conf = Configuration.getInstance();
        version = conf.getVersion();
        initComponents();
        initAdditional();
 //       initTest();
    }

    public void printHeader(PrintStream p)
    {
	p.println("H\tCensus version " + version);                    
	p.println("H\tCensus a merged file");
	p.println("H\tCreate by ");
	p.println("H\tRobin, Sung Kyu Park rpark@scripps.edu");
	p.println("H\tJohn Venable jvenable@scripps.edu");		    
	p.println("H\tMichael J. MacCoss");                    
	p.println("H\tThe Scripps Research Institute, La Jolla, CA");
	p.println("H\tOL stands for outlier");
	p.print("H\tcreated date\t"); p.println(new Date());                    
        
    }
    
    private void initAdditional()
    {                
        proteinSimpleTable = new JTable(proteinSimpleTableModel) {
            public Component prepareRenderer(TableCellRenderer renderer, int rowIndex, int columnIndex) {
                    Component c = super.prepareRenderer(renderer, rowIndex, columnIndex);
                    /*
                    System.out.println("===>>" + columnIndex);
                    if (rowIndex == 0) {
                            c.setFont(new Font("Arial", Font.BOLD, 18));
                    } */
                    if (rowIndex % 2 == 1 && !isCellSelected(rowIndex, columnIndex)) {
                            c.setFont(getFont());
                            c.setBackground(new Color(182, 208, 255)); 
                    } else if (isCellSelected(rowIndex, columnIndex)) {
                            // do nothing to allow operating system to handle shading
                    } else {
                            c.setFont(getFont());
                            c.setBackground(new Color(255, 255, 255)); // a light yellow
                    }
                    return c;
            }  
        };                                
                
        this.proteinSimplePane.setViewportView(proteinSimpleTable);
        
        peptideListTable = new javax.swing.JTable(peptideTableModel) {
            public Component prepareRenderer(TableCellRenderer renderer, int rowIndex, int columnIndex) {
                    Component c = super.prepareRenderer(renderer, rowIndex, columnIndex);

                    if (rowIndex % 2 == 1 && !isCellSelected(rowIndex, columnIndex)) {
                            c.setFont(getFont());
                            c.setBackground(new Color(182, 208, 255)); 
                    } else if (isCellSelected(rowIndex, columnIndex)) {
                            // do nothing to allow operating system to handle shading
                    } else {
                            c.setFont(getFont());
                            c.setBackground(new Color(255, 255, 255)); // a light yellow
                            // if not shaded, match the table's background
                            //c.setBackground(getBackground());
                            //c.setFont(getFont());
                            //c.setForeground(getForeground());
                    }
                    return c;
            }  
        };
        
        peptideList.setViewportView(peptideListTable);
        
        peptideListTable.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                peptideListTableKeyPressed(evt);
            }
        });
        peptideListTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                peptideListTableMouseClicked(evt);
            }
        });
        
        proteinSimpleTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                proteinSimpleTableMouseClicked(evt);
            }
        });
        
        proteinSimpleTable.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                proteinSimpleTableKeyPressed(evt);
            }
        });
        
        proteinSimplePane.setViewportView(proteinSimpleTable);
        
                /*
        int vColIndex = 1;
TableColumn col = table.getColumnModel().getColumn(vColIndex);
int width=399;
col.setPreferredWidth(width);
*/
        
        TableColumn column = null;
        
        column = peptideListTable.getColumnModel().getColumn(0);
        column.setPreferredWidth(10);
        
        column = this.proteinTable.getColumnModel().getColumn(0);
        column.setPreferredWidth(10);
        
                  /*
        for (int i = 0; i < peptideListTable.getColumnCount(); i++) {
            column = peptideListTable.getColumnModel().getColumn(i);
        
            column.setPreferredWidth(1);
            
            
            switch(i)
            {
                case 0:
                    column.setPreferredWidth(1);
                    System.out.println("aaaaaaaa");
                    break;
                    
                case 1:
                    column.setPreferredWidth(1);
                    break;
              
                case 2:
                    break;
                case 3:
                    break;
                case 4:
                    break;
                case 5:
                    break;
                case 6:
                    break;                
                    
                default :
                    //column.setPreferredWidth(100);
                    break;
                    
            }
            
        }
            */    
        corrPlot = new CorrelationPlot();        
        corrPlot.setBackground(new Color(255, 255, 255));  
        corrPlot.setSize(250, 250);
        
        PostOptions options = PostOptions.getInstance();
        options.setFilterFragmentIons(true);
        options.setDisplayFragmentIons(false);
        
        
        this.tabbedPanel.setVisible(false);
        this.tabbedPanel.hide();

        
        proteinRatioDistPanel.setLayout(new java.awt.BorderLayout());
        pepTabbedPanel.addTab("Peptide Ratio Dist", proteinRatioDistPanel); 
        
        
        tabbedPanel.setEnabledAt(1,false);
    }
    
    private void initTest()
    {
        tabbedPanel.setEnabledAt(1,false);
      
        
        ////remove this later.  this is for testing..
//        File file = new File("/home/rpark/rpark_on_data/relax_run/BDCHN15");

        File tempFile = new File("/home/rpark/rpark_on_data/relax_run/BDCHN15/N15isotope.ini");
        
        //File tempFile = new File("E:\\relex\\newFinal_data\\data-independent\\N15isotope.ini");
        isotopeFileField.setText(tempFile.getAbsolutePath());
        currentDirectory = "/home/rpark/rpark_on_data/relax_run/BDCHN15";
        //currentDirectory = "E:\\relex\\newFinal_data\\data-independent";
        this.reportItem.setEnabled(true);
        //String dtaselectFile="e:\\DTASelect.txt";           
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        extractRadioGrp = new javax.swing.ButtonGroup();
        quantModeRadioGrp = new javax.swing.ButtonGroup();
        jPanel1 = new javax.swing.JPanel();
        chroPanel = new javax.swing.JPanel();
        isotopeLabel = new javax.swing.JLabel();
        isotopeFileField = new javax.swing.JTextField();
        fileSelectBtn = new javax.swing.JButton();
        extractPanel = new javax.swing.JPanel();
        jRadioButton1 = new javax.swing.JRadioButton();
        jRadioButton2 = new javax.swing.JRadioButton();
        jPanel2 = new javax.swing.JPanel();
        fullMassScan = new javax.swing.JRadioButton();
        msmsScan = new javax.swing.JRadioButton();
        jPanel3 = new javax.swing.JPanel();
        jCheckBox1 = new javax.swing.JCheckBox();
        jLabel2 = new javax.swing.JLabel();
        scanBefore = new javax.swing.JTextField();
        scanAfter = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        jCheckBox2 = new javax.swing.JCheckBox();
        jTextField5 = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jCheckBox3 = new javax.swing.JCheckBox();
        jTextField6 = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        extractBtn = new javax.swing.JButton();
        resetBtn = new javax.swing.JButton();
        chorNoteLabel1 = new javax.swing.JLabel();
        chroNoteLabel2 = new javax.swing.JLabel();
        peptideListBox = new javax.swing.JPanel();
        quanPanel = new javax.swing.JPanel();
        fragIonScrollPanel = new javax.swing.JScrollPane();
        fragIonPanel = new javax.swing.JPanel();
        jToolBar1 = new javax.swing.JToolBar();
        open = new javax.swing.JButton();
        save = new javax.swing.JButton();
        export = new javax.swing.JButton();
        filterBtn = new javax.swing.JButton();
        filePathLabel = new javax.swing.JLabel();
        tabbedPanel = new javax.swing.JTabbedPane();
        proteinPanel = new javax.swing.JPanel();
        proteinListPanel = new javax.swing.JScrollPane();
        proteinTable = new javax.swing.JTable(proteinTableModel) {
            public Component prepareRenderer(TableCellRenderer renderer, int rowIndex, int columnIndex) {
                Component c = super.prepareRenderer(renderer, rowIndex, columnIndex);
                if (rowIndex % 2 == 1 && !isCellSelected(rowIndex, columnIndex)) {
                    c.setFont(getFont());
                    c.setBackground(new Color(255, 255, 204)); // a light yellow
                } else if (isCellSelected(rowIndex, columnIndex)) {
                    // do nothing to allow operating system to handle shading
                } else {
                    c.setFont(getFont());
                    c.setBackground(new Color(255, 255, 255)); // a light yellow
                }
                return c;
            }
        };
        searchField = new javax.swing.JTextField();
        searchBtn = new javax.swing.JButton();
        peptidePanel = new javax.swing.JPanel();
        peptideList = new javax.swing.JScrollPane();
        proteinSimplePane = new javax.swing.JScrollPane();
        proteinInfoPanel = new javax.swing.JPanel();
        proteinLabel = new javax.swing.JLabel();
        jSplitPane = new javax.swing.JSplitPane();
        paramPanel = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        shiftField = new javax.swing.JTextField();
        shiftLabel = new javax.swing.JLabel();
        rrField = new javax.swing.JTextField();
        measuredRatioLabel = new javax.swing.JLabel();
        regressionRatioField = new javax.swing.JTextField();
        areaRatioField = new javax.swing.JTextField();
        measuredRatioLabel1 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        areaRatioLogField = new javax.swing.JTextField();
        pepTabbedPanel = new javax.swing.JTabbedPane();
        chromatogramPanel = new javax.swing.JPanel();
        correlationPanel =    new javax.swing.JPanel();
        mainPanel = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        welcomeLabel = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        openItem = new javax.swing.JMenuItem();
        reportItem = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JSeparator();
        jMenuItem2 = new javax.swing.JMenuItem();
        runMenu = new javax.swing.JMenu();
        runItem = new javax.swing.JMenuItem();
        runNonLabel = new javax.swing.JMenuItem();
        confItem = new javax.swing.JMenuItem();
        toolMenu = new javax.swing.JMenu();
        optionItem = new javax.swing.JMenuItem();
        mergeItem = new javax.swing.JMenuItem();
        alignSpectra = new javax.swing.JMenuItem();
        openSpectra = new javax.swing.JMenuItem();
        mrmCsv = new javax.swing.JMenuItem();

        chroPanel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        chroPanel.setEnabled(false);
        isotopeLabel.setText("Select isotope file");
        isotopeLabel.setPreferredSize(new java.awt.Dimension(10, 14));
        chroPanel.add(isotopeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 10, 150, -1));

        chroPanel.add(isotopeFileField, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 30, 270, -1));

        fileSelectBtn.setLabel("...");
        fileSelectBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fileSelectBtnActionPerformed(evt);
            }
        });

        chroPanel.add(fileSelectBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(290, 30, -1, -1));

        extractPanel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        extractPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Extraction Options"));
        extractRadioGrp.add(jRadioButton1);
        jRadioButton1.setSelected(true);
        jRadioButton1.setText("Single Experiment");
        extractPanel.add(jRadioButton1, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 30, -1, -1));

        extractRadioGrp.add(jRadioButton2);
        jRadioButton2.setText("Multiple Experiment");
        jRadioButton2.setEnabled(false);
        extractPanel.add(jRadioButton2, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 60, -1, -1));

        chroPanel.add(extractPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 80, 180, 110));

        jPanel2.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder("Quantitation Mode Options"));
        quantModeRadioGrp.add(fullMassScan);
        fullMassScan.setSelected(true);
        fullMassScan.setText("Full Mass Scans");
        fullMassScan.setActionCommand("f");
        jPanel2.add(fullMassScan, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 30, -1, -1));

        quantModeRadioGrp.add(msmsScan);
        msmsScan.setText("MS/MS spectra");
        msmsScan.setActionCommand("m");
        jPanel2.add(msmsScan, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 60, -1, -1));

        chroPanel.add(jPanel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 210, 180, 110));

        jPanel3.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder("Time Width Options"));
        jCheckBox1.setSelected(true);
        jCheckBox1.setText("Extract by number of MS scans");
        jPanel3.add(jCheckBox1, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 30, -1, -1));

        jLabel2.setText("scans before");
        jPanel3.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(280, 30, -1, -1));

        scanBefore.setText("50");
        jPanel3.add(scanBefore, new org.netbeans.lib.awtextra.AbsoluteConstraints(240, 30, -1, -1));

        scanAfter.setText("50");
        jPanel3.add(scanAfter, new org.netbeans.lib.awtextra.AbsoluteConstraints(240, 60, -1, -1));

        jLabel3.setText("scans after");
        jPanel3.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(280, 60, -1, -1));

        chroPanel.add(jPanel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(210, 80, 400, 110));

        jPanel4.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jPanel4.setBorder(javax.swing.BorderFactory.createTitledBorder("Ion Chromatogram m/z width options"));
        jCheckBox2.setSelected(true);
        jCheckBox2.setText("Automatic isotope window");
        jPanel4.add(jCheckBox2, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 30, -1, -1));

        jTextField5.setText("98.0");
        jPanel4.add(jTextField5, new org.netbeans.lib.awtextra.AbsoluteConstraints(180, 30, -1, -1));

        jLabel4.setText("ape");
        jPanel4.add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 30, -1, -1));

        jCheckBox3.setText("Fixed m/z window");
        jCheckBox3.setEnabled(false);
        jPanel4.add(jCheckBox3, new org.netbeans.lib.awtextra.AbsoluteConstraints(20, 60, -1, -1));

        jTextField6.setEditable(false);
        jTextField6.setText("2.5");
        jPanel4.add(jTextField6, new org.netbeans.lib.awtextra.AbsoluteConstraints(180, 60, -1, -1));

        jLabel5.setText("+/- m/z");
        jPanel4.add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(220, 60, -1, -1));

        chroPanel.add(jPanel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(210, 210, 310, 130));

        extractBtn.setText("Extract");
        extractBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                extractBtnActionPerformed(evt);
            }
        });

        chroPanel.add(extractBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(310, 370, -1, -1));

        resetBtn.setText("Reset");
        resetBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetBtnActionPerformed(evt);
            }
        });

        chroPanel.add(resetBtn, new org.netbeans.lib.awtextra.AbsoluteConstraints(390, 370, -1, -1));

        chorNoteLabel1.setText("Note. DTASelect-filter.txt and raw files are");
        chroPanel.add(chorNoteLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(340, 30, -1, 20));

        chroNoteLabel2.setText("assumed to be in the same folder");
        chroPanel.add(chroNoteLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(370, 50, -1, -1));

        peptideListBox.setLayout(new java.awt.BorderLayout());

        peptideListBox.setBorder(javax.swing.BorderFactory.createTitledBorder("Peptide List"));
        quanPanel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        fragIonScrollPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("FragIon"));
        fragIonPanel.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        fragIonPanel.setBackground(new java.awt.Color(255, 255, 255));
        fragIonScrollPanel.setViewportView(fragIonPanel);

        quanPanel.add(fragIonScrollPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(1020, 10, 310, 510));

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Census Main");
        jToolBar1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jToolBar1.setToolTipText("open");
        open.setIcon(new javax.swing.ImageIcon(getClass().getResource("/open.gif")));
        open.setToolTipText("new");
        open.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        open.setMargin(new java.awt.Insets(2, 2, 2, 2));
        open.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openActionPerformed(evt);
            }
        });

        jToolBar1.add(open);

        save.setIcon(new javax.swing.ImageIcon(getClass().getResource("/save.gif")));
        save.setToolTipText("save");
        save.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        save.setMargin(new java.awt.Insets(2, 2, 2, 2));
        save.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveActionPerformed(evt);
            }
        });

        jToolBar1.add(save);

        export.setIcon(new javax.swing.ImageIcon(getClass().getResource("/export.gif")));
        export.setToolTipText("export report");
        export.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        export.setMargin(new java.awt.Insets(2, 2, 2, 2));
        export.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportActionPerformed(evt);
            }
        });

        jToolBar1.add(export);

        filterBtn.setIcon(new javax.swing.ImageIcon(getClass().getResource("/filter.gif")));
        filterBtn.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        filterBtn.setMargin(new java.awt.Insets(2, 2, 2, 2));
        filterBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                filterBtnActionPerformed(evt);
            }
        });

        jToolBar1.add(filterBtn);

        filePathLabel.setToolTipText("File Path");
        jToolBar1.add(filePathLabel);

        proteinTable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                proteinTableMouseClicked(evt);
            }
        });

        proteinListPanel.setViewportView(proteinTable);

        searchField.setMaximumSize(null);
        searchField.setPreferredSize(new java.awt.Dimension(39, 19));
        searchField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                searchFieldActionPerformed(evt);
            }
        });

        searchBtn.setText("Search");
        searchBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                searchBtnActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout proteinPanelLayout = new org.jdesktop.layout.GroupLayout(proteinPanel);
        proteinPanel.setLayout(proteinPanelLayout);
        proteinPanelLayout.setHorizontalGroup(
            proteinPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(proteinPanelLayout.createSequentialGroup()
                .add(searchField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 168, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(searchBtn)
                .addContainerGap(1150, Short.MAX_VALUE))
            .add(org.jdesktop.layout.GroupLayout.TRAILING, proteinListPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1398, Short.MAX_VALUE)
        );
        proteinPanelLayout.setVerticalGroup(
            proteinPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(proteinPanelLayout.createSequentialGroup()
                .add(proteinPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(searchBtn)
                    .add(searchField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 23, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(proteinListPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 712, Short.MAX_VALUE)
                .add(111, 111, 111))
        );
        tabbedPanel.addTab("Proteins", proteinPanel);

        peptidePanel.setBackground(new java.awt.Color(102, 102, 255));
        peptideList.setBorder(javax.swing.BorderFactory.createTitledBorder("Peptides"));
        peptideList.setMinimumSize(new java.awt.Dimension(31, 200));
        peptideList.setPreferredSize(new java.awt.Dimension(31, 200));

        proteinSimplePane.setBorder(javax.swing.BorderFactory.createTitledBorder("Proteins"));

        proteinInfoPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        proteinLabel.setText(" ");

        org.jdesktop.layout.GroupLayout proteinInfoPanelLayout = new org.jdesktop.layout.GroupLayout(proteinInfoPanel);
        proteinInfoPanel.setLayout(proteinInfoPanelLayout);
        proteinInfoPanelLayout.setHorizontalGroup(
            proteinInfoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(proteinInfoPanelLayout.createSequentialGroup()
                .add(proteinLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1193, Short.MAX_VALUE)
                .addContainerGap())
        );
        proteinInfoPanelLayout.setVerticalGroup(
            proteinInfoPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(proteinLabel)
        );

        jSplitPane.setDividerLocation(700);
        jSplitPane.setMinimumSize(new java.awt.Dimension(100, 81));
        paramPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Scores"));
        paramPanel.setMinimumSize(new java.awt.Dimension(0, 0));
        paramPanel.setPreferredSize(new java.awt.Dimension(4, 19));
        jLabel6.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel6.setText("R^2");

        shiftField.setColumns(3);

        shiftLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        shiftLabel.setText("shift");

        rrField.setColumns(10);
        rrField.setMaximumSize(new java.awt.Dimension(4, 19));

        measuredRatioLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        measuredRatioLabel.setText("Regression Ratio");

        regressionRatioField.setColumns(10);

        areaRatioField.setColumns(10);
        areaRatioField.setMaximumSize(new java.awt.Dimension(4, 19));

        measuredRatioLabel1.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        measuredRatioLabel1.setText("Area Ratio");

        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel1.setText("Ln (Regression Ratio)");

        areaRatioLogField.setColumns(10);

        org.jdesktop.layout.GroupLayout paramPanelLayout = new org.jdesktop.layout.GroupLayout(paramPanel);
        paramPanel.setLayout(paramPanelLayout);
        paramPanelLayout.setHorizontalGroup(
            paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(paramPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jLabel6, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 132, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                        .add(jLabel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(measuredRatioLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                        .add(measuredRatioLabel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(shiftLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .add(23, 23, 23)
                .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING, false)
                    .add(regressionRatioField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 19, Short.MAX_VALUE)
                    .add(areaRatioLogField)
                    .add(rrField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(areaRatioField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(shiftField))
                .add(205, 205, 205))
        );
        paramPanelLayout.setVerticalGroup(
            paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(paramPanelLayout.createSequentialGroup()
                .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel6)
                    .add(rrField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel1)
                    .add(areaRatioLogField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(measuredRatioLabel)
                    .add(regressionRatioField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(measuredRatioLabel1)
                    .add(areaRatioField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(paramPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(shiftLabel)
                    .add(shiftField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(351, Short.MAX_VALUE))
        );
        jSplitPane.setRightComponent(paramPanel);

        pepTabbedPanel.setMaximumSize(new java.awt.Dimension(512, 302));
        pepTabbedPanel.setMinimumSize(new java.awt.Dimension(0, 0));
        pepTabbedPanel.setPreferredSize(new java.awt.Dimension(150, 100));
        chromatogramPanel.setLayout(new java.awt.BorderLayout());

        pepTabbedPanel.addTab("chromatogram", chromatogramPanel);

        correlationPanel.setBackground(new java.awt.Color(255, 255, 255));
        correlationPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Correlation", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 0, 11), java.awt.Color.black));
        pepTabbedPanel.addTab("correlation", correlationPanel);

        jSplitPane.setLeftComponent(pepTabbedPanel);

        org.jdesktop.layout.GroupLayout peptidePanelLayout = new org.jdesktop.layout.GroupLayout(peptidePanel);
        peptidePanel.setLayout(peptidePanelLayout);
        peptidePanelLayout.setHorizontalGroup(
            peptidePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(peptidePanelLayout.createSequentialGroup()
                .add(proteinSimplePane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 173, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(peptidePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(peptideList, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1207, Short.MAX_VALUE)
                    .add(proteinInfoPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jSplitPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1207, Short.MAX_VALUE))
                .addContainerGap())
        );
        peptidePanelLayout.setVerticalGroup(
            peptidePanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(peptidePanelLayout.createSequentialGroup()
                .add(proteinInfoPanel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(peptideList, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 258, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jSplitPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 496, Short.MAX_VALUE)
                .add(71, 71, 71))
            .add(proteinSimplePane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 854, Short.MAX_VALUE)
        );
        tabbedPanel.addTab("Peptides", peptidePanel);

        mainPanel.setLayout(new java.awt.BorderLayout());

        jLabel7.setText("\"\"");
        jLabel7.setVerticalAlignment(javax.swing.SwingConstants.TOP);
        jLabel7.setMaximumSize(new java.awt.Dimension(10, 30));
        jLabel7.setMinimumSize(new java.awt.Dimension(10, 30));
        jLabel7.setPreferredSize(new java.awt.Dimension(10, 50));
        mainPanel.add(jLabel7, java.awt.BorderLayout.NORTH);

        welcomeLabel.setFont(new java.awt.Font("Dialog", 1, 36));
        welcomeLabel.setForeground(new java.awt.Color(0, 0, 102));
        welcomeLabel.setText("Welcome to CenSus v0.963");
        welcomeLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);
        welcomeLabel.setAlignmentY(0.0F);
        mainPanel.add(welcomeLabel, java.awt.BorderLayout.CENTER);

        fileMenu.setLabel("File");
        fileMenu.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fileMenuActionPerformed(evt);
            }
        });

        openItem.setText("Open chro file...");
        openItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OpenChroFileActionPerformed(evt);
            }
        });

        fileMenu.add(openItem);

        reportItem.setText("Export Report...");
        reportItem.setEnabled(false);
        reportItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                reportItemActionPerformed(evt);
            }
        });

        fileMenu.add(reportItem);

        fileMenu.add(jSeparator1);

        jMenuItem2.setLabel("Exit");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });

        fileMenu.add(jMenuItem2);

        jMenuBar1.add(fileMenu);

        runMenu.setText("Run");
        runItem.setText("run labeled data..");
        runItem.setActionCommand("run..");
        runItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runItemActionPerformed(evt);
            }
        });

        runMenu.add(runItem);

        runNonLabel.setText("run nonlabeled data..");
        runNonLabel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                runNonLabelActionPerformed(evt);
            }
        });

        runMenu.add(runNonLabel);

        confItem.setText("configuration..");
        confItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                confItemActionPerformed(evt);
            }
        });

        runMenu.add(confItem);

        jMenuBar1.add(runMenu);

        toolMenu.setText("Tools");
        toolMenu.setActionCommand("Menu");
        optionItem.setText("Options...");
        optionItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                optionItemActionPerformed(evt);
            }
        });

        toolMenu.add(optionItem);

        mergeItem.setText("Merge...");
        mergeItem.setToolTipText("merge CenSus output files");
        mergeItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mergeItemActionPerformed(evt);
            }
        });

        toolMenu.add(mergeItem);

        alignSpectra.setText("align spectra...");
        alignSpectra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                alignSpectraActionPerformed(evt);
            }
        });

        toolMenu.add(alignSpectra);

        openSpectra.setText("Open spectra file...");
        openSpectra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                openSpectraActionPerformed(evt);
            }
        });

        toolMenu.add(openSpectra);

        mrmCsv.setText("MRM CSV generator");
        mrmCsv.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mrmCsvActionPerformed(evt);
            }
        });

        toolMenu.add(mrmCsv);

        jMenuBar1.add(toolMenu);

        setJMenuBar(jMenuBar1);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jToolBar1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1417, Short.MAX_VALUE)
            .add(layout.createSequentialGroup()
                .add(tabbedPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1403, Short.MAX_VALUE)
                .addContainerGap(14, Short.MAX_VALUE))
            .add(mainPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1417, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jToolBar1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(layout.createSequentialGroup()
                        .add(25, 25, 25)
                        .add(tabbedPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 881, Short.MAX_VALUE)))
                .addContainerGap())
            .add(org.jdesktop.layout.GroupLayout.TRAILING, mainPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 918, Short.MAX_VALUE)
        );
        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void alignSpectraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_alignSpectraActionPerformed
// TODO add your handling code here:
        
        
        JFileChooser choose = new JFileChooser();
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Select config file");
        choose.setApproveButtonText("Select config file");
       	
        if(this.currentDirectory != null)
            choose.setCurrentDirectory( new File(this.getCurrentDirectory()) );
                
        int returnVal = choose.showOpenDialog(this);        

        if(returnVal == choose.CANCEL_OPTION)
            return;
                
        final File file = choose.getSelectedFile();
        final String workFolder = file.getParent();
       
        
        final ChroProgressDialog chroProgress = new ChroProgressDialog(this, false);
        chroProgress.setLocationRelativeTo(this);
        chroProgress.setResizable(false);        
        chroProgress.setVisible(true);

        final RelExMainFrame mFrame = this; 
        try
        {

	    SAXBuilder sb = new SAXBuilder();
	    Document doc = sb.build(file);
	    final Element root = doc.getRootElement();            

	    Thread t = new Thread() {
                
                private boolean isSuccessful= false;
		public void run() {

		    try {
                        
                        Configuration conf = Configuration.getInstance();
                        String parentPath = file.getParent();
                        
                        conf.readXMLParam(parentPath + File.separator + file.getName());
                        conf.setFilePath(parentPath);
                        
			List sampleList = root.getChildren("sample");
                        
                        //Configuration.
                        String refFileName = "";
                        Element refEle = root.getChild("ref");
                        if(null != refEle)
                        {
                            //String refSamName = refEle.getChildText("sample_name");
                            refFileName = refEle.getChildText("file_name");

                            conf.setRefFileName(refFileName);
                        }
                        			

			int index=0;
			int refIndex=0;

			Vector<String> fileNameList = new Vector<String>();
			Vector<String> sampleNameList = new Vector<String>();
                        Vector<String> pathFileNameList = new Vector<String>();
                        
                        
                        //confSam.setRefFileName(refFileName);
                        //Hashtable<String, Hashtable> masterHt = new Hashtable<String, Hashtable>();
                        HashSet set = new HashSet();
                        
			for(Iterator<Element> itr = sampleList.iterator(); itr.hasNext(); )
			{
			    Element sam = itr.next();
			    String samName = sam.getChildText("name");

                            //populate configuration class
                            Configuration.Sample confSam = new Configuration.Sample();
                            confSam.setName(samName);
                            
                            
			    List fileList = sam.getChild("ms_files").getChildren("file");
                            
			    for(Iterator<Element> itr1 = fileList.iterator(); itr1.hasNext(); )
			    {
                                
				Element eachFile = itr1.next();
				String fileName = eachFile.getText();                    
                          //      masterHt.put(fileName, new Hashtable());
                                
                                confSam.addFile(fileName);
                                pathFileNameList.add(fileName);
                                
                                set.add(fileName.substring(0, fileName.lastIndexOf("/")));
                                
                                if(fileName.endsWith("ms2"))
                                {
                                    fileName = fileName.substring(0, fileName.length()-3);
                                    fileName += "ms1";
                                    
                                }
                                
				fileNameList.add(fileName);                                
				sampleNameList.add(samName);
                                
                                if( null != refEle && refFileName.equals(fileName) )
                                    refIndex = index;

                                
                                index++;
			    }
                            
                            conf.addExp(confSam);                            
			}

                        
			long start = System.currentTimeMillis();			
			chroalign align = new chroalign();       


			int[][][] pathArray = null;
                        
                        boolean isAlign = conf.isAlign();                        
                                                
                        chroProgress.setProgress(1);
                        
                        File alignFile = new File(workFolder + "/aligned_out.xml");
                        File pathoutFile = new File(workFolder + "/path_out.xml");
                        File chrooutFile = new File(workFolder + "/chro_out.xml");
                        
                        int selection = -1;
                        if(alignFile.exists() && pathoutFile.exists() && chrooutFile.exists() )
                        {
                            Object[] options = {"Yes", "No"};
                             
                            selection = JOptionPane.showOptionDialog(mFrame, 
                                    "Alignment out files are found.  Do you want to read them?", 
                                    "Alignment out files found", 
                                    JOptionPane.YES_NO_OPTION, 
                                    JOptionPane.QUESTION_MESSAGE, 
                                    null,
                                    options,
                                    options[0]
                                    );                            
                        }
                 
                        if(selection != 0) //align
                        {
                            if(isAlign) //align based on chromatogram profile
                            {
                                //pathArray = align.alignChro(chroProgress.getProgressBar(), fileNameList.toArray(), sampleNameList.toArray(), refIndex, false, 500, file.getParent());

                                pathArray = align.alignChro(chroProgress, fileNameList.toArray(), sampleNameList.toArray(), refIndex, false, 500, file.getParent());

                                NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);                        
                                conf.setMapModel(mapModel);                        
                            }
                            else //align based on retention time
                            {
                                pathArray = align.noAlignChro(chroProgress, fileNameList.toArray(), sampleNameList.toArray(), file.getParent());                            
                                NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);
                                mapModel.reinitializeMaxIndexByRet(); //this method is called only for the aligning by retention time.  Not nice idea.
                                conf.setMapModel(mapModel);
                            }

                            System.out.println( System.currentTimeMillis() );
                            String[] targetMS1Files = align.getTargetMS1Files();
                            String referenceMS1File = align.getReferenceMS1File();

                            conf.setNonlabelFilePaths(set);

                            chroProgress.addMessage("Reading Spectra and Running Quantification...");
                            
                        }
                        
                        this.isSuccessful = true;

		    } catch (Exception e)
		    {
			System.out.println("error " + e);
			e.printStackTrace();
		    }

		    SwingUtilities.invokeLater(new Runnable() {
			    public void run() {
			    //progress.setVisible(false);
                                chroProgress.setVisible(false);
                                chroProgress.hide();
                                
                                if(isSuccessful)
                                {
                                    SimplePlot sPlot = new SimplePlot();
                            //        AlignPlot sPlot = new AlignPlot();
                              //      mFrame.getProteinPanel().add(sPlot);
                                    sPlot.setVisible(true);
                                    sPlot.Go(workFolder);             
                                    
                                }
                                else
                                    JOptionPane.showMessageDialog(mFrame, "Failed to align spectra", "Failed to align spectra", JOptionPane.ERROR_MESSAGE);
                              
			    }
			    });
		}
	    };

	    t.start();                                
            
        } catch(JDOMException ex)
        {

            JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file" + ex, JOptionPane.ERROR_MESSAGE);
            chroProgress.addMessageWithLine("Error reading the config file" + ex);
            System.out.println("Error " + ex);
        } catch(IOException ex)
        {

            JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file" + ex.toString(), JOptionPane.ERROR_MESSAGE);
            chroProgress.addMessageWithLine("Error reading the config file" + ex);
            System.out.println("Error " + ex);
        } catch(Exception e)
        {
            JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file" + e.toString(), JOptionPane.ERROR_MESSAGE);
            chroProgress.addMessageWithLine("Error reading the config file" + e);
            System.out.println("Error " + e);
        }

        
    }//GEN-LAST:event_alignSpectraActionPerformed

    public static void mrmCsvTest(java.awt.event.ActionEvent evt) {                                       
	
        File file = new File("/home/rpark/001_emily_data");
        if(null==file)
            return;

        //spectrumField.setText(choose.getSelectedFile().getAbsolutePath()); //.getCurrentDirectory().toString());
        
        File[] fList = file.listFiles();
        
        boolean isDtaSelect=false;
        boolean isMs2File=false;
        boolean isMs1File=false;
        
        for(int i=0;i<fList.length;i++)
        {
            if("DTASelect-filter.txt".equals(fList[i].getName()))
                isDtaSelect = true;
            else if(fList[i].getName().endsWith("ms1"))
                isMs1File = true;
            else if(fList[i].getName().endsWith("ms2"))
                isMs2File = true;
        }
        
        StringBuffer errorSb = new StringBuffer();
        if(!isDtaSelect)
            errorSb.append("DTASlect-filter.txt is not found.\n");
        if(!isMs1File)
            errorSb.append("ms1 files are not found.\n");
        if(!isMs2File)
            errorSb.append("ms2 files are not found.\n");
        
        System.out.println(errorSb.length());
        System.out.println(errorSb.toString());
        if(errorSb.length()>0)
        {
            return;
        }
            
        
//        final ChroProgressDialog chroProgress = new ChroProgressDialog(this, false);
  //      chroProgress.setLocationRelativeTo(this);
    //    chroProgress.setResizable(false);        
      //  chroProgress.setVisible(true);
        
        Configuration conf = Configuration.getInstance();
	conf.setFilePath(file.getAbsolutePath());

        for(int i=0;i<fList.length;i++)
        {            
            System.out.println(fList[i]);
            
        }                
        
        Thread t = new Thread()
        {
            boolean isSuccessful = false;
            
            public void run()
            {   
                try {
                    ChroGenerator chro = new ChroGenerator(null);         
        
                    chro.createMRMFragmentIons(null);
                    isSuccessful = true;
                }catch(IOException e) {
                    e.printStackTrace();                    
                    
                }catch(Exception e) {
                    e.printStackTrace();
                }
                
                
                SwingUtilities.invokeLater(new Runnable()
                {
                    public void run()
                    {
                        if(isSuccessful)
                        {
                        }
                    }
                 });
            }
        };

        try {
            t.start();
            
        } catch(Exception e)
        {
            t = null;
        }
    }


    private void mrmCsvActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mrmCsvActionPerformed
// TODO add your handling code here:
        JFileChooser choose = new JFileChooser();
        choose.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        //choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Select Spectrum Directory");
        
        if(this.currentDirectory != null)
            choose.setCurrentDirectory(new File(this.currentDirectory));

        int returnVal = choose.showOpenDialog(this);
                       
        File file = choose.getSelectedFile();
        if(null==file)
            return;

        //spectrumField.setText(choose.getSelectedFile().getAbsolutePath()); //.getCurrentDirectory().toString());
        
        File[] fList = file.listFiles();
        
        boolean isDtaSelect=false;
        boolean isMs2File=false;
        boolean isMs1File=false;
        
        for(int i=0;i<fList.length;i++)
        {
            if("DTASelect-filter.txt".equals(fList[i].getName()))
                isDtaSelect = true;
            else if(fList[i].getName().endsWith("ms1"))
                isMs1File = true;
            else if(fList[i].getName().endsWith("ms2"))
                isMs2File = true;
        }
        
        StringBuffer errorSb = new StringBuffer();
        if(!isDtaSelect)
            errorSb.append("DTASlect-filter.txt is not found.\n");
        if(!isMs1File)
            errorSb.append("ms1 files are not found.\n");
        if(!isMs2File)
            errorSb.append("ms2 files are not found.\n");
        
        System.out.println(errorSb.length());
        System.out.println(errorSb.toString());
        if(errorSb.length()>0)
        {
            JOptionPane.showMessageDialog(this, errorSb.toString(), "Failed to generate a chro file", JOptionPane.ERROR_MESSAGE);
            return;
        }
            
        
        final ChroProgressDialog chroProgress = new ChroProgressDialog(this, false);
        chroProgress.setLocationRelativeTo(this);
        chroProgress.setResizable(false);        
        chroProgress.setVisible(true);
        
        conf.setFilePath(file.getAbsolutePath());

        //final String spectrumFolder = this.spectrumField.getText();
        //final String configFile = this.configField.getText();
        //final String dtaFile = this.idFileField.getText();        
       
        
        
        for(int i=0;i<fList.length;i++)
        {            
            System.out.println(fList[i]);
            
        }                
        
        
        Thread t = new Thread()
        {
            boolean isSuccessful = false;
            
            public void run()
            {   
                try {
        //            conf = Configuration.getInstance();
          //          conf.setStartTime();
            //        conf.setFilePath(spectrumFolder);
              //      conf.readXMLParam(configFile); 
                //    conf.setDtaSelectFile(dtaFile);  
                  //  conf.setLabeling(true);
        
                    ChroGenerator chro = new ChroGenerator(chroProgress);         
        
                    chroProgress.addMessageWithLine("Census starts to analyze data...");
                    chro.createMRMFragmentIons(chroProgress);
                    /*
                    switch(conf.getQuantLevel())
                    {
                        case 1: //Full
                            chro.createFullscanXmlChro();
                            break;

                        case 2: //MSMS
                            chro.createMsmsXmlChro(chroProgress);
                            break;

                        default :
                            break;
                    }                    
                    */
                    //if( isFull.equals("f") ) //Full Scan
                    //    chro.createFullscanXmlChro();
                    //else //msms scan
                    //    chro.createMsmsXmlChro();

                    isSuccessful = true;
                }catch(IOException e) {
                    e.printStackTrace();                    
                    
                }catch(Exception e) {
                    e.printStackTrace();
                    //JOptionPane.showMessageDialog(this, "Failed to generate a chro file: " + e, "Failed to generate a chro file", JOptionPane.ERROR_MESSAGE);                                        
                }
                
                
                SwingUtilities.invokeLater(new Runnable()
                {
                    public void run()
                    {
                        chroProgress.setVisible(false);
                        chroProgress.hide();

                        if(isSuccessful)
                        {
                            
                            openMRMCrvFile(conf.getFilePath() + "mrm_frags.xml");
        
                        }
                    }
                 });
            }
        };

        try {
            t.start();
            
            if(null != conf.getErrorMessage())
                throw new Exception();
            
        } catch(Exception e)
        {
            t = null;
            JOptionPane.showMessageDialog(this, "Failed to generate a chro file: " + e, "Failed to generate a chro file", JOptionPane.ERROR_MESSAGE);                    
                        //chroProgress.setVisible(false);
        }
                          
    }//GEN-LAST:event_mrmCsvActionPerformed


                
    private void nonlabelTableKeyPressed(java.awt.event.KeyEvent evt) {
        
                
        //JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file", JOptionPane.ERROR_MESSAGE);
    }
    


    private void nonlabelTableMouseClicked(java.awt.event.MouseEvent evt) {
        
        System.out.println("single clicked");
        
        JTable table = (JTable)evt.getSource();
            
        generateNonLabelData(currentPeptide, table.getSelectedRow());
        
        //JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file", JOptionPane.ERROR_MESSAGE);
    }
    
                
    private void peptideListTableKeyPressed(java.awt.event.KeyEvent evt) {
// TODO add your handling code here:
        
        if(evt.getKeyCode() != KeyEvent.VK_DOWN && evt.getKeyCode() != KeyEvent.VK_UP)
            return;
        
        int pepSize = currentProtein.getPeptideList().size();
        
        JTable table = (JTable)evt.getSource();
        
        //ChroPeptide peptide=null;
        
        if( evt.getKeyCode() == KeyEvent.VK_DOWN ) {
            if( table.getSelectedRow()+1 >= pepSize )
                return;
            
            this.currentPeptide = (ChroPeptide)currentProtein.getPeptideList().get( table.getSelectedRow()+1 );
        } else if( evt.getKeyCode() == KeyEvent.VK_UP ) {
            if( table.getSelectedRow() <=0 )
                return;
            
            this.currentPeptide = (ChroPeptide)currentProtein.getPeptideList().get( table.getSelectedRow()-1 );
        }
        
        
        //if(null==peptide) return;
        
        /*
        PostOptions options = PostOptions.getInstance();
        
        if(!this.labeled && this.quantLevel==1)
            generateNonLabelData(currentPeptide);
        else if(this.isDataDependent)
            generateDepData(this.currentPeptide);
        else if(options.isFilterFragmentIons())
            generateInDepFragData(this.currentPeptide);
        else
            generateInDepData(this.currentPeptide);
        */
        
        selectQuantType();
    }

    private void selectQuantType()
    {
        PostOptions options = PostOptions.getInstance();
        
	//need to change it more logically.  This happened as we add more and more features.
        if(!this.labeled)
        {
            //if( this.quantLevel==1 )
            generateNonLabelData(currentPeptide);        
            //else if(this.quantLevel==2 )
              //  generateNonLabelData(currentPeptide);        
        }        
        //else if(this.isDataDependent)
        else if(this.quantLevel==1)
            generateDepData(this.currentPeptide);
        else if(options.isFilterFragmentIons())
            generateInDepFragData(this.currentPeptide);
        else
            generateInDepData(this.currentPeptide);
    }
    
    private void peptideListTableMouseClicked(java.awt.event.MouseEvent evt) {
// TODO add your handling code here:
        System.out.println("single click on peptide table");
        
        if (this.isChroFile) {
            JTable table = (JTable)evt.getSource();
            
            ChroPeptide peptide = (ChroPeptide)currentProtein.getPeptideList().get( table.getSelectedRow() );
            this.currentPeptide = peptide;
            
            selectQuantType();
            /*
            PostOptions options = PostOptions.getInstance();
            
            if(!this.labeled && this.quantLevel==1)
                generateNonLabelData(currentPeptide);
            else if(this.isDataDependent)
                generateDepData(peptide);
            else if(options.isFilterFragmentIons())
                generateInDepFragData(peptide);
            else
                generateInDepData(peptide);        
            */
        }
    }
    
    private void searchFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_searchFieldActionPerformed
// TODO add your handling code here:
    }//GEN-LAST:event_searchFieldActionPerformed

    public void runtest()
    {
        this.runNonLabelActionPerformed(null);
    }

    /*
    public static void runsimpletest() {                                            
        
        //for testing
        final File file = new File("/home/rpark/001/census_config16.xml");                
        //end of testing

        
        try
        {
	    SAXBuilder sb = new SAXBuilder();
	    Document doc = sb.build(file);
	    final Element root = doc.getRootElement();            

	    Thread t = new Thread() {
		public void run() {

		    try {
                        
                        //reads conf. file
                        Configuration conf = Configuration.getInstance();
                        conf.readXMLParam(file.getParent() +  file.getName());

                        //System.out.println(conf.isHighRes() + " " + conf.getMassTolerance());

			List sampleList = root.getChildren("sample");
                        
                        //Configuration.
                        String refSamName = root.getChild("ref").getChildText("sample_name");
			String refFileName = root.getChild("ref").getChildText("file_name");
                        
                        conf.setRefFileName(refFileName);
                        
			

			int index=0;
			int refIndex=0;

			Vector<String> fileNameList = new Vector<String>();
			Vector<String> sampleNameList = new Vector<String>();
                        Vector<String> pathFileNameList = new Vector<String>();
                        
                        
                        //confSam.setRefFileName(refFileName);
//                        Hashtable<String, Hashtable> masterHt = new Hashtable<String, Hashtable>();
                        HashSet set = new HashSet();
                        
			for(Iterator<Element> itr = sampleList.iterator(); itr.hasNext(); )
			{
			    Element sam = itr.next();
			    String samName = sam.getChildText("name");

                            //populate configuration class
                            Configuration.Sample confSam = new Configuration.Sample();
                            confSam.setName(samName);
                            
                            
			    List fileList = sam.getChild("ms_files").getChildren("file");
                            
			    for(Iterator<Element> itr1 = fileList.iterator(); itr1.hasNext(); )
			    {
                                
				Element eachFile = itr1.next();
				String fileName = eachFile.getText();                    
//                                masterHt.put(fileName, new Hashtable());
                                
                                confSam.addFile(fileName);
                                pathFileNameList.add(fileName);
                                
                                set.add(fileName.substring(0, fileName.lastIndexOf("/")));
                                

				fileNameList.add(fileName);
				sampleNameList.add(samName);
                                
                                if( refFileName.equals(fileName) )
				    refIndex = index;
                                
                                index++;
			    }
                            
                            conf.addExp(confSam);                            
			}

                        
			long start = System.currentTimeMillis();			
                        
                        System.out.println("run simple test..");
			chroalign align = new chroalign();       
                        javax.swing.JProgressBar aJProgressBar = new javax.swing.JProgressBar();
                        //align.alignChro(aJProgressBar, fileNameList.toArray(), sampleNameList.toArray(), refIndex, false, 500);

                        
                        if(true)
                            System.exit(0);
                        
                        


			int[][][] pathArray = null;
                        
                        
                        int size=0;
                        int tmpSize=0;
                        for(Iterator<Element> itr = sampleList.iterator(); itr.hasNext(); )
			{
			    Element sam = itr.next();
                            
			    List fileList = sam.getChild("ms_files").getChildren("file");
                            
			    for(Iterator<Element> itr1 = fileList.iterator(); itr1.hasNext(); )
			    {
				Element eachFile = itr1.next();
				String fileName = eachFile.getText();                    
                                                                
                                SpectrumReader sReader = new SpectrumReader(fileName, "ms1");
                                tmpSize = sReader.getNumSpectra();
                            
                                if(tmpSize>size)
                                    size = tmpSize;
                            
                            }
			
			}
                        
                        size += 2; // add margin

                        System.out.println("size" + size);
                        
                        
                        
                        SAXBuilder builder = new SAXBuilder();
                        Document doc = builder.build( new File("/home/rpark/path_out.xml") );
                        Element rootEle = doc.getRootElement();
                        List l = rootEle.getChildren("dataset");
                        
                        int firstInd=0;
                        //int secondInd=0;
                        int thirdInd=0;
                        
                        
                        //pathArray = new int[fileNameList.size()-1][2][2*size];
                        
                        int tmp1=0;
                        for(Iterator<Element> itr=l.iterator(); itr.hasNext(); )
                        {
                            Element e = itr.next();
                            
                            if(tmp1<e.getChildren().size())
                                tmp1 = e.getChildren().size();
                        }
                        
                        
                        pathArray = new int[fileNameList.size()-1][2][2*tmp1];
                        
                        for(Iterator<Element> itr=l.iterator(); itr.hasNext(); )
                        {
                            Element e = itr.next();
                            
                            
                            
                            //ArrayList aList = new ArrayList();
                            
                            //System.out.println("==>>" + e.getChildren().size());
                            
                            for(Iterator<Element> itr1=e.getChildren("p").iterator(); itr1.hasNext(); )
                            {
                                Element pEle = itr1.next();
                                
                                
                                pathArray[firstInd][0][thirdInd] = Integer.parseInt( pEle.getAttributeValue("x") );
                                pathArray[firstInd][1][thirdInd] = Integer.parseInt( pEle.getAttributeValue("y") );

                                
                                
                                
                                thirdInd++;
                            }
                            
                            ///masterHt.put(fileName, null);
                                                            
                            firstInd++;
                        }

                        //System.out.println(pathArray.length);
                        //System.out.println(pathFileNameList);

                                
                        
                        NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);
                        
                        conf.setMapModel(mapModel);
                        
 
   
                        

                        String[] targetMS1Files = align.getTargetMS1Files();
                        String referenceMS1File = align.getReferenceMS1File();

                        conf.setNonlabelFilePaths(set);
                        //conf.setPathFileNameList(pathFileNameList);
                        
                        
                
                        ChroGenerator chro = new ChroGenerator(
                                //aJProgressBar,
                                null,
                                null,
                                referenceMS1File,
                                targetMS1Files,
                                root,
                                pathArray
                                //isotopeFileField.getText().trim(),                                
                                );
                        
                        chro.createNonlabelXmlChro();
                        


		    } catch (Exception e)
		    {
			System.out.println("error " + e);
			e.printStackTrace();
		    }

		    SwingUtilities.invokeLater(new Runnable() {
			    public void run() {
			    //progress.setVisible(false);  
                            
                            if(true)
                                System.exit(0);
			    }
			    });
		}
	    };

	    t.start();   
            
                        
                        
                

	
            
        } catch(Exception ex)
        {
        }
    }                                           

    */
    
    //private void runNonLabelActionPerformed(java.awt.event.ActionEvent evt) {                                            
    public void runNonLabelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runNonLabelActionPerformed
// TODO add your handling code here:
        //comment out for testing.

        JFileChooser choose = new JFileChooser();
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Select config file");
        choose.setApproveButtonText("Select");
       	
        if(this.currentDirectory != null)
            choose.setCurrentDirectory( new File(this.getCurrentDirectory()) );
                
        int returnVal = choose.showOpenDialog(this);        

        if(returnVal == choose.CANCEL_OPTION)
            return;
                
        final File file = choose.getSelectedFile();
        final String workFolder = file.getParent();
       
        
        final ChroProgressDialog chroProgress = new ChroProgressDialog(this, false);
        chroProgress.setLocationRelativeTo(this);
        chroProgress.setResizable(false);        
        chroProgress.setVisible(true);


       // final RelExMainFrame mFrame = this; 
        
//        for testing
//        final File file = new File("/home/rpark/001/nonlabel/IsotopeFree/census_config.xml");                
  //      end of testing
        
        try
        {

	    SAXBuilder sb = new SAXBuilder();
	    Document doc = sb.build(file);
	    final Element root = doc.getRootElement();            

//commented out for testing
	    final JFrame mFrame = this; 
	    Thread t = new Thread() {
                private boolean isSuccessful=true;

		public void run() {

		    try {
                        
                        //reads conf. file
                        Configuration conf = Configuration.getInstance();
                        //conf.setTextArea(chroProgress.getProgressText());                        
                        String parentPath = file.getParent();
                        
                        conf.readXMLParam(parentPath + File.separator + file.getName());
                        conf.setFilePath(parentPath);
                        
//                        System.out.println(conf.isHighRes() + " " + conf.getMassTolerance());

			List sampleList = root.getChildren("sample");
                        
                        //Configuration.
                        String refFileName = "";
                        Element refEle = root.getChild("ref");
                        if(null != refEle)
                        {
                            //String refSamName = refEle.getChildText("sample_name");
                            refFileName = refEle.getChildText("file_name");

                            conf.setRefFileName(refFileName);
                        }
                        			

			int index=0;
			int refIndex=0;

			Vector<String> fileNameList = new Vector<String>();
			Vector<String> sampleNameList = new Vector<String>();
                        Vector<String> pathFileNameList = new Vector<String>();
                        
                        
                        //confSam.setRefFileName(refFileName);
                        //Hashtable<String, Hashtable> masterHt = new Hashtable<String, Hashtable>();
                        HashSet set = new HashSet();
                        
			for(Iterator<Element> itr = sampleList.iterator(); itr.hasNext(); )
			{
			    Element sam = itr.next();
			    String samName = sam.getChildText("name");

                            //populate configuration class
                            Configuration.Sample confSam = new Configuration.Sample();
                            confSam.setName(samName);
                            
                            
			    List fileList = sam.getChild("ms_files").getChildren("file");
                            
			    for(Iterator<Element> itr1 = fileList.iterator(); itr1.hasNext(); )
			    {
                                
				Element eachFile = itr1.next();
				String fileName = eachFile.getText();                    
                          //      masterHt.put(fileName, new Hashtable());
                                
                                confSam.addFile(fileName);
                                pathFileNameList.add(fileName);
                                
                                set.add(fileName.substring(0, fileName.lastIndexOf("/")));
                                
                                if(fileName.endsWith("ms2"))
                                {
                                    fileName = fileName.substring(0, fileName.length()-3);
                                    fileName += "ms1";
                                    
                                }
                       
				File tmpFile = new File(fileName);
				if(!tmpFile.exists())
				{
				    isSuccessful = false;
				    throw new FileNotFoundException(fileName + " file not found ");
				}
				    


				
				fileNameList.add(fileName);                                
				sampleNameList.add(samName);
                                
                                if( null != refEle && refFileName.equals(fileName) )
                                    refIndex = index;

                                
                                index++;
			    }
                            
                            conf.addExp(confSam);                            
			}

                        
			long start = System.currentTimeMillis();			
			chroalign align = new chroalign();       


			int[][][] pathArray = null;
                        
                        boolean isAlign = conf.isAlign();                        
                                                
                        chroProgress.setProgress(1);


                        File alignFile = new File(workFolder + "/aligned_out.xml");
                        File pathoutFile = new File(workFolder + "/path_out.xml");
                        File chrooutFile = new File(workFolder + "/chro_out.xml");
                        
                        int selection = -1;
                        if(alignFile.exists() && pathoutFile.exists() && chrooutFile.exists() )
                        {
                            Object[] options = {"Yes", "No"};
                             
                            selection = JOptionPane.showOptionDialog(mFrame, 
                                    "Alignment out files are found.  Do you want to read them?", 
                                    "Alignment out files found", 
                                    JOptionPane.YES_NO_OPTION, 
                                    JOptionPane.QUESTION_MESSAGE, 
                                    null,
                                    options,
                                    options[0]
                                    );                            
                        }
                
                        if(selection != 0) //align
                        {
			    chroProgress.addMessageWithLine("Start aligning spectra...");
			    if(isAlign) //align based on chromatogram profile
			    {
				//pathArray = align.alignChro(chroProgress.getProgressBar(), fileNameList.toArray(), sampleNameList.toArray(), refIndex, false, 500, file.getParent());
				pathArray = align.alignChro(chroProgress, fileNameList.toArray(), sampleNameList.toArray(), refIndex, false, 500, file.getParent());

				chroProgress.addMessageWithLine("Populating mapping model...");
				NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);                        
				conf.setMapModel(mapModel);                        
			    }
			    else //align based on retention time
			    {
				pathArray = align.noAlignChro(chroProgress, fileNameList.toArray(), sampleNameList.toArray(), file.getParent());                            
				chroProgress.addMessageWithLine("Populating mapping model...");
				NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);
				mapModel.reinitializeMaxIndexByRet(); //this method is called only for the aligning by retention time.  Not nice idea.
				conf.setMapModel(mapModel);
			    }
			    chroProgress.addMessageWithLine("Spectra alignment done.");
/*
for(int ii=0;ii<pathArray.length;ii++)
{
    
    //for(int jj=0;jj<pathArray[ii][0].length;jj++)
    for(int jj=0;jj<3;jj++)
	System.out.println( pathArray[ii][0][jj] + "\t" + pathArray[ii][1][jj]);

    System.out.println("--");
}
*/
			}
			else //already aligned
			{
			    chroProgress.addMessageWithLine("Reading pre-aligned xml file...");

			    SAXBuilder builder = new SAXBuilder();
			    Document doc = builder.build( pathoutFile );
			    Element rootEle = doc.getRootElement();

			    int numberOfAlignment = 1;  //number of alignment is one bigger than actual alignment number :-(
			    int biggestNum=0;

			    for(Iterator<Element> itr=rootEle.getChildren("dataset").iterator(); itr.hasNext(); )
			    {
				Element ele = itr.next();

				if(biggestNum< ele.getChildren().size())
				    biggestNum = ele.getChildren().size();
				numberOfAlignment++;
			    }

			    pathArray = new int[numberOfAlignment][2][biggestNum+1];

			    int firstIndex=0;

			    for(Iterator<Element> itr=rootEle.getChildren("dataset").iterator(); itr.hasNext(); )
			    {
				Element ele = itr.next();
			    
				int thirdIndex=0;
				for(Iterator<Element> pitr = ele.getChildren("p").iterator(); pitr.hasNext(); )
				{
				    Element pele = pitr.next();

				    pathArray[firstIndex][0][thirdIndex] = Integer.parseInt(pele.getAttributeValue("x"));
				    pathArray[firstIndex][1][thirdIndex] = Integer.parseInt(pele.getAttributeValue("y"));
//System.out.println( pathArray[firstIndex][0][thirdIndex]  + "\t" + pathArray[firstIndex][1][thirdIndex] );
				    thirdIndex++;
				}

				firstIndex++;
			    }

			    /*
for(int ii=0;ii<pathArray.length;ii++)
{
    
    //for(int jj=0;jj<pathArray[ii][0].length;jj++)
    for(int jj=0;jj<3;jj++)
	System.out.println( pathArray[ii][0][jj] + "\t" + pathArray[ii][1][jj]);

    System.out.println("--");
}
*/
			    chroProgress.addMessageWithLine("Populating mapping model...");
			    
			    NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);                        
			    conf.setMapModel(mapModel);                        

			    chroProgress.addMessageWithLine("Pre-alignment file loading done.");

/*
			    if(isAlign) //align based on chromatogram profile
			    {
				pathArray = align.alignChro(chroProgress, fileNameList.toArray(), sampleNameList.toArray(), refIndex, false, 500, file.getParent());

				NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);                        
				conf.setMapModel(mapModel);                        
			    }
			    else //align based on retention time
			    {
				pathArray = align.noAlignChro(chroProgress, fileNameList.toArray(), sampleNameList.toArray(), file.getParent());                            
				NonLabelMappingModel mapModel = new NonLabelMappingModel(pathArray, pathFileNameList, refIndex);
				mapModel.reinitializeMaxIndexByRet(); //this method is called only for the aligning by retention time.  Not nice idea.
				conf.setMapModel(mapModel);
			    }
*/
			}
			
                     
                        String[] targetMS1Files = align.getTargetMS1Files();
                        String referenceMS1File = align.getReferenceMS1File();

                        conf.setNonlabelFilePaths(set);
                                        
                        chroProgress.addMessageWithLine("Reading Spectra and Running Quantification...");
                        
                        ChroGenerator chro = new ChroGenerator(
                                //aJProgressBar, //commented out for testing
                                chroProgress, //.getProgressBar(),
                                //null,
                                null,
                                referenceMS1File,
                                targetMS1Files,
                                root,
                                pathArray
                                //isotopeFileField.getText().trim(),                                
                                );
                        
                        
                        //if( 1 == conf.getQuantLevel() )
                            chro.createNonlabelXmlChro();
                        //else if( 2 == conf.getQuantLevel() )
                        //    chro.createNonlabelMsmsXmlChro();

		    } catch (FileNotFoundException e)
		    {
			JOptionPane.showMessageDialog(chroProgress, "Error : " + e.getMessage(), "Error ", JOptionPane.ERROR_MESSAGE);
			e.printStackTrace();
			
		    } catch (Exception e)
		    {
			JOptionPane.showMessageDialog(chroProgress, "Error : " + e.getMessage(), "Error ", JOptionPane.ERROR_MESSAGE);
			e.printStackTrace();
		    }

		    SwingUtilities.invokeLater(new Runnable() {
			    public void run() {
			    //progress.setVisible(false);
			    System.out.println("done....");
                                chroProgress.setVisible(false);
                                chroProgress.hide();
                                
				if(!isSuccessful)
				    return;
				    
                                openChroFile(file.getParent() + File.separator + "census_chro.xml");
                     
			    }
			    });
		}
	    };

	    t.start();                                
            
        } catch(JDOMException ex)
        {

            JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file" + ex, JOptionPane.ERROR_MESSAGE);
            chroProgress.addMessageWithLine("Error reading the config file" + ex);
            System.out.println("Error " + ex);
        } catch(IOException ex)
        {

            JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file" + ex.toString(), JOptionPane.ERROR_MESSAGE);
            chroProgress.addMessageWithLine("Error reading the config file" + ex);
            System.out.println("Error " + ex);
        } catch(Exception e)
        {
            JOptionPane.showMessageDialog(this, "Error reading the config file.", "Error reading the config file" + e.toString(), JOptionPane.ERROR_MESSAGE);
            chroProgress.addMessageWithLine("Error reading the config file" + e);
            System.out.println("Error " + e);
        }
        
    }//GEN-LAST:event_runNonLabelActionPerformed

    private void openSpectraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openSpectraActionPerformed
// TODO add your handling code here:
        
        //Configuration conf = Configuration.getInstance();
        //conf.setSimpleIndexGenerator(true);
        
        JFileChooser choose = new JFileChooser();
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Select Spectra File");
        //choose.addChoosableFileFilter( new SimpleFileNameFilter("xml", "Chro File") );

        if(currentDirectory != null && !"".equals(currentDirectory))
	    choose.setCurrentDirectory(new File(currentDirectory));

        int returnVal = choose.showOpenDialog(chroPanel);
        this.specFile = choose.getSelectedFile();

        if(null==specFile || returnVal == choose.CANCEL_OPTION)
            return;
       
        currentDirectory = specFile.getAbsolutePath();
        currentDirectory = currentDirectory.substring(0, currentDirectory.lastIndexOf(File.separator));        

        filePathLabel.setText(specFile.getAbsolutePath());
                
        cleanupProteinTableModel();
        
        this.openSpecFile(specFile.getAbsolutePath());

    }//GEN-LAST:event_openSpectraActionPerformed

    private void searchBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_searchBtnActionPerformed
// TODO add your handling code here:
        
        int rows = this.proteinTable.getRowCount();
        int columns = this.proteinTable.getColumnCount();

        Object value = null;
        String searchText = this.searchField.getText().trim();

        
        this.searchIndex = (this.searchIndex>=rows)?0:this.searchIndex;
        
        for(int i=this.searchIndex; i<rows; i++)
        {            
            value = this.proteinTableModel.getValueAt(i,0);
            
            if( null != value && value.toString().contains(searchText) )
            {
                this.proteinTable.setRowSelectionInterval(i,i);
                this.searchIndex = (this.searchIndex>=rows)?0:i+1;
                this.proteinTable.scrollRectToVisible(this.proteinTable.getCellRect(i,0,true));

                return;                
            }
              
            value = this.proteinTableModel.getValueAt(i,columns-1);
            
            if( null != value && value.toString().contains(searchText) )
            {
                this.proteinTable.setRowSelectionInterval(i,i);
                this.searchIndex = (this.searchIndex>=rows)?0:i+1;
                this.proteinTable.scrollRectToVisible(this.proteinTable.getCellRect(i,0,true));
            //    this.proteinTable.setColumnSelectionInterval(0,0);
                return;                
            }
        }            
        
        if(this.searchIndex!=0)
        {
            for(int i=0; i<this.searchIndex; i++)
            {            
                value = this.proteinTableModel.getValueAt(i,0);

                if( null != value && value.toString().contains(searchText) )
                {
                    this.proteinTable.setRowSelectionInterval(i,i);
                    this.searchIndex = (this.searchIndex>=rows)?0:i+1;
                    this.proteinTable.scrollRectToVisible(this.proteinTable.getCellRect(i,0,true));
                //    this.proteinTable.setColumnSelectionInterval(0,0);
                    return;                
                }

                value = this.proteinTableModel.getValueAt(i,columns-1);

                if( null != value && value.toString().contains(searchText) )
                {
                    this.proteinTable.setRowSelectionInterval(i,i);
                    this.searchIndex = (this.searchIndex>=rows)?0:i+1;
                    this.proteinTable.scrollRectToVisible(this.proteinTable.getCellRect(i,0,true));
                //    this.proteinTable.setColumnSelectionInterval(0,0);
                    return;                
                }
            }
        }
        
        JOptionPane.showMessageDialog(this, "No protein was found.", "No protein was found.", JOptionPane.ERROR_MESSAGE);
    }//GEN-LAST:event_searchBtnActionPerformed

    public void openSpecFile(final String specFile)
    {
        this.specFile = new File(specFile);
        this.isChroFile = false;
        
        try
        {
            this.welcomeLabel.setVisible(false);
            this.tabbedPanel.setVisible(true);

            final JDialog progress = new JDialog(this);
            JProgressBar aJProgressBar = new JProgressBar(0, 100);
            aJProgressBar.setIndeterminate(true);
            Container cp = progress.getContentPane();
            JLabel jb = new JLabel("Opening DTASelect-filter.out file...",
                  SwingConstants.CENTER);
            cp.add(jb, BorderLayout.SOUTH);
            cp.add(aJProgressBar, BorderLayout.NORTH);
            progress.setSize(500, 100);
            progress.setLocationRelativeTo(this);
            progress.pack();

            progress.setResizable(false);
            progress.setVisible(true);
  
            this.tabbedPanel.remove(this.peptidePanel);            
            
            tabbedPanel.addTab("Peptides", qualPanel);
            
            final String tempDir = this.currentDirectory;
            
            final JFrame mFrame = this;
            Thread t = new Thread() {
                public void run() {

                    try {

                        dtaReader = new DTASelectFilterReader(specFile);
                        File f = new File(specFile);
                        Configuration conf = Configuration.getInstance();
                        conf.setSimpleIndexGenerator(true);
                                
                        ht = ChroGenerator.createIndexedFiles( f.getParent() + File.separator, "ms2");

                        //qualPanel = new QualificationPanel(mFrame, tempDir, ht);
                        qualPanel.setMFrame(mFrame);
                        qualPanel.setCurrentDirectory(tempDir);
                        qualPanel.setHt(ht);
                                  
                        list = dtaReader.getChroProteinList();                                            
                            
                        Object[] simpleProteinArr = new Object[1];
                        
                        for(Iterator<ChroProtein> itr = list.iterator(); itr.hasNext(); )
                        {
                            ChroProtein protein = itr.next();
                            proteinTableModel.addRow(protein.getProteinData());
                            
                            simpleProteinArr[0] = protein.getLocus();
                            
                            proteinSimpleTableModel.addRow( simpleProteinArr );
                        }                                                    

                        tabbedPanel.setSelectedIndex(0);
                        tabbedPanel.setEnabledAt(0, true);
                        
                        
                        //irisPanel = new IrisPanel(ht, this.currentPeptide);
                        
                        //this.peptidePanel.invalidate();
                        //this.peptidePanel.validate();
                        //this.peptidePanel.repaint();
         
                       
                        
                    //} catch (IOException e)
                    } catch (Exception e)
                    {
                      System.out.println("error " + e);
                      e.printStackTrace();
                    }

                    SwingUtilities.invokeLater(new Runnable() {
                          public void run() {
                            progress.setVisible(false);                              
                            progress.hide();
                          }
                    });
                }
            };

            t.start();                                
            
        }
        /*
        catch(IOException ioe)
        {
            JOptionPane.showMessageDialog(proteinListPanel, "Failed to open a chro file: " + ioe, "Failed to open a chro file", JOptionPane.ERROR_MESSAGE);
            ioe.printStackTrace();
        }
        catch(JDOMException je)
        {
            JOptionPane.showMessageDialog(proteinListPanel, "Failed to open a chro file: " + je, "Failed to open a chro file", JOptionPane.ERROR_MESSAGE);
            je.printStackTrace();
        } */       
        catch(Exception je)
        {
            JOptionPane.showMessageDialog(proteinListPanel, "Failed to open a chro file: " + je, "Failed to open a chro file", JOptionPane.ERROR_MESSAGE);
            je.printStackTrace();
        }
        
    }
    
    
    public void openMRMCrvFile(String chroFile)
    {

        String filePath = conf.getFilePath();
        File mrmChroFile = new File(filePath);
        if(!mrmChroFile.exists())
        {
            JOptionPane.showMessageDialog(this, "MRM Chro file was not generated", "Failed to generate a chro file", JOptionPane.ERROR_MESSAGE);                                                                                                        
            return;
        }

        try
        {
            this.welcomeLabel.setVisible(false);
            
            MRMFragPanel mrmPanel = new MRMFragPanel(chroFile);
            
            //pack();
            //this.setVisible((true);
            
            //this.mainPanel.add(mrmPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 50, 1417, 868));
        
            //mainPanel.add(welcomeLabel, java.awt.BorderLayout.CENTER);
        
            mainPanel.add(mrmPanel, BorderLayout.CENTER);
        
            //mainPanel.add(welcomeLabel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 50, 1417, 868));
            
            //this.getContentPane().add(mrmPanel);
            /*
            org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
            getContentPane().setLayout(layout);
                layout.setHorizontalGroup(
                    layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jToolBar1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1417, Short.MAX_VALUE)
                    .add(layout.createSequentialGroup()
                        .addContainerGap()
                        .add(welcomeLabel)
                        .addContainerGap(905, Short.MAX_VALUE))
                    .add(layout.createSequentialGroup()
                        .add(mrmPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 1403, Short.MAX_VALUE)
                        .addContainerGap(14, Short.MAX_VALUE))
            );
            layout.setVerticalGroup(
                layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(layout.createSequentialGroup()
                    .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                        .add(layout.createSequentialGroup()
                            .add(jToolBar1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(30, 30, 30)
                            .add(welcomeLabel))
                        .add(layout.createSequentialGroup()
                            .add(25, 25, 25)
                            .add(mrmPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 831, Short.MAX_VALUE)))
                    .addContainerGap())
            );
             */
            
        }
        catch (Exception e)
        {
            e.printStackTrace();
           JOptionPane.showMessageDialog(this, "Failed to open MRM Chro file" + e, "Failed to open MRM Chro file", JOptionPane.ERROR_MESSAGE);
           
        }            
    }
    
    public void openChroFile(String chroFile)
    {
        this.isChroFile = true;        
        this.chroFile = new File(chroFile);
                
        try
        {
	System.out.println(chroFile);
            cr = new ChroXmlReader(chroFile);                
            
            this.welcomeLabel.setVisible(false);
            this.tabbedPanel.setVisible(true);
            
            this.isDataDependent = cr.isDataDependent();
            this.quantLevel = cr.getQuantLevel();
            this.labeled = cr.isLabeled();
                            
            if( !this.labeled )
            {     
                
                if(cr.getQuantLevel() == 1)
                    this.fragIonScrollPanel.setVisible(false);
                else
                    this.fragIonScrollPanel.setVisible(true);
                    
                
                this.correlationPanel.setVisible(false);
                //this.paramPanel.setVisible(false);
                this.paramPanel.removeAll();
                
                nonLabelPanel.setBackground(new java.awt.Color(255, 255, 255));
                nonLabelPanel.setLayout(new BorderLayout());                
                nonLabelPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "All", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 0, 11), java.awt.Color.black));
                //quanPanel.add(nonLabelPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(710, 190, 580, 300));                
                nonlabelTable.setModel(nonlabelTableModel);
                
                //add action to the table
                nonlabelTable.addKeyListener(new java.awt.event.KeyAdapter() {
                    public void keyPressed(java.awt.event.KeyEvent evt) {
                        nonlabelTableKeyPressed(evt);
                    }
                });
                
                nonlabelTable.addMouseListener(new java.awt.event.MouseAdapter() {
                    public void mouseClicked(java.awt.event.MouseEvent evt) {
                        nonlabelTableMouseClicked(evt);
                    }
                });        
                
                nonlabelScrollPane.setViewportView(nonlabelTable);
                
                nonLabelPanel.add(nonlabelScrollPane);        
                nonLabelPanel.setMinimumSize(new Dimension(10,10));                
                nonLabelPanel.setMaximumSize(new Dimension(1000,1000));
                
                this.nonLabelSummaryPanel.setBackground(new java.awt.Color(255, 255, 255));
                this.nonLabelSummaryPanel.setLayout(new BorderLayout());                
                this.nonLabelSummaryPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Summary", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 0, 11), java.awt.Color.black));
                //quanPanel.add(nonLabelSummaryPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(710, 490, 580, 300));                
                
                nonlabelSummaryTable.setModel(nonlabelSummaryTableModel);
                nonlabelSummaryScrollPane.setViewportView(nonlabelSummaryTable);                
                nonLabelSummaryPanel.add(nonlabelSummaryScrollPane);        
                nonLabelSummaryPanel.setMinimumSize(new Dimension(10,10));
                nonLabelSummaryPanel.setMaximumSize(new Dimension(1000,1000));
                
                this.paramPanel.setLayout(new BorderLayout());
                
                this.paramPanel.add(this.nonLabelPanel, BorderLayout.NORTH);
                this.paramPanel.add(this.nonLabelSummaryPanel, BorderLayout.CENTER);
                
            }
            
            this.plot = new ChromatographPlot(this);
            this.pepDistPlot = new PeptideDistPlot(this);

            final JDialog progress = new JDialog(this);
            final String tempFolder = this.currentDirectory + File.separator;

            JProgressBar aJProgressBar = new JProgressBar(0, 100);
            aJProgressBar.setIndeterminate(true);
            Container cp = progress.getContentPane();
            JLabel jb = new JLabel("Opening chro file...",
                  SwingConstants.CENTER);
            cp.add(jb, BorderLayout.SOUTH);
            cp.add(aJProgressBar, BorderLayout.NORTH);
            progress.setSize(500, 100);
            progress.setLocationRelativeTo(this);
            progress.pack();

            progress.setResizable(false);
            progress.setVisible(true);

            Thread t = new Thread() {
                public void run() {
		
                    try {
                        plot.setBackground(new Color(255, 255, 255));  
                        pepDistPlot.setBackground(new Color(255, 255, 255));  
                        
                        chromatogramPanel.add(plot);
                        proteinRatioDistPanel.add(pepDistPlot);                        

                        chroXmlParser = new ChroXMLParser((Plot)plot);  
                        peptideDistParser = new PlotMLParser((Plot)pepDistPlot);

                        list = cr.getProteinList();

                        Object[] simpleProteinArr = new Object[2];                        
                        for(Iterator<ChroProtein> itr = list.iterator(); itr.hasNext(); )
                        {
                            ChroProtein protein = itr.next();
                            proteinTableModel.addRow(protein.getProteinData());
                            
                            simpleProteinArr[0] = protein.getLocus();
                            simpleProteinArr[1] = protein.getDescription();
                            
                            proteinSimpleTableModel.addRow( simpleProteinArr );
                        }

                        //tabbedPanel.setSelectedIndex(1);
                        //tabbedPanel.setEnabledAt(1, true);
                    } catch (IOException e)
                    {
                      System.out.println("error " + e);
                    }

                    SwingUtilities.invokeLater(new Runnable() {
                          public void run() {
                            progress.setVisible(false);                              
			    progress.hide();
                            
                            chroFileOpen = true;
                            reportItem.setEnabled(true);
                          }
                    });
                }
            };

            t.start();                                
        }
        catch(IOException ioe)
        {
            JOptionPane.showMessageDialog(proteinListPanel, "Failed to open a chro file: " + ioe, "Failed to open a chro file", JOptionPane.ERROR_MESSAGE);
            ioe.printStackTrace();
        }
        catch(JDOMException je)
        {
            JOptionPane.showMessageDialog(proteinListPanel, "Format of chro xml file is incorrect.", "Failed to open a chro file", JOptionPane.ERROR_MESSAGE);
            je.printStackTrace();
        }

        this.reportItem.setEnabled(true);
    }
    
    private void runItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_runItemActionPerformed
// TODO add your handling code here:
        OpenConfigDialog dialog = new OpenConfigDialog(this,true);
        dialog.pack();
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);
        dialog.setResizable(false);
            
    }//GEN-LAST:event_runItemActionPerformed

    private void confItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_confItemActionPerformed
	// TODO add your handling code here:
        SelectConfDialog dialog = new SelectConfDialog(this,true);                  
        dialog.pack();
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);
        dialog.setResizable(false);

    }//GEN-LAST:event_confItemActionPerformed

    private void mergeItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mergeItemActionPerformed
    // TODO add your handling code here:
        
        MergeDialog dialog = new MergeDialog(this,true);
        dialog.pack();
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);
        dialog.setResizable(false);

    }//GEN-LAST:event_mergeItemActionPerformed

    /*
    public void mergeFiles(
            final Object[] arr, 
            final File outputFile, 
            final String dbFilePath, 
            final boolean detSelect, 
            final double detValue,
            final boolean pValueSelect,
            final double pValue,
            final boolean filterFragmentIons
            )
     */
    
    public void mergeFiles(
            final Object[] arr, 
            final File outputFile, 
            final String dbFilePath, 
            final FilterModel fModel,
            final double correctFactorValue
            )            
    {
        try
        {
            //final String[] arr1 = {"/home/rpark/a1.txt", "/home/rpark/a2.txt", "/home/rpark/a3.txt",  };
            
            //display progress bar
            final JDialog progress = new JDialog(this);
            
            //final ChroPeptide tempPeptide = this.currentPeptide;
            
            final JProgressBar aJProgressBar = new JProgressBar(0, 100);
            aJProgressBar.setStringPainted(true);
            Container cp = progress.getContentPane();
            JLabel jb = new JLabel("Merging files...", SwingConstants.CENTER);
            cp.add(jb, BorderLayout.SOUTH);
            cp.add(aJProgressBar, BorderLayout.NORTH);
            progress.setSize(500, 100);
            progress.setLocationRelativeTo(this);
            progress.pack();
            progress.setResizable(false);
	    progress.setVisible(true);
                       
	    Thread t = new Thread() {
                private boolean isSuccessful=true;
                private String errorMessage="";
                private PrintStream p = new PrintStream( new BufferedOutputStream(new FileOutputStream(outputFile)));    
                public void run() 
		{
		    //parent.dispose();
		    //MainFrame frame = (MainFrame) parent.getOwner();

		    printHeader(p);

                    p.println("H\tMerged Data");
                    
                    for(int i=0;i<arr.length;i++)
                    {
                        p.print("H\tMerged File : ");
                        p.println(arr[i]);
                    }
                    
                    p.print("H\tCorrection Factor Value : "); p.println(correctFactorValue);
                    
                    if(fModel.isDetSelect())                    
                    {    p.print("H\tDetermination Factor : "); p.println(fModel.getDetValue()); }
                    else
                        p.println("H\tNo Determination Factor");

                    if(fModel.isPValueSelect())
                    {    p.print("H\tOutlier pValue : "); p.println(fModel.getPValue()); }
                    else
                         p.println("H\tNo Outlier pValue");

                    if(fModel.isFilterFragmentIons())
                         p.println("H\tFilter Fragment Ions on MS/MS pValue : true");

		    p.println("H\tPLINE\tLOCUS\tAVERAGE_RATIO\tSTANDARD_DEVIATION\tPEPTIDE_NUM\tDESCRIPTION");
		    p.println("H\tSLINE\tUNIQUE\tSEQUENCE\tRATIO\tREGRESSION_FACTOR\tDETERMINANT_FACTOR\tSAM_INT\tREF_INT\tFILE_NAME");                    
                    
                    StringBuffer result = new StringBuffer();
         
                    int totalCount=0;
                    int quantifiedCount=0;

                    CenSusReportReader cReader = new CenSusReportReader();
                    
		    try {                        
                        
                        List<MergeProteinModel> list = cReader.merge(arr, aJProgressBar, dbFilePath, fModel, correctFactorValue);
                        
                        for(Iterator<MergeProteinModel> itr=list.iterator(); itr.hasNext(); )
                        {
                            MergeProteinModel protein = itr.next();
                            if(protein.getPeptides().size()<=0)
                                continue;
                            
                            if( fModel.isPValueSelect() )
                                protein.removeOutlier(fModel.getPValue());

                            for(Iterator<ChroProtein> pItr=protein.getProteins().iterator(); pItr.hasNext(); )
                            {
                                ChroProtein cPro = pItr.next();                                                                

                                result.append("P\t"); 
                                result.append(cPro.getLocus());
                                result.append("\t");                                
                                
                                if( Double.compare(protein.getAverageRatio(), Double.NaN) == 0)
                                    result.append("NA");
                                else
                                    result.append( format.format(protein.getAverageRatio()) );
                                result.append("\t");
                                                                
                                if( Double.compare(protein.getStdev(), Double.NaN) == 0)
                                    result.append("NA");
                                else                                    
                                    result.append( format.format(protein.getStdev()) );
                                
                                result.append("\t");
                                result.append( protein.getPeptides().size() );
                                
                                result.append("\t");
                                result.append( cPro.getSpectrumCount() );
                                
                                result.append("\t");
                                result.append(cPro.getDescription());                                
                                result.append("\n");                                
                                
                               // System.out.println("========" + cPro.getSpectrumCount() + " " + cPro.getDescription() + " " + );
                                
                            }

                            Vector pepList = new Vector();
                            pepList.addAll(protein.getPeptides());                            
                            
//                            if(pepList.size()>3 && fModel.isPValueSelect())
//                                edu.scripps.pms.stats.GrubbsTest.filterMerge(pepList, fModel.getPValue());
                                                                  
                            //for(Iterator<MergeProteinModel.Peptide> pepItr=protein.getPeptides().iterator(); pepItr.hasNext(); )
                            for(Iterator<MergeProteinModel.Peptide> pepItr=pepList.iterator(); pepItr.hasNext(); )
                            {
                                MergeProteinModel.Peptide pep = pepItr.next();
                             
                                result.append("S\t");
                                result.append(pep.isUnique()?"U":"");
                                result.append("\t");
                                result.append(pep.getSequence());
                                result.append("\t");
                                result.append( format.format(pep.getRatio()) );
                                result.append("\t");
                                result.append(format.format(pep.getRegFactor()) );
                                result.append("\t");
                                result.append(format.format(pep.getRegFactor()*pep.getRegFactor()) );
                                result.append("\t");                                
                                result.append( (pep.getSamIntensity()<0)?"":pep.getSamIntensity() );
                                result.append("\t");
                                result.append( (pep.getRefIntensity()<0)?"":pep.getRefIntensity() );
                                result.append("\t");
                                result.append(pep.getFileName());
                                result.append("\n");
                    
                                quantifiedCount++;                       
                            }                            
                        }
                    }
		    catch(IOException e)                      
		    {
			isSuccessful=false;
			errorMessage = e.getMessage();
                        
                        //System.out.println("error.." + e);
                        e.printStackTrace();
		    }
                    catch(Exception e)
                    {
                        isSuccessful=false;
			errorMessage = e.getMessage();
                        
                        //System.out.println("error.." + e);
                        e.printStackTrace();
                    }
                    
		    final int finalTotalCount = cReader.getTotalPeptideCount();
		    final int finalQuantifiedCount =  quantifiedCount; //quantifiedCount;

		    SwingUtilities.invokeLater(new Runnable() {
			    public void run() {
			    progress.setVisible(false);
			    progress.hide();

			    if(isSuccessful)
			    {
			    JOptionPane.showMessageDialog(
				chroPanel, 
				"Merging files completed.",
				"Merging files completed.", 
				JOptionPane.PLAIN_MESSAGE);
			    }                
			    else
			    {
			    JOptionPane.showMessageDialog(
				chroPanel, 
				errorMessage, 
				"Report file Creation", 
				JOptionPane.ERROR_MESSAGE);
                            
                             outputFile.delete();
			    }

                        }

                    }                    
		    );

                    
                    p.print("H\t"); p.print("Total peptides\t"); p.println(finalTotalCount);
                    p.print("H\t"); p.print("Quantified peptides\t"); p.print(finalQuantifiedCount); p.print("\n");
                    p.print("H\t"); p.print("Quantification efficiency\t"); p.print(twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 )); p.print(" %\n");
                    p.print(result.toString());

                    if(null != p)
                        p.close();  

		}
	    };
            
            t.start();
        }
        catch(IOException ioe)
        {
            JOptionPane.showMessageDialog(proteinListPanel, "Failed to open a chro file: " + ioe, "Failed to open a chro file", JOptionPane.ERROR_MESSAGE);
            ioe.printStackTrace();
        }
        
    }
    
    private void exportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportActionPerformed
// TODO add your handling code here:
        reportItemActionPerformed(evt);
    }//GEN-LAST:event_exportActionPerformed

    private void saveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveActionPerformed
// TODO add your handling code here:
        
        //System.out.println(chroFile.getAbsolutePath());
        try
        {
            //ChroGenerator.createFullscanXmlChro(list, isDataDependent);    
            
        }
        catch(Exception e)
        {
            System.out.println("Error : " + e.toString());
        }
        
        
        
    }//GEN-LAST:event_saveActionPerformed

    public void toggleFilterIcon(boolean isFilter)
    {
       
        if(isFilter)
            filterBtn.setIcon(new javax.swing.ImageIcon(getClass().getResource("/filter.gif")));
        else
            filterBtn.setIcon(new javax.swing.ImageIcon(getClass().getResource("/nofilter.gif")));
    }
    
    private void filterBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_filterBtnActionPerformed
// TODO add your handling code here:
        
        PostOptions options = PostOptions.getInstance();

        
        if(options.isFilterFragmentIons())
        {
            options.setFilterFragmentIons(false);
            toggleFilterIcon(false);
            //filterBtn.setIcon(new javax.swing.ImageIcon(getClass().getResource("/nofilter.gif")));
        }
        else
        {
            options.setFilterFragmentIons(true);
            toggleFilterIcon(true);
            //filterBtn.setIcon(new javax.swing.ImageIcon(getClass().getResource("/filter.gif")));            
        }        
        
        if(!this.labeled && this.quantLevel==1)
        {
            generateNonLabelData(currentPeptide);
        }
        else if(this.isDataDependent)
            generateDepData(currentPeptide);
        else if(options.isFilterFragmentIons())
            generateInDepFragData(currentPeptide);
        else
            generateInDepData(currentPeptide);

        
            
        if(cr.getQuantLevel()==1)
            updatePeptideInfo();
        else if(cr.getQuantLevel()==2)
        {
            if(options.isFilterFragmentIons())
                updateMS2PeptideFilterInfo(null, -1);
            else
                updatePeptideInfo();
        }

        /*
        if(this.isDataDependent)
            generateDepData(this.currentPeptide);
        else
            generateInDepFragData(this.currentPeptide);
            */   
    }//GEN-LAST:event_filterBtnActionPerformed

    private void openActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openActionPerformed
// TODO add your handling code here:
        this.OpenChroFileActionPerformed(evt);
    }//GEN-LAST:event_openActionPerformed

    private void optionItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_optionItemActionPerformed
        
        
        //options.setFilterFragmentIons(this.filterFragmentIons);
        //options.setDisplayFragmentIons(this.isDisplayFragmentIons());
                
        OptionsDialog dialog = new OptionsDialog(this,true);                  
        dialog.pack();
        dialog.setLocationRelativeTo(this);
        dialog.setVisible(true);
        dialog.setResizable(false);
                        

        // TODO add your handling code here:
    }//GEN-LAST:event_optionItemActionPerformed
    
    //labeling free report
    public void exportReport()
    {
        JFileChooser choose = new JFileChooser(this.currentDirectory);
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Save CenSus Report File");
        choose.setApproveButtonText("Write");
        choose.addChoosableFileFilter( new SimpleFileNameFilter("txt", "CenSus Report File (*.txt)") );
                
        if(currentDirectory != null && !"".equals(currentDirectory))
	    choose.setCurrentDirectory(new File(currentDirectory));

        File f = new File(this.currentDirectory + File.separator + "census-out.txt");
        choose.setSelectedFile(f);

        int returnVal = choose.showOpenDialog(chroPanel);

        if(returnVal == choose.CANCEL_OPTION)
            return;
        
        final File file = choose.getSelectedFile();
        //isotopeFileField.setText(file.getAbsolutePath());
        
        try
        {
            //display progress bar
            final JDialog progress = new JDialog(this);
            final String tempFolder = this.currentDirectory + File.separator;
            final ChroPeptide tempPeptide = this.currentPeptide;
            
            //final JPanel tempPepPanel = this.peptidePanel;
            final JProgressBar aJProgressBar = new JProgressBar(0, 100);
            //aJProgressBar.setIndeterminate(true);
            aJProgressBar.setStringPainted(true);
            
            Container cp = progress.getContentPane();
            
            //cp.setSize(1000, 500);
            JLabel jb = new JLabel("Generating report...",
                               SwingConstants.CENTER);
            cp.add(jb, BorderLayout.SOUTH);
            cp.add(aJProgressBar, BorderLayout.NORTH);
            progress.setSize(500, 100);
            progress.setLocationRelativeTo(this);
            progress.pack();

            progress.setResizable(false);
	    progress.setVisible(true);

                                
            Thread t = null;
            
            if(!labeled && quantLevel==1)
            {
                
                t = new Thread() {
                    private boolean isSuccessful=true;
                    private String errorMessage="";
                    private PrintStream p = new PrintStream( new BufferedOutputStream(new FileOutputStream(file)));    
                    public void run() 
                    {
                        //parent.dispose();
                        //MainFrame frame = (MainFrame) parent.getOwner();
                        //head lines

			printHeader(p);
                        p.println("H\tCensus nonlabeling analysis");                        
                        p.print("H\tcreated date\t"); p.println(new Date());
                        

                        ArrayList sampleList = cr.getSampleList();
                        ArrayList fileList = cr.getFileList();
                        
                        p.print("H\tPLINE\tLOCUS\t");
                       
		       /*
                        for(Iterator<String> itr=sampleList.iterator(); itr.hasNext(); )
                        {
                            String each = itr.next();
                            p.print(each);
                            p.print("_WEIGHTED_AVG_INT\t");
                        }
			*/

			for(int i=1;i<sampleList.size();i++)
			{
			    String str = sampleList.get(i).toString();

			    p.print("AVG(");
                            p.print(sampleList.get(0));
                            p.print("_INT");
			    p.print("/" + str);
                            p.print("_INT");
			    p.print(")\t");
			}

/*
                        for(Iterator<String> itr=sampleList.iterator(); itr.hasNext(); )
                        {
                            String each = itr.next();
                            p.print(each);
                            p.print("_AVG_INT\t");
                        }
*/

                        p.println("PEPTIDE_NUM\tSPEC_COUNT\tDESCRIPTION");
                        
                        p.print("H\tSLINE\tUNIQUE\tSEQUENCE\t"); //RATIO\tREGRESSION_FACTOR\tDETERMINANT_FACTOR\tSAM_INT\tREF_INT\tSIGNAL_TO_NOISE_RATIO\tFILE_NAME");
                        
                        int fileSize = fileList.size();                        
			for(int i=1;i<sampleList.size();i++)
			{
			    String str = sampleList.get(i).toString();

                            p.print(sampleList.get(0));
                            p.print("_INT");
			    p.print("/" + str);
                            p.print("_INT\t");

//                            p.print(sampleList.get(0) + "/" + str);
  //                          p.print("_STDEV\t");                            
			}

/*
                        for(Iterator<String> itr=sampleList.iterator(); itr.hasNext(); )
                        {
                            String each = itr.next();
                            //p.print(each);
                            //p.print(" TOTAL INTENSITY\t");
                            p.print(each);
                            p.print("_AVG\t");
                            p.print(each);
                            p.print("_STDEV\t");                            
                        }
                      */  
                       /* 
                        for(Iterator<String> itr=fileList.iterator(); itr.hasNext(); )
                        {
                            String each = itr.next();
                            p.print(each.substring( each.lastIndexOf(File.separator)+1 ));
                            p.print("\t");
                        }
                        */
                                
                        p.print("FILE_NAME");
                        p.println();

                        StringBuffer result = new StringBuffer();

                        int totalCount=0;
                        int quantifiedCount=0;
                        int tempaaa=0;

                        try {
                            double eachSeg = (double)100/list.size();                
                            double percent =0;

                            StringBuffer proteinSb = new StringBuffer();
                            boolean isSameGroup=false;

                            for(Iterator<ChroProtein> proItr = list.iterator(); proItr.hasNext(); )
                            {                    
                                ChroProtein protein = proItr.next();            

                                if(!isSameGroup)
                                    proteinSb = new StringBuffer();

                                if(protein.isRedundant())
                                {
                                    isSameGroup = true;
                                    proteinSb.append("P\t"); 
                                    proteinSb.append(protein.getLocus());
                                    proteinSb.append("\n");

                                    continue;
                                }
                                else
                                {
                                    isSameGroup=false;
                                }

                                StringBuffer peptideLines = new StringBuffer();
                                List<ChroPeptide> peptideList = protein.getPeptideList();
                                List<ChroPeptide> tempPepList = new Vector<ChroPeptide>();

                                long[] sampleIntSumArr = new long[sampleList.size()];
                                
                                for(Iterator<ChroPeptide> pepItr = peptideList.iterator(); pepItr.hasNext(); )
                                {   
                                    ChroPeptide peptide = pepItr.next();                                
                                    
                                    totalCount++;

                                    
                                    List dataList = peptide.getDataList();                                                                               

                                    long[] intensitySumArr = new long[fileSize];
                                    //long[] samArr = new long[dataList.size()];
                                    //long[] refArr = new long[samArr.length];

                                    //double samIntSum = 0;
                                    //double refIntSum = 0;

                                    //int index=0;
                                    //int startIndex=0;
                                    //int endIndex=samArr.length-1;

                                    int startRange = Integer.parseInt(peptide.getStartRange());
                                    int endRange = Integer.parseInt(peptide.getEndRange());

                                    //LinearRegression reg = null;
                                    
                                    for(Iterator<ChroNonLabelData> dataItr=dataList.iterator(); dataItr.hasNext(); )
                                    {
                                        ChroNonLabelData eachData = dataItr.next();

                                        int[] scanNumArr = eachData.getScanNumArr();
                                        long[] intenArr = eachData.getIntensityArr();

                                        for(int i=0;i<scanNumArr.length;i++)
                                        {                                    
                                            if(scanNumArr[0]>=startRange && scanNumArr[0]<=endRange)
                                                intensitySumArr[i] += intenArr[i];
                                        }

                                    }
                                    
                                    peptide.setTotalIntArr(intensitySumArr);
                                    
                                    //System.out.println("============>>" + intensitySumArr.length);
                                    
                                    //for(int i=0;i<intensitySumArr.length;i++)
                                      //  System.out.println(intensitySumArr[i]);
                                    
                                    
                                    tempPepList.add(peptide);
                                    
                                }

                                int peptideCount=0;
                                //double ratioSum=0;
                                

                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();

                                    //fix me when we use filtering
                                    //if(!noFilter && each.isFilterOut())
                                    //    continue;

                                    //ratioSum += each.getSlope();
                                    peptideCount++;
                                    quantifiedCount++;
                                    
                                }

                                proteinSb.append("P\t"); 
                                proteinSb.append(protein.getLocus());
                                proteinSb.append("\t");
                                //proteinSb.append( averageRatio>0?format.format(averageRatio):"" );
                                //proteinSb.append("\t");

                                double devSum=0;

                                StringBuffer pepSb = new StringBuffer();

                                //int tmpc=0;
                                WeightedProtein wProtein = new WeightedProtein();
                                long[][] sampleIntWeightStdevArr = new long[sampleList.size()][tempPepList.size()]; //standard dev for weighted avg
                                long[][] sampleIntStdevArr = new long[sampleList.size()][tempPepList.size()]; //standard dev for simple avg


				//remove outlier
				/*
				for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
				{
                                    ChroPeptide each = tempItr.next();

				    List<String> samNameList = cr.getSampleList();
				    String refSamName = samNameList.get(0);
				    ChroXmlReader.Sample refSam = sampleHt.get(refSamName);                                            

				    for(int i=1;i<samNameList.size();i++)
				    {       
					//String sampleName = itr.next();
					String sampleName = samNameList.get(i);
					ChroXmlReader.Sample eachSam = sampleHt.get(sampleName);                                            
					//sampleIntSum += eachSam.getSumIntensity();

					if(eachSam.getSumIntensity()>0)
					{
					    pepSb.append( format.format( (double)refSam.getAverage()/eachSam.getAverage()) ).append("\t");  
					} else
					{
					    //   pepSb.append( 0.0 ).append("\t");
					    pepSb.append( 0.0 ).append("\t");  
					}
				    }

				}
				*/

				//peptide ratio array before removing outlier
				double[][] pepRatioArr = new double[tempPepList.size()][sampleList.size()-1];

				int pepCount=0;

                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();
                                    
                                    //fix me when we use filtering              
                                    //if(noFilter || !each.isFilterOut())
                                    //{
//                                        devSum += dev*dev;
/*
                                        pepSb.append("S\t");
                                        pepSb.append(each.isUnique()?"U":"");
                                        pepSb.append("\t");
                                        pepSb.append(each.getSequence());
                                        pepSb.append("\t");
*/                                        
                                        long[] totalIntArr = each.getTotalIntArr();
                                        Hashtable<String, ChroXmlReader.Sample> sampleHt = new Hashtable<String, ChroXmlReader.Sample>();
                                        
                                        for(int i=0;i<totalIntArr.length;i++)
                                        {
                                            String sampleName = cr.getSampleName(i);
                                            
                                            ChroXmlReader.Sample sample = sampleHt.get(sampleName);
            
                                            if(null == sample)
                                            {
                                                sample = new ChroXmlReader.Sample(sampleName);
                                                sample.addIntensity(totalIntArr[i]);
                                                sampleHt.put(sampleName, sample);
                                            }
                                            else
                                            {
                                                sample.addIntensity(totalIntArr[i]);
                                            }                                
                                            
                                        }
        
                                        int samIndex=0;
					List<String> samNameList = cr.getSampleList();
					String refSamName = samNameList.get(0);
					ChroXmlReader.Sample refSam = sampleHt.get(refSamName);                                            

                                        for(int i=1;i<samNameList.size();i++)
                                        {       
                                            //String sampleName = itr.next();
                                            String sampleName = samNameList.get(i);
                                            ChroXmlReader.Sample eachSam = sampleHt.get(sampleName);                                            
                                            //sampleIntSum += eachSam.getSumIntensity();

					    sampleIntStdevArr[samIndex][pepCount] = eachSam.getAverage()>0?eachSam.getAverage():0;
					    samIndex++;
                                                          
                                            if(eachSam.getSumIntensity()>0)
                                            {
						double dValue = (double)refSam.getAverage()/eachSam.getAverage();
                                                //pepSb.append( format.format(dValue) ).append("\t");  
						pepRatioArr[pepCount][i-1] = dValue;
                                            } else
                                            {
                                                //pepSb.append( 0.0 ).append("\t");  
						pepRatioArr[pepCount][i-1] = 0;
                                            }
                                            
                                            int count=0;
                                            long[] intArr = new long[eachSam.getIntensityArr().size()];
                                            
                                            for(Iterator<Long> itrInt = eachSam.getIntensityArr().iterator(); itrInt.hasNext(); )
                                            {
                                                //itrInt.next();
                                                intArr[count++] = itrInt.next().longValue();                       
                                            }            
           
                                        }
                                            
                                        //for(int i=0;i<totalIntArr.length;i++)
                                          //  pepSb.append( totalIntArr[i]>0?scientificFormat.format(totalIntArr[i]):0.0 ).append("\t");
                                        
//                                        pepSb.append(each.getFileName()).append("\n");
                                    //}
                                   	pepCount++; 
                                }

/*
				for(int ii=0;ii<pepRatioArr.length;ii++)
				{
				    for(int jj=0;jj<pepRatioArr[ii].length;jj++)
					System.out.print("-->>" + pepRatioArr[ii][jj]);
				    System.out.println("");

				}
*/
				double[] averageRatioArr = new double[pepRatioArr[0].length];
				double[] stdevRatioArr = new double[pepRatioArr[0].length];
				double[] dArr = null;

				for(int ii=0;ii<pepRatioArr[0].length;ii++)
				{
				    double[] tmpArr = new double[pepRatioArr.length];
				    double[] tmpArrForStdev = new double[pepRatioArr.length];
				    
				    for(int jj=0;jj<pepRatioArr.length;jj++)
				    {
					tmpArr[jj] = pepRatioArr[jj][ii];
					tmpArrForStdev[jj] = pepRatioArr[jj][ii];
				    }

                                    
				    //iterate until there is no outliers
				    while(true)
				    {
                                        //System.out.println(ii + "========");
					//dArr = edu.scripps.pms.stats.GrubbsTest.filter(tmpArr, 0.1);
					dArr = edu.scripps.pms.stats.GrubbsTest.filterExcludingNegative(tmpArr, conf.getOutlierPValue());

					int num1=0;
					int num2=0;
					for(double each : dArr)
						if(each == -1)
							num1++;

					for(double each : tmpArr)
						if(each == -1)
							num2++;


//					for(int k=0;k<dArr.length;k++)
//						System.out.println(dArr[k] + "\t" + tmpArr[k]);
//System.out.println(num1 + " " + num2);
					tmpArr = dArr;

					if(num1 == num2)
						break;
		
				    }

				    int pepTmpCount=0;
				    double tmpSum=0;
				    for(int jj=0;jj<dArr.length;jj++)
				    {
					if(-1 == dArr[jj])
					{
					    pepRatioArr[jj][ii] = -1;
					    tmpArrForStdev[jj] = -1;
					}
					else
					{
					    pepTmpCount++;
					    tmpSum += pepRatioArr[jj][ii];
					}
				    }

				    averageRatioArr[ii] = tmpSum / pepTmpCount;
				    stdevRatioArr[ii] = STDev.getStdevWithoutNegative(tmpArrForStdev);
				    
				}

                                //if( protein.getLocus().equals("YMR303C") )
                                  //  System.exit(0);
                                
				int tmpCount=0;

				for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
				{
				    ChroPeptide each = tempItr.next();

				    pepSb.append("S\t");
				    pepSb.append(each.isUnique()?"U":"");
				    pepSb.append("\t");
				    pepSb.append(each.getSequence());
				    pepSb.append("\t");

				    for(int jj=0;jj<pepRatioArr[tmpCount].length;jj++)
				    {
					if(-1 == pepRatioArr[tmpCount][jj])
					    pepSb.append("OL").append("\t");
					else
					{
					    pepSb.append(  format.format(pepRatioArr[tmpCount][jj]) ).append("\t");
					}
				    }

				    pepSb.append(each.getFileName()).append("\n");

				    tmpCount++;
				}

//                                if(!noFilter && tempPepList.size()>3 && pValueSelect)
				    //edu.scripps.pms.stats.GrubbsTest.filter(tempPepList, pValue);
                               
				
                                for(int i=0;i<averageRatioArr.length;i++)
				{
				    proteinSb.append( format.format(averageRatioArr[i]) ).append("\t");
				    proteinSb.append( format.format(stdevRatioArr[i]) ).append("\t");
				}

/*
                                //average intensity
                                for(int i=0;i<sampleIntSumArr.length;i++)
                                {
                                    proteinSb.append("\t");
                                    //proteinSb.append( scientificFormat.format(peptideCount>0?(sampleIntSumArr[i]/peptideCount):0) );
                                    proteinSb.append( scientificFormat.format(peptideCount>0?(sampleIntSumArr[i]/peptideCount):0) );
                                }
  */                              
                                proteinSb.append(peptideCount>0?peptideCount:"");
                                proteinSb.append("\t");
                                proteinSb.append(protein.getSpectrumCount());
                                proteinSb.append("\t");
                                proteinSb.append(protein.getDescription());
                                proteinSb.append(peptideLines.toString());                
                                proteinSb.append("\n");

                                percent += eachSeg;
                                aJProgressBar.setValue((int)percent);

                                if( pepSb.length()<=0 )
                                    continue;

                                result.append(proteinSb.toString());
                                result.append(pepSb.toString());			    


                                //System.out.println(proteinSb.toString() + pepSb.toString());
                            }

                        }
                        catch(Exception e)  
                        {
                            isSuccessful=false;
                            errorMessage = e.getMessage();
                            e.printStackTrace();
                        }

                        final int finalTotalCount = totalCount;
                        final int finalQuantifiedCount = quantifiedCount;

                        SwingUtilities.invokeLater(new Runnable() {
                                public void run() {
                                progress.setVisible(false);
				progress.hide();

                                if(isSuccessful)
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    "Report file was successfully created." + 
                                    "\n\nTotal peptides : " + finalTotalCount + 
                                    "\nQuantified peptides : " + finalQuantifiedCount +
                                    "\nQuantification efficiency : " + twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 ) + " %",
                                    "Report file Creation", 
                                    JOptionPane.PLAIN_MESSAGE);
                                }                
                                else
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    errorMessage, 
                                    "Report file Creation", 
                                    JOptionPane.ERROR_MESSAGE);
                                }

                            }

                        }                    
                        );

                        p.print("H\t"); p.print("Total peptides\t"); p.println(finalTotalCount);
                        p.print("H\t"); p.print("Quantified peptides\t"); p.print(finalQuantifiedCount); p.print("\n");
                        p.print("H\t"); p.print("Quantification efficiency\t"); p.print(twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 )); p.print(" %\n");
                        //p.print("H\t"); p.print("Correction Factor (Ln)\t"); p.println(correctFactorValue);                    
                        
                        p.print(result.toString());

                        if(null != p)
                            p.close();  


                    }

                };
                
                         
                System.out.println("nonlabeled...");
                //return;                         
            }
            

            

        
        t.start();
  
            
            
        } catch(IOException e)
        {
            System.out.println("Failed to write file" + e);
            e.printStackTrace();
            
        }
    }
    
    public void exportDummy()
    {
        JFileChooser choose = new JFileChooser(this.currentDirectory);
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Save CenSus Report File");
        choose.setApproveButtonText("Write");
        choose.addChoosableFileFilter( new SimpleFileNameFilter("txt", "CenSus Report File (*.txt)") );
                
        if(currentDirectory != null && !"".equals(currentDirectory))
	    choose.setCurrentDirectory(new File(currentDirectory));

        File f = new File(this.currentDirectory + File.separator + "census-out.txt");
        choose.setSelectedFile(f);

        int returnVal = choose.showOpenDialog(chroPanel);

        if(returnVal == choose.CANCEL_OPTION)
            return;
        
        final File file = choose.getSelectedFile();
        isotopeFileField.setText(file.getAbsolutePath());
        
        final JDialog progress = new JDialog(this);
        try
        {
            //display progress bar
            final String tempFolder = this.currentDirectory + File.separator;
            final ChroPeptide tempPeptide = this.currentPeptide;
            
            //final JPanel tempPepPanel = this.peptidePanel;
            final JProgressBar aJProgressBar = new JProgressBar(0, 100);
            //aJProgressBar.setIndeterminate(true);
            aJProgressBar.setStringPainted(true);
            
            Container cp = progress.getContentPane();
            
            //cp.setSize(1000, 500);
            JLabel jb = new JLabel("Generating report...",
                               SwingConstants.CENTER);
            cp.add(jb, BorderLayout.SOUTH);
            cp.add(aJProgressBar, BorderLayout.NORTH);
            progress.setSize(500, 100);
            progress.setLocationRelativeTo(this);
            progress.pack();

            progress.setResizable(false);
	    progress.setVisible(true);

	    final boolean tempIsdataDependent = this.isDataDependent;
            
            ////////////  FIX THIS
            //final boolean tempIsFilterFrag = true; //options.isFilterFragmentIons();
            //////////////////
            
	    //final boolean tempIsFilterFrag = options.isFilterFragmentIons();
	    //final float tmpDetValue = options.getDetFactorValue();
            //final double tmpDetValue = detValue;
            
	    //bar.setValue((int)percent);                    
	    //        progressBar.setStringPainted(true);

                                
            Thread t = null;
            
                t = new Thread() {
                    private boolean isSuccessful=true;
                    private String errorMessage="";
                    private PrintStream p = new PrintStream( new BufferedOutputStream(new FileOutputStream(file)));    
                    public void run() 
                    {
                        //parent.dispose();
                        //MainFrame frame = (MainFrame) parent.getOwner();
                        //head lines

			printHeader(p);
                        p.print("H\tcreated date\t"); p.println(new Date());


                        p.println("H\tPLINE\tLOCUS\tAVERAGE_RATIO\tSTANDARD_DEVIATION\tWEIGHTED_AVERAGE\tPEPTIDE_NUM\tSPEC_COUNT\tDESCRIPTION");
                        //p.println("H\tSLINE\tUNIQUE\tSEQUENCE\tRATIO\tREGRESSION_FACTOR\tDETERMINANT_FACTOR\tSAM_INT\tREF_INT\tSIGNAL_TO_NOISE_RATIO\tFILE_NAME");
                        p.println("H\tSLINE\tUNIQUE\tSEQUENCE\tRATIO\tREGRESSION_FACTOR\tDETERMINANT_FACTOR\tSAM_INT\tREF_INT\tFILE_NAME");

                        StringBuffer result = new StringBuffer();

                        int totalCount=0;
                        int quantifiedCount=0;
                        int tempaaa=0;

                        try {
                            //ChroProtein teP = list.get(0);

                            double eachSeg = (double)100/list.size();                
                            double percent =0;

                            StringBuffer proteinSb = new StringBuffer();
                            boolean isSameGroup=false;

                            for(Iterator<ChroProtein> proItr = list.iterator(); proItr.hasNext(); )
                            {                    
                                ChroProtein protein = proItr.next();            

                                if(!isSameGroup)
                                    proteinSb = new StringBuffer();

                                if(protein.isRedundant())
                                {
                                    isSameGroup = true;
                                    proteinSb.append("P\t"); 
                                    proteinSb.append(protein.getLocus());
                                    proteinSb.append("\n");

                                    continue;
                                }
                                else
                                {
                                    isSameGroup=false;
                                }

                                StringBuffer peptideLines = new StringBuffer();
                                List<ChroPeptide> peptideList = protein.getPeptideList();
                                List<ChroPeptide> tempPepList = new Vector<ChroPeptide>();

                                //System.out.println("protein====" + protein.getLocus());
                                
                                for(Iterator<ChroPeptide> pepItr = peptideList.iterator(); pepItr.hasNext(); )
                                {   
                                    ChroPeptide peptide = pepItr.next();                                
                                    totalCount++;

                                    List l = peptide.getDataList();

                                    long[] samArr = new long[l.size()];
                                    long[] refArr = new long[samArr.length];

                                    double samIntSum = 0;
                                    double refIntSum = 0;

                                    int index=0;
                                    int startIndex=0;
                                    int endIndex=samArr.length-1;

                                    int startRange = Integer.parseInt(peptide.getStartRange());
                                    int endRange = Integer.parseInt(peptide.getEndRange());

                                    LinearRegression reg = null;

                                    
                                        for(Iterator<ChroData> dataItr = l.iterator(); dataItr.hasNext(); )
                                        {
                                            ChroData data = dataItr.next();

                                            samArr[index] = data.getSampleIntensity();
                                            refArr[index] = data.getRefIntensity();            

                                            int scanTemp = data.getScanNum();            
                                            if(startRange>=scanTemp)
                                                startIndex = index;
                                            if(endRange>=scanTemp)
                                                endIndex = index;

                                            index++;                                        
                                        }

                                        samIntSum = 0;
                                        refIntSum = 0;

                                        //System.out.println("sn===>>" + format.format(snRatio));

    //                                    System.out.println(noise + "\t" + signal);

                                        endIndex = (endIndex!=0)?endIndex:samArr.length;
                                        for(int ii=startIndex;ii<=endIndex;ii++)
                                        {
                                            samIntSum += samArr[ii];
                                            refIntSum += refArr[ii];
                                        }                                    

                                        reg = new LinearRegression(samArr, refArr, startIndex, endIndex, MAX_SHIFT);
                                    

                                    double slope = reg.getSlope();
                                    double intercept = reg.getIntercept();

                                   // double snRatio = CalcUtil.calculateSNRatio(samArr, refArr, startIndex, endIndex);

                        //            System.out.println(snRatio);

                                    //if(!noFilter && reg.getCorr()<0)
                                    //    continue;

                                    //if( noFilter && reg.getCorr()<0)
                                    //    continue;

                                    //normalize the ratio in case overall ratios shifted 
                                    
                                    slope = Math.exp(Math.log(slope));
                                    
                                    peptide.setSlope(slope);
                                    peptide.setCorr(reg.getCorr());
                                    //System.out.println("it is ==>>" + peptide.getSequence() + " " + slope + " " + reg.getCorr()*reg.getCorr());
                                    peptide.setSamIntensity(samIntSum);
                                    peptide.setRefIntensity(refIntSum);
                                    //peptide.setSnRatio(snRatio);

                                    tempPepList.add(peptide);

                                    //tempPepCount++;                                
                                }


                                double averageRatio=0;
                                int peptideCount=0;
                                double ratioSum=0;

                                //System.out.println("");
                                //System.out.print(tempPepList.size() + "\t");

                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();

                                  //  if(!noFilter && each.isFilterOut())
                                    //    continue;

                                    if(each.getSlope()>0)
                                    {
                                        ratioSum += each.getSlope();
                                        peptideCount++;
                                        quantifiedCount++;
                                    }
                                }

                                //System.out.println("pepcount==>>" + peptideCount);
                                //System.out.println(quantifiedCount + "\t");

                                if(peptideCount>0)
                                    averageRatio = ratioSum/peptideCount;

                                proteinSb.append("P\t"); 
                                proteinSb.append(protein.getLocus());
                                proteinSb.append("\t");
                                proteinSb.append( averageRatio>0?format.format(averageRatio):"" );
                                proteinSb.append("\t");
                                
                                

                                double devSum=0;

                                StringBuffer pepSb = new StringBuffer();

				WeightedProtein.ProteinModel pModel = new WeightedProtein.ProteinModel();

                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();

               //                     if(isUniquePeptide && !each.isUnique())
               //                         continue;

                                    //if(noFilter || !each.isFilterOut())
                                    //{
                                        
                                        pepSb.append("S\t");
                                        pepSb.append(each.isUnique()?"U":"");
                                        pepSb.append("\t");
                                        pepSb.append(each.getSequence());
                                        pepSb.append("\t");

					if(each.getCorr()<0)
					{
					    pepSb.append( "0.0" );
					    pepSb.append("\t");
					    pepSb.append(format.format(each.getCorr()) );
					    pepSb.append("\t");
					    pepSb.append("0.0");
					}
					else
					{
					    pepSb.append( format.format(each.getSlope()) );
					    pepSb.append("\t");
					    pepSb.append(format.format(each.getCorr()) );
					    pepSb.append("\t");
					    pepSb.append(format.format(each.getCorr()*each.getCorr()) );
					}

                                        pepSb.append("\t");
                                        pepSb.append( each.getSamIntensity() );                                    
                                        pepSb.append("\t");
                                        pepSb.append( each.getRefIntensity() );                                    
                                        pepSb.append("\t");           
                                        
                                        
                                        /*
                                        double rsqrtLog = Math.log( each.getCorr()*each.getCorr() );
                                        double stdevLog = -0.84 * rsqrtLog + 0.43;
                                        double invStdev = Math.exp(stdevLog);
*/

                                        double invStdev = CalcUtil.getWeightedStdev(each.getCorr());
                                        
                                        //grap only valid ratio
                                        if(each.getSlope()>0)
                                        {
                                            pModel.add(invStdev, each.getSlope());                                            
                                            double dev = each.getSlope()-averageRatio;
                                            devSum += dev*dev;    

                                        }
                                 //       pepSb.append( format.format(each.getSnRatio()) );
                                 //       pepSb.append("\t");
                                        pepSb.append(each.getFileName());
                                        pepSb.append("\n");

                                  //  }
                                }

                                if(peptideCount>1)
                                    proteinSb.append( format.format(Math.sqrt(devSum/(peptideCount-1))) );
                                else                                
                                    proteinSb.append("");

                                proteinSb.append("\t");
				proteinSb.append( format.format(pModel.getStandardWeightedAverage()) );
                                proteinSb.append("\t");
                                proteinSb.append(peptideCount>0?peptideCount:"");
                                proteinSb.append("\t");
                                proteinSb.append(protein.getSpectrumCount());
                                proteinSb.append("\t");                                
                                proteinSb.append(protein.getDescription());
//                                proteinSb.append(peptideLines.toString());                
                                proteinSb.append("\n");

                                percent += eachSeg;
                                aJProgressBar.setValue((int)percent);

                                if( pepSb.length()<=0 )
                                    continue;

                                result.append(proteinSb.toString());
                                result.append(pepSb.toString());			    


                                //System.out.println(proteinSb.toString() + pepSb.toString());
                            }
                        }
                        catch(Exception e)  
                        {
                            isSuccessful=false;
                            errorMessage = e.getMessage();
                            e.printStackTrace();
                        }

                        final int finalTotalCount = totalCount;
                        final int finalQuantifiedCount = quantifiedCount;

                        SwingUtilities.invokeLater(new Runnable() {
                                public void run() {
                                progress.setVisible(false);
				progress.hide();

                                if(isSuccessful)
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    "Report file was successfully created." + 
                                    "\n\nTotal peptides : " + finalTotalCount + 
                                    "\nQuantified peptides : " + finalQuantifiedCount +
                                    "\nQuantification efficiency : " + twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 ) + " %",
                                    "Report file Creation", 
                                    JOptionPane.PLAIN_MESSAGE);
                                }                
                                else
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    errorMessage, 
                                    "Report file Creation", 
                                    JOptionPane.ERROR_MESSAGE);
                                }

                            }

                        }                    
                        );

                        p.print("H\t"); p.print("Total peptides\t"); p.println(finalTotalCount);
                        p.print("H\t"); p.print("Quantified peptides\t"); p.print(finalQuantifiedCount); p.print("\n");
                        p.print("H\t"); p.print("Quantification efficiency\t"); p.print(twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 )); p.print(" %\n");
                        //p.print("H\t"); p.print("Correction Factor (Ln)\t"); p.println(correctFactorValue);                    
                        p.print(result.toString());

                        if(null != p)
                            p.close();  

                    }
                };
            

            

        
        t.start();
  
            
            
        } catch(IOException e)
        {
            System.out.println("Failed to write file" + e);
            if(null != progress)
	    {
                progress.setVisible(false);
		progress.hide();
	    }
            JOptionPane.showMessageDialog(this, e.toString(), e.toString(), JOptionPane.ERROR_MESSAGE);

            e.printStackTrace();
            
        }
        
    }
    
    //labeled report
    public void exportReport(
            final boolean noFilter, 
            final boolean detSelect, 
            final boolean pValueSelect, 
            final boolean filterFragmentIons, 
            final double detValue, 
            final double pValue, 
            final double correctFactorValue, 
            final boolean isUniquePeptide, 
            final boolean removeNegative) {
        
        /*
        if(true)
        {
            exportDummy();
            return;
        }
        */
        JFileChooser choose = new JFileChooser(this.currentDirectory);
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Save CenSus Report File");
        choose.setApproveButtonText("Write");
        choose.addChoosableFileFilter( new SimpleFileNameFilter("txt", "CenSus Report File (*.txt)") );
                
        if(currentDirectory != null && !"".equals(currentDirectory))
	    choose.setCurrentDirectory(new File(currentDirectory));

        File f = new File(this.currentDirectory + File.separator + "census-out.txt");
        choose.setSelectedFile(f);

        int returnVal = choose.showOpenDialog(chroPanel);

        if(returnVal == choose.CANCEL_OPTION)
            return;
        
        final File file = choose.getSelectedFile();
        isotopeFileField.setText(file.getAbsolutePath());
        
        final JDialog progress = new JDialog(this);
        try
        {
            //display progress bar
            
            final String tempFolder = this.currentDirectory + File.separator;
            final ChroPeptide tempPeptide = this.currentPeptide;
            
            //final JPanel tempPepPanel = this.peptidePanel;
            final JProgressBar aJProgressBar = new JProgressBar(0, 100);
            //aJProgressBar.setIndeterminate(true);
            aJProgressBar.setStringPainted(true);
            
            Container cp = progress.getContentPane();
            
            //cp.setSize(1000, 500);
            JLabel jb = new JLabel("Generating report...",
                               SwingConstants.CENTER);
            cp.add(jb, BorderLayout.SOUTH);
            cp.add(aJProgressBar, BorderLayout.NORTH);
            progress.setSize(500, 100);
            progress.setLocationRelativeTo(this);
            progress.pack();

            progress.setResizable(false);
	    progress.setVisible(true);

	    final boolean tempIsdataDependent = this.isDataDependent;
            
            ////////////  FIX THIS
            //final boolean tempIsFilterFrag = true; //options.isFilterFragmentIons();
            //////////////////
            
	    //final boolean tempIsFilterFrag = options.isFilterFragmentIons();
	    //final float tmpDetValue = options.getDetFactorValue();
            //final double tmpDetValue = detValue;
            
	    //bar.setValue((int)percent);                    
	    //        progressBar.setStringPainted(true);

                                
            Thread t = null;
            
            /*
            if(!labeled && quantLevel==1)
            {
                
                t = new Thread() {
                    private boolean isSuccessful=true;
                    private String errorMessage="";
                    private PrintStream p = new PrintStream( new BufferedOutputStream(new FileOutputStream(file)));    
                    public void run() 
                    {
                        //parent.dispose();
                        //MainFrame frame = (MainFrame) parent.getOwner();
                        //head lines

                        p.println("H\tCenSus version " + VERSION);
                        p.println("H\tCreated by ");
                        p.println("H\tJohn Venable jvenable@scripps.edu");
                        p.println("H\tRobin, Sung Kyu Park rpark@scripps.edu");
                        p.println("H\tMichael J. MacCoss");                    
                        p.println("H\tThe Scripps Research Institute, La Jolla, CA");
                        p.println("H\tCensus nonlabeling analysis");                        
                        p.print("H\tcreated date\t"); p.println(new Date());
                        
                        
                        ArrayList sampleList = cr.getSampleList();
                        ArrayList fileList = cr.getFileList();
                        
                        p.print("H\tPLINE\tLOCUS\t");
                        for(Iterator<String> itr=sampleList.iterator(); itr.hasNext(); )
                        {
                            String each = itr.next();
//                            p.print(each);
//                            p.print(" TOTAL INTENSITY\t");
                            p.print(each);
                            p.print(" AVG_INT\t");
//                            p.print(each);
//                            p.print(" STDEV\t");                            
                        }
                        
                        p.println("PEPTIDE_NUM\tSPEC_COUNT\tDESCRIPTION");
                        
                        p.print("H\tSLINE\tUNIQUE\tSEQUENCE\t"); //RATIO\tREGRESSION_FACTOR\tDETERMINANT_FACTOR\tSAM_INT\tREF_INT\tSIGNAL_TO_NOISE_RATIO\tFILE_NAME");
                        
                        int fileSize = fileList.size();                        
                        for(Iterator<String> itr=sampleList.iterator(); itr.hasNext(); )
                        {
                            String each = itr.next();
                            p.print(each);
                            p.print(" TOTAL INTENSITY\t");
                            p.print(each);
                            p.print(" AVG\t");
                            p.print(each);
                            p.print(" STDEV\t");                            
                        }
                        
                        for(Iterator<String> itr=fileList.iterator(); itr.hasNext(); )
                        {
                            String each = itr.next();
                            p.print(each.substring( each.lastIndexOf(File.separator)+1 ));
                            p.print("\t");
                        }
                        
                        p.print("FILE NAME");
                        p.println();

                        StringBuffer result = new StringBuffer();

                        int totalCount=0;
                        int quantifiedCount=0;
                        int tempaaa=0;

                        try {
                            double eachSeg = (double)100/list.size();                
                            double percent =0;

                            StringBuffer proteinSb = new StringBuffer();
                            boolean isSameGroup=false;

                            for(Iterator<ChroProtein> proItr = list.iterator(); proItr.hasNext(); )
                            {                    
                                ChroProtein protein = proItr.next();            

                                if(!isSameGroup)
                                    proteinSb = new StringBuffer();

                                if(protein.isRedundant())
                                {
                                    isSameGroup = true;
                                    proteinSb.append("P\t"); 
                                    proteinSb.append(protein.getLocus());
                                    proteinSb.append("\n");

                                    continue;
                                }
                                else
                                {
                                    isSameGroup=false;
                                }

                                StringBuffer peptideLines = new StringBuffer();
                                List<ChroPeptide> peptideList = protein.getPeptideList();
                                List<ChroPeptide> tempPepList = new Vector<ChroPeptide>();

                                long[] sampleIntSumArr = new long[sampleList.size()];
                                
                                for(Iterator<ChroPeptide> pepItr = peptideList.iterator(); pepItr.hasNext(); )
                                {   
                                    ChroPeptide peptide = pepItr.next();                                
                                    
                                    totalCount++;

                                    
                                    List dataList = peptide.getDataList();                                                                               

                                    long[] intensitySumArr = new long[fileSize];
                                    //long[] samArr = new long[dataList.size()];
                                    //long[] refArr = new long[samArr.length];

                                    //double samIntSum = 0;
                                    //double refIntSum = 0;

                                    //int index=0;
                                    //int startIndex=0;
                                    //int endIndex=samArr.length-1;

                                    int startRange = Integer.parseInt(peptide.getStartRange());
                                    int endRange = Integer.parseInt(peptide.getEndRange());

                                    //LinearRegression reg = null;


                                    
                                    for(Iterator<ChroNonLabelData> dataItr=dataList.iterator(); dataItr.hasNext(); )
                                    {
                                        ChroNonLabelData eachData = dataItr.next();

                                        int[] scanNumArr = eachData.getScanNumArr();
                                        long[] intenArr = eachData.getIntensityArr();

                                        for(int i=0;i<scanNumArr.length;i++)
                                        {                                    
                                            if(scanNumArr[0]>=startRange && scanNumArr[0]<=endRange)
                                                intensitySumArr[i] += intenArr[i];
                                        }

                                    }
                                    
       
                                    peptide.setTotalIntArr(intensitySumArr);
                                    tempPepList.add(peptide);
                                    //tempPepCount++;                                

                                }

  //                              if(!noFilter && tempPepList.size()>3 && pValueSelect)
    //                                edu.scripps.pms.stats.GrubbsTest.filter(tempPepList, pValue);

                                //double averageRatio=0;
                                int peptideCount=0;
                                //double ratioSum=0;
                                

                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();

                                    if(!noFilter && each.isFilterOut())
                                        continue;

                                    //ratioSum += each.getSlope();
                                    peptideCount++;
                                    quantifiedCount++;
                                    
                                }

                                //System.out.println("pepcount==>>" + peptideCount);
                                //System.out.println(quantifiedCount + "\t");

                                //if(peptideCount>0)
                                //    averageRatio = ratioSum/peptideCount;

                                proteinSb.append("P\t"); 
                                proteinSb.append(protein.getLocus());
                                proteinSb.append("\t");
                                //proteinSb.append( averageRatio>0?format.format(averageRatio):"" );
                                proteinSb.append("\t");

                                double devSum=0;

                                StringBuffer pepSb = new StringBuffer();

                                //int tmpc=0;
                                
                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();

               //                     if(isUniquePeptide && !each.isUnique())
               //                         continue;

                                  //  tmpc++; if(tmpc>3) System.exit(0);
                                    
                                    
                                    if(noFilter || !each.isFilterOut())
                                    {
                                  //      double dev = each.getSlope()-averageRatio;
                                  //      devSum += dev*dev;    

                                        pepSb.append("S\t");
                                        pepSb.append(each.isUnique()?"U":"");
                                        pepSb.append("\t");
                                        pepSb.append(each.getSequence());
                                        pepSb.append("\t");
                                        
                                        long[] totalIntArr = each.getTotalIntArr();

                                        Hashtable<String, ChroXmlReader.Sample> sampleHt = new Hashtable<String, ChroXmlReader.Sample>();
                                        
                                        for(int i=0;i<totalIntArr.length;i++)
                                        {
                                            String sampleName = cr.getSampleName(i);
                                            
                                            ChroXmlReader.Sample sample = sampleHt.get(sampleName);
            
                                            if(null == sample)
                                            {
                                                sample = new ChroXmlReader.Sample(sampleName);
                                                sample.addIntensity(totalIntArr[i]);
                                                sampleHt.put(sampleName, sample);
                                            }
                                            else
                                            {
                                                sample.addIntensity(totalIntArr[i]);
                                            }                                
                                            
                                        //    for(int kk=0;kk<totalIntArr.length;kk++)
                                          //      System.out.println(kk + " " + totalIntArr[kk]);
                                        }
        
                                        int samIndex=0;
                                        for(Iterator<String> itr=cr.getSampleList().iterator(); itr.hasNext(); )
                                        {       
                                            String sampleName = itr.next();
                                            ChroXmlReader.Sample eachSam = sampleHt.get(sampleName);                                            
                                            
                                            //sampleIntSum += eachSam.getSumIntensity();
                                        
                                            sampleIntSumArr[samIndex++] +=eachSam.getAverage();
                                            
                                            pepSb.append( scientificFormat.format(eachSam.getSumIntensity()) ).append("\t");
                                            pepSb.append( scientificFormat.format(eachSam.getAverage()) ).append("\t");       
                                            
                                            int count=0;
                                            long[] intArr = new long[eachSam.getIntensityArr().size()];
                                            
                                  //          System.out.println("====>>" + eachSam.getIntensityArr().size());
                                            for(Iterator<Long> itrInt = eachSam.getIntensityArr().iterator(); itrInt.hasNext(); )
                                            {
                                                //itrInt.next();
                                                intArr[count++] = itrInt.next().longValue();                       
                                            }            
            
                                            pepSb.append( scientificFormat.format( STDev.getStdev(intArr) ) ).append("\t");
                                        }
                                            
                                        for(int i=0;i<totalIntArr.length;i++)
                                            pepSb.append(scientificFormat.format(totalIntArr[i])).append("\t");
                                        
                                        pepSb.append(each.getFileName()).append("\n");
                                    }
                                }

                                
                                if(peptideCount>1)
                                    proteinSb.append( format.format(Math.sqrt(devSum/(peptideCount-1))) );
                                else                                
                                    proteinSb.append("");

                                
                                //proteinSb.append(long[] sampleIntSumArr = new long[sampleList.size()];)
                                
                                for(int i=0;i<sampleIntSumArr.length;i++)
                                {
                                    proteinSb.append("\t");
                                    proteinSb.append( scientificFormat.format(peptideCount>0?(sampleIntSumArr[i]/peptideCount):0) );
                                }
                                
                                proteinSb.append("\t");
                                proteinSb.append(peptideCount>0?peptideCount:"");
                                proteinSb.append("\t");
                                proteinSb.append(protein.getSpectrumCount());
                                proteinSb.append("\t");
                                proteinSb.append(protein.getDescription());
                                proteinSb.append(peptideLines.toString());                
                                proteinSb.append("\n");

                                percent += eachSeg;
                                aJProgressBar.setValue((int)percent);

                                if( pepSb.length()<=0 )
                                    continue;

                                result.append(proteinSb.toString());
                                result.append(pepSb.toString());			    


                                //System.out.println(proteinSb.toString() + pepSb.toString());
                            }

                        }
                        catch(Exception e)  
                        {
                            isSuccessful=false;
                            errorMessage = e.getMessage();
                            e.printStackTrace();
                        }

                        final int finalTotalCount = totalCount;
                        final int finalQuantifiedCount = quantifiedCount;

                        SwingUtilities.invokeLater(new Runnable() {
                                public void run() {
                                progress.setVisible(false);

                                if(isSuccessful)
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    "Report file was successfully created." + 
                                    "\n\nTotal peptides : " + finalTotalCount + 
                                    "\nQuantified peptides : " + finalQuantifiedCount +
                                    "\nQuantification efficiency : " + twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 ) + " %",
                                    "Report file Creation", 
                                    JOptionPane.PLAIN_MESSAGE);
                                }                
                                else
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    errorMessage, 
                                    "Report file Creation", 
                                    JOptionPane.ERROR_MESSAGE);
                                }

                            }

                        }                    
                        );

                        p.print("H\t"); p.print("Total peptides\t"); p.println(finalTotalCount);
                        p.print("H\t"); p.print("Quantified peptides\t"); p.print(finalQuantifiedCount); p.print("\n");
                        p.print("H\t"); p.print("Quantification efficiency\t"); p.print(twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 )); p.print(" %\n");
                        p.print("H\t"); p.print("Correction Factor (Ln)\t"); p.println(correctFactorValue);                    
                        
                        p.print(result.toString());

                        if(null != p)
                            p.close();  


                    }

                };
                
                         
                System.out.println("nonlabeled...");
                //return;                         
            }
            else
            {*/
                t = new Thread() {
                    private boolean isSuccessful=true;
                    private String errorMessage="";
                    private PrintStream p = new PrintStream( new BufferedOutputStream(new FileOutputStream(file)));    
                    public void run() 
                    {
                        //parent.dispose();
                        //MainFrame frame = (MainFrame) parent.getOwner();
                        //head lines

			printHeader(p);
                        p.print("H\tcreated date\t"); p.println(new Date());
                        if(detSelect)
                        {    p.print("H\tDetermination Factor : "); p.println(detValue); }
                        else
                            p.println("H\tNo Determination Factor");

                        if(pValueSelect)
                        {    p.print("H\tOutlier pValue : "); p.println(pValue); }
                        else
                             p.println("H\tNo Outlier pValue");

                        if(filterFragmentIons)
                             p.println("H\tFilter Fragment Ions on MS/MS pValue : true");

                        p.print("H\tCorrection Factor Value : "); p.println(correctFactorValue);

                        p.print("H\tUnique Peptide only : "); p.println(isUniquePeptide?"true":"false");

                        //p.println("H\tPLINE\tLOCUS\tAVERAGE_RATIO\tSTANDARD_DEVIATION\tPEPTIDE_NUM\tSPEC_COUNT\tDESCRIPTION");
                        p.println("H\tPLINE\tLOCUS\tAVERAGE_RATIO\tSTANDARD_DEVIATION\tWEIGHTED_AVERAGE\tPEPTIDE_NUM\tSPEC_COUNT\tDESCRIPTION");
                        //p.println("H\tSLINE\tUNIQUE\tSEQUENCE\tRATIO\tREGRESSION_FACTOR\tDETERMINANT_FACTOR\tSAM_INT\tREF_INT\tSIGNAL_TO_NOISE_RATIO\tFILE_NAME");
                        p.println("H\tSLINE\tUNIQUE\tSEQUENCE\tRATIO\tREGRESSION_FACTOR\tDETERMINANT_FACTOR\tSAM_INT\tREF_INT\tFILE_NAME");

                        StringBuffer result = new StringBuffer();

                        int totalCount=0;
                        int quantifiedCount=0;
                        int tempaaa=0;

                        try {
                            //ChroProtein teP = list.get(0);

                            double eachSeg = (double)100/list.size();                
                            double percent =0;

                            StringBuffer proteinSb = new StringBuffer();
                            boolean isSameGroup=false;

                            for(Iterator<ChroProtein> proItr = list.iterator(); proItr.hasNext(); )
                            {                    
                                ChroProtein protein = proItr.next();            

                                if(!isSameGroup)
                                    proteinSb = new StringBuffer();

                                if(protein.isRedundant())
                                {
                                    isSameGroup = true;
                                    proteinSb.append("P\t"); 
                                    proteinSb.append(protein.getLocus());
                                    proteinSb.append("\n");

                                    continue;
                                }
                                else
                                {
                                    isSameGroup=false;
                                }

                                StringBuffer peptideLines = new StringBuffer();
                                List<ChroPeptide> peptideList = protein.getPeptideList();
                                List<ChroPeptide> tempPepList = new Vector<ChroPeptide>();

                                for(Iterator<ChroPeptide> pepItr = peptideList.iterator(); pepItr.hasNext(); )
                                {   
                                    ChroPeptide peptide = pepItr.next();                                
                                    totalCount++;
                                    List<ChroData> l = peptide.getDataList();

                                    long[] samArr = new long[l.size()];
                                    long[] refArr = new long[samArr.length];

                                    double samIntSum = 0;
                                    double refIntSum = 0;

                                    int index=0;
                                    int startIndex=0;
                                    int endIndex=samArr.length-1;

                                    int startRange = Integer.parseInt(peptide.getStartRange());
                                    int endRange = Integer.parseInt(peptide.getEndRange());

                                    LinearRegression reg = null;

                                    if( conf.getQuantLevel() == 2  && filterFragmentIons )
                                    {
                                        int pepLength = l.get(0).getResidueLength(); 

                                        long[][] bsTempArr = new long[pepLength][samArr.length];
                                        long[][] ysTempArr = new long[pepLength][samArr.length];
                                        long[][] brTempArr = new long[pepLength][samArr.length];
                                        long[][] yrTempArr = new long[pepLength][samArr.length];

                                        int[] scanNumArr = new int[samArr.length];

                                        for(Iterator<ChroData> itr=l.iterator(); itr.hasNext(); )
                                        {
                                            ChroData data = itr.next();

                                            long bsArr[] = data.getBsIntensity();
                                            long ysArr[] = data.getYsIntensity();
                                            long brArr[] = data.getBrIntensity();
                                            long yrArr[] = data.getYrIntensity();

                                            for(int i=0;i<bsArr.length;i++)
                                            {
                                                bsTempArr[i][index] = bsArr[i];
                                                ysTempArr[i][index] = ysArr[i];
                                                brTempArr[i][index] = brArr[i];
                                                yrTempArr[i][index] = yrArr[i];
                                            }

                                            scanNumArr[index] = data.getScanNum();

                                            int scanTemp = data.getScanNum();            
                                            if(startRange>=scanTemp)
                                                startIndex = index;
                                            if(endRange>=scanTemp)
                                                endIndex = index;

                                            index++;

                                        }

                                        FragIonList ionList = CalcUtil.getBestFragIons(bsTempArr, ysTempArr, brTempArr, yrTempArr, startIndex, endIndex, MAX_SHIFT);

                                        int tempIndex=0;

                                        for(Iterator<FragIon> itr=ionList.iterator(); itr.hasNext(); )
                                        {
                                            FragIon ion = itr.next();

                                            long[] tempSArr = ion.getSArr();
                                            long[] tempRArr = ion.getRArr();

                                            for(int i=0;i<tempSArr.length;i++)
                                            {
                                                samArr[i] += tempSArr[i];
                                                refArr[i] += tempRArr[i];
                                            }

                                            if(tempIndex==ionList.getBestIndex())
                                                break;

                                            tempIndex++;

                                        }

                                        samIntSum = 0;
                                        refIntSum = 0;

                                        endIndex = (endIndex!=0)?endIndex:samArr.length;
                                        for(int ii=startIndex;ii<=endIndex;ii++)
                                        {
                                            samIntSum += samArr[ii];
                                            refIntSum += refArr[ii];
                                        }

                                        reg = new LinearRegression(samArr, refArr, startIndex, endIndex, MAX_SHIFT);
                                    }
                                    else
                                    {

                                        for(Iterator<ChroData> dataItr = l.iterator(); dataItr.hasNext(); )
                                        {
                                            ChroData data = dataItr.next();

                                            samArr[index] = data.getSampleIntensity();
                                            refArr[index] = data.getRefIntensity();            

                                            int scanTemp = data.getScanNum();            
                                            if(startRange>=scanTemp)
                                                startIndex = index;
                                            if(endRange>=scanTemp)
                                                endIndex = index;

                                            index++;                                        
                                        }

                                        samIntSum = 0;
                                        refIntSum = 0;

                                        //System.out.println("sn===>>" + format.format(snRatio));

    //                                    System.out.println(noise + "\t" + signal);

                                        endIndex = (endIndex!=0)?endIndex:samArr.length;
                                        for(int ii=startIndex;ii<=endIndex;ii++)
                                        {
                                            samIntSum += samArr[ii];
                                            refIntSum += refArr[ii];
                                        }                                    

                                        reg = new LinearRegression(samArr, refArr, startIndex, endIndex, MAX_SHIFT);
                                    }

                                    double slope = reg.getSlope();
                                    double intercept = reg.getIntercept();

                                   // double snRatio = CalcUtil.calculateSNRatio(samArr, refArr, startIndex, endIndex);

                        //            System.out.println(snRatio);

                                    //if(!noFilter && reg.getCorr()<0)
                                    //    continue;

                                    //System.out.print(isUniquePeptide + "\t" + noFilter + "\t" + detSelect + "\t" + reg.getCorr()*reg.getCorr() + "\t");

                                    if(reg.getCorr()<0 && removeNegative)
                                        continue;

                                    if( detSelect && detValue>reg.getCorr()*reg.getCorr() )
                                        continue;

                                    if(isUniquePeptide && !peptide.isUnique())
                                        continue;                                

                                    if(removeNegative && peptide.isFilterOut())
                                        continue;

                                    //if( noFilter && reg.getCorr()<0)
                                    //    continue;

                                    //normalize the ratio in case overall ratios shifted 
                                    
                                    slope = Math.exp(Math.log(slope) + correctFactorValue);
                                    
                                    peptide.setSlope(slope);
                                    peptide.setCorr(reg.getCorr());
                                    peptide.setSamIntensity(samIntSum);
                                    peptide.setRefIntensity(refIntSum);
                                    //peptide.setSnRatio(snRatio);

                                    tempPepList.add(peptide);

                                    //tempPepCount++;                                
                                }

                                if(!noFilter && tempPepList.size()>3 && pValueSelect)
                                    edu.scripps.pms.stats.GrubbsTest.filter(tempPepList, pValue);

                                double averageRatio=0;
                                int peptideCount=0;
                                double ratioSum=0;

                                //System.out.println("");
                                //System.out.print(tempPepList.size() + "\t");

                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();

                                    if(!noFilter && each.isFilterOut())
                                        continue;

                                    ratioSum += each.getSlope();
                                    peptideCount++;
                                    quantifiedCount++;
                                }

                                //System.out.println("pepcount==>>" + peptideCount);
                                //System.out.println(quantifiedCount + "\t");

                                if(peptideCount>0)
                                    averageRatio = ratioSum/peptideCount;

                                proteinSb.append("P\t"); 
                                proteinSb.append(protein.getLocus());
                                proteinSb.append("\t");
                                proteinSb.append( averageRatio>0?format.format(averageRatio):"" );
                                proteinSb.append("\t");
                                
                                

                                double devSum=0;

                                StringBuffer pepSb = new StringBuffer();

                                WeightedProtein.ProteinModel pModel = new WeightedProtein.ProteinModel();
                                
                                for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
                                {
                                    ChroPeptide each = tempItr.next();

               //                     if(isUniquePeptide && !each.isUnique())
               //                         continue;

                                    if(noFilter || !each.isFilterOut())
                                    {
                                        double dev = each.getSlope()-averageRatio;
                                        devSum += dev*dev;    

                                        pepSb.append("S\t");
                                        pepSb.append(each.isUnique()?"U":"");
                                        pepSb.append("\t");
                                        pepSb.append(each.getSequence());
                                        pepSb.append("\t");

					if(each.getCorr()<0)
					{
					    pepSb.append( "0.0" );
					    pepSb.append("\t");
					    pepSb.append(format.format(each.getCorr()) );
					    pepSb.append("\t");
					    pepSb.append("0.0");
					}
					else
					{
					    pepSb.append( format.format(each.getSlope()) );
					    pepSb.append("\t");
					    pepSb.append(format.format(each.getCorr()) );
					    pepSb.append("\t");
					    pepSb.append(format.format(each.getCorr()*each.getCorr()) );
					}

                                        pepSb.append("\t");
                                        pepSb.append( each.getSamIntensity() );                                    
                                        pepSb.append("\t");
                                        pepSb.append( each.getRefIntensity() );                                    
                                        pepSb.append("\t");              
                                 //       pepSb.append( format.format(each.getSnRatio()) );
                                 //       pepSb.append("\t");
                                        pepSb.append(each.getFileName());
                                        pepSb.append("\n");
                                        
                                        
                                        
                                        double rsqrtLog = Math.log( each.getCorr()*each.getCorr() );
                                        double stdevLog = -0.84 * rsqrtLog + 0.43;
                                        double invStdev = Math.exp(stdevLog);

					//System.out.println("stdev===>>" + each.getCorr() + " " + stdevLog + " " + invStdev);
                                        
                                        //grap only valid ratio
                                        if(each.getSlope()>0)
                                        {
                                            pModel.add(invStdev, each.getSlope());                                            
                                           // double dev = each.getSlope()-averageRatio;
                                         //   devSum += dev*dev;    
                                        }

                                    }
                                }

                                if(peptideCount>1)
                                    proteinSb.append( format.format(Math.sqrt(devSum/(peptideCount-1))) );
                                else                                
                                    proteinSb.append("");

                                
                                proteinSb.append("\t");
                                proteinSb.append( format.format(pModel.getStandardWeightedAverage()) );
                                proteinSb.append("\t");
                                proteinSb.append(peptideCount>0?peptideCount:"");
                                proteinSb.append("\t");
                                proteinSb.append(protein.getSpectrumCount());
                                proteinSb.append("\t");                                
                                proteinSb.append(protein.getDescription());
                                proteinSb.append(peptideLines.toString());                
                                proteinSb.append("\n");

                                percent += eachSeg;
                                aJProgressBar.setValue((int)percent);

                                if( pepSb.length()<=0 )
                                    continue;

                                result.append(proteinSb.toString());
                                result.append(pepSb.toString());			    

                            }
                        }
                        catch(Exception e)  
                        {
                            isSuccessful=false;
                            errorMessage = e.getMessage();
                            e.printStackTrace();
                        }

                        final int finalTotalCount = totalCount;
                        final int finalQuantifiedCount = quantifiedCount;

                        SwingUtilities.invokeLater(new Runnable() {
                                public void run() {
                                progress.setVisible(false);
				progress.hide();

                                if(isSuccessful)
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    "Report file was successfully created." + 
                                    "\n\nTotal peptides : " + finalTotalCount + 
                                    "\nQuantified peptides : " + finalQuantifiedCount +
                                    "\nQuantification efficiency : " + twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 ) + " %",
                                    "Report file Creation", 
                                    JOptionPane.PLAIN_MESSAGE);
                                }                
                                else
                                {
                                JOptionPane.showMessageDialog(
                                    chroPanel, 
                                    errorMessage, 
                                    "Report file Creation", 
                                    JOptionPane.ERROR_MESSAGE);
                                }

                            }

                        }                    
                        );

                        p.print("H\t"); p.print("Total peptides\t"); p.println(finalTotalCount);
                        p.print("H\t"); p.print("Quantified peptides\t"); p.print(finalQuantifiedCount); p.print("\n");
                        p.print("H\t"); p.print("Quantification efficiency\t"); p.print(twoDigitFormat.format( (double)finalQuantifiedCount/finalTotalCount*100 )); p.print(" %\n");
                        p.print("H\t"); p.print("Correction Factor (Ln)\t"); p.println(correctFactorValue);                    
                        p.print(result.toString());

                        if(null != p)
                            p.close();  

                    }
                };
                
            //}
            

            

        
        t.start();
  
            
            
        } catch(IOException e)
        {
            System.out.println("Failed to write file" + e);
            if(null != progress)
	    {
                progress.setVisible(false);
		progress.hide();
	    }
            
            JOptionPane.showMessageDialog(this, e.toString(), e.toString(), JOptionPane.ERROR_MESSAGE);

            e.printStackTrace();
            
        }
    }
    
    private void reportItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_reportItemActionPerformed
        // TODO add your handling code here:
        
        Configuration conf = Configuration.getInstance();
        
        if(this.labeled)
        {
            ExportDialog dialog = new ExportDialog(this,true);                  
            dialog.pack();
            dialog.setLocationRelativeTo(this);
            dialog.setVisible(true);
            dialog.setResizable(false);            
        }
        else
        {
            ExportNonlabelDialog dialog = new ExportNonlabelDialog(this,true);                  
            dialog.pack();
            dialog.setLocationRelativeTo(this);
            dialog.setVisible(true);
            dialog.setResizable(false);

        }
        
    }//GEN-LAST:event_reportItemActionPerformed

    private void fileMenuActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fileMenuActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_fileMenuActionPerformed

    private void drawPepDist(String data)
    {
        try {
            
            pepDistPlot.clear(true);
            pepDistPlot.repaint();
            peptideDistParser.parse(null, data);
            peptideDistParser.postProcessing();
            
            //pepDistPlot._drawPoints();
        }
        catch(Exception e)
        {
            System.out.println("error==>> : " + e);
        }                
        
    }
    
    private void drawPlot(String data)
    {
        try {
            //this.plot = new Plot();
            //PlotBoxMLParser chroXmlParser = new PlotMLParser((Plot)plot);
            plot.clear(true);
            plot.repaint();
            chroXmlParser.parse(null, data);
            chroXmlParser.postProcessing();
        }
        catch(Exception e)
        {
            System.out.println("error==>> : " + e);
        }                
    }

    /****  Sample DATA ******
        xmlData = new StringBuffer();
        xmlData.append("<?xml version=\"1.0\" standalone=\"no\"?>");              
     xmlData.append("</plot>");
        xmlData.append("<title>Chromatogram</title>");
        xmlData.append("<xLabel>Scan Number</xLabel>");
        xmlData.append("<yLabel>Intensity</yLabel>");
        xmlData.append("<noGrid/>");    
        xmlData.append("<size width=\"550\" height=\"370\"/>");
- <xTicks>
  <tick label="50-60" position="50" /> 
  <tick label="60-70" position="60" /> 
  <tick label="70-80" position="70" /> 
  <tick label="80-90" position="80" /> 
  <tick label="90-100" position="90" /> 
  </xTicks>     
        xmlData.append("<dataset name=\"dmso\" marks=\"none\" connected=\"yes\" stems=\"no\">");    
        xmlData.append("<p x=\"221.724\" y=\"7719.56\"/>");
        xmlData.append("<p x=\"220.945\" y=\"7616.44\"/>");
        xmlData.append("<p x=\"220.168\" y=\"7822.69\"/>");
        xmlData.append("<p x=\"219.392\" y=\"8073.13\"/>");
        xmlData.append("<p x=\"131.194\" y=\"2519.17\"/>");
        xmlData.append("</dataset>");
        xmlData.append("</plot>");
     *
     *
     *****************************/   
    
    public void generateNonLabelData(ChroPeptide peptide)
    {
        generateNonLabelData(peptide, -1);
    }
    
    public void generateNonLabelData(ChroPeptide peptide, int selectId)
    {
                
        if(null == currentPeptide)
            return;
        
        if(null == peptide)
            peptide = currentPeptide;
        
        //System.out.println("fdsafadsfdsa");

        StringBuffer xmlData = new StringBuffer();
        xmlData.append("<?xml version=\"1.0\" standalone=\"no\"?>");   
        xmlData.append("<plot>");
        xmlData.append("<title>Chromatogram</title>");
        
        if(conf.isAlign())
            xmlData.append("<xLabel>Scan Number</xLabel>");
        else
            xmlData.append("<xLabel>Retention Time</xLabel>");
        
        xmlData.append("<yLabel>Intensity</yLabel>");

        int startRange =0;
        int endRange = 0;
        
        xmlData.append("<startRange>").append(peptide.getStartRange()).append("</startRange>");
        xmlData.append("<endRange>").append(peptide.getEndRange()).append("</endRange>");
        xmlData.append("<scanNum>").append(peptide.getScanNum()).append("</scanNum>");            

        startRange = Integer.parseInt(peptide.getStartRange());
        endRange = Integer.parseInt(peptide.getEndRange());
        
        xmlData.append("<grid/>");    
        
        //xmlData.append("<size width=\"590\" height=\"390\"/>");        

        int fileSize = cr.getFileList().size();
        StringBuffer ticks = new StringBuffer();
        StringBuffer[] bufferArr = new StringBuffer[fileSize];        
                
        ArrayList grayoutList = new ArrayList();
        for(int i=0;i<bufferArr.length;i++)
        {
            bufferArr[i] = new StringBuffer();
            bufferArr[i].append("<dataset name=\"").append(cr.getFileName(i)).append("\" marks=\"none\" connected=\"yes\" stems=\"no\">");                               

            if(selectId>=0 && selectId!=i)
                grayoutList.add(i);            
        }
        
        this.plot.setGrayOutList(grayoutList);
        
        ticks.append("<xTicks>");

        List dataList = peptide.getDataList();
        
                
        long[] intensitySumArr = new long[fileSize];
    
        if(cr.getQuantLevel() == 1)
        {
            for(Iterator<ChroNonLabelData> itr=dataList.iterator(); itr.hasNext(); )
            {
                ChroNonLabelData eachData = itr.next();

                int[] scanNumArr = eachData.getScanNumArr();
                long[] intenArr = eachData.getIntensityArr();


                //for(int i=0;i<intenArr.length;i++)
                //    System.out.print(scanNumArr[i] + " ");

                for(int i=0;i<scanNumArr.length;i++)
                {
                    bufferArr[i].append("<p x=\"");
                    bufferArr[i].append(scanNumArr[0]);
                    bufferArr[i].append("\" y=\"");
                    bufferArr[i].append(intenArr[i]);
                    bufferArr[i].append("\"/>");

                    if(scanNumArr[0]>=startRange && scanNumArr[0]<=endRange)
                    {
                        //System.out.println(intenArr[i]);
                        intensitySumArr[i] += intenArr[i];
    //                    System.out.println(intenArr[i]);
                    }

                }

                //System.out.println("");

                ticks.append("<tick label=\"");
                ticks.append(scanNumArr[0]);
                ticks.append("\" position=\"");
                ticks.append(scanNumArr[0]);
                ticks.append("\" />");                        
            }            
        }
        else if (cr.getQuantLevel() == 2)
        {
            for(Iterator<ChroNonLabelMSMSData> itr=dataList.iterator(); itr.hasNext(); )
            {
                ChroNonLabelMSMSData eachData = itr.next();

                int[] scanNumArr = eachData.getScanArr();
                long[] intenArr = eachData.getTotalIntArr();

                for(int i=0;i<scanNumArr.length;i++)
                {
                    bufferArr[i].append("<p x=\"");
                    bufferArr[i].append(scanNumArr[0]);
                    bufferArr[i].append("\" y=\"");
                    bufferArr[i].append(intenArr[i]);
                    bufferArr[i].append("\"/>");

                    if(scanNumArr[0]>=startRange && scanNumArr[0]<=endRange)
                    {
                        //System.out.println(intenArr[i]);
                        intensitySumArr[i] += intenArr[i];
                    }
                }

                ticks.append("<tick label=\"");
                ticks.append(scanNumArr[0]);
                ticks.append("\" position=\"");
                ticks.append(scanNumArr[0]);
                ticks.append("\" />");                        
            }

        }
        
        ticks.append("</xTicks>");
        
        String prevDir="";
        String curDir="";
                
        int rowCount = nonlabelTableModel.getRowCount();
                
        for(int i=0;i<rowCount;i++)
            nonlabelTableModel.removeRow(0); //note zero here                
        
        rowCount = nonlabelSummaryTableModel.getRowCount();
        for(int i=0;i<rowCount;i++)
            nonlabelSummaryTableModel.removeRow(0); //note zero here                
        
        
        //int rowCount = peptideTableModel.getRowCount(); 
        //for(int i=0;i<rowCount;i++)
          //  peptideTableModel.removeRow(0); //note zero here
        Hashtable<String, ChroXmlReader.Sample> sampleHt = new Hashtable<String, ChroXmlReader.Sample>();
        
        
        /*
        if(selectId>=0)
        {
                bufferArr[selectId].append("</dataset>");
                xmlData.append(bufferArr[selectId].toString());    
        }
        */
        for(int i=0;i<bufferArr.length;i++)
        {
          //  if(selectId<0 || selectId!=i)
            
            bufferArr[i].append("</dataset>");
            xmlData.append(bufferArr[i].toString());    

            //JLabel label = new JLabel(cr.getFileList().get(i));
            curDir = cr.getFileList().get(i);            
            String sampleName = cr.getSampleName(curDir);
            Vector vec = new Vector();            
            vec.add(sampleName);
            vec.add(curDir.substring(curDir.lastIndexOf(File.separator)+1));
            
            //we don't know if file path is generated from linux or window.
            if(curDir.startsWith("/"))
                vec.add(curDir.substring(0, curDir.lastIndexOf("/")));
            else
                vec.add(curDir.substring(0, curDir.lastIndexOf("\\")));
                        
            vec.add( this.scientificFormat.format(intensitySumArr[i]) );
            
            this.nonlabelTableModel.addRow(vec);
            
            ChroXmlReader.Sample sample = sampleHt.get(sampleName);
            
            if(null == sample)
            {
                sample = new ChroXmlReader.Sample(sampleName);
                sample.addIntensity(intensitySumArr[i]);
                sampleHt.put(sampleName, sample);
            }
            else
            {
                sample.addIntensity(intensitySumArr[i]);
            }
                       
            //for(int kk=0;kk<intensitySumArr.length;kk++)
              //  System.out.println(kk + " " + intensitySumArr[kk]);
        
        
            prevDir = curDir;            
        }   
            
        xmlData.append("</plot>");   
        
        this.plot.setScanNum(peptide.getScanNum());
        this.plot.setDtaStartRange( peptide.getDtaStartRange() );
        this.plot.setDtaEndRange( peptide.getDtaEndRange() );
        
        drawPlot(xmlData.toString());
        
        Hashtable<String, ChroXmlReader.Sample> sampleObjList = cr.getSampleObjList();
         
        for(Iterator<String> itr=cr.getSampleList().iterator(); itr.hasNext(); )
        {
            String sampleName = itr.next();
            
            //ChroXmlReader.Sample eachSam = sampleObjList.get(sampleName);
            ChroXmlReader.Sample eachSam = sampleHt.get(sampleName);            
                    
            //System.out.println("sum===>>" + sampleName + " " + eachSam.getSumIntensity());            
            
            Vector vec = new Vector();
            vec.add(sampleName);
            
            vec.add( this.scientificFormat.format(eachSam.getSumIntensity()) );
            vec.add( this.scientificFormat.format(eachSam.getAverage()) );
            //System.out.println("====" + eachSam.getIntensityArr().size());
            
            long[] intArr = new long[eachSam.getIntensityArr().size()];
            int count=0;
            for(Iterator<Long> itrInt = eachSam.getIntensityArr().iterator(); itrInt.hasNext(); )
            {
                //itrInt.next();
                intArr[count++] = itrInt.next().longValue();                   
            }            
            
            vec.add( this.scientificFormat.format( STDev.getStdev(intArr) ) );
            
            this.nonlabelSummaryTableModel.addRow(vec);
        }
        
    }
    
    public String chromXMLHeader(ChroPeptide peptide)
    {
        StringBuffer sb = new StringBuffer();
        sb.append("<?xml version=\"1.0\" standalone=\"no\"?>");   
        sb.append("<plot>");
        sb.append("<title>Chromatogram</title>");
        sb.append("<xLabel>Scan Number</xLabel>");
        sb.append("<yLabel>Intensity</yLabel>");
        
        sb.append("<startRange>").append(peptide.getStartRange()).append("</startRange>");
        sb.append("<endRange>").append(peptide.getEndRange()).append("</endRange>");
        sb.append("<scanNum>").append(peptide.getScanNum()).append("</scanNum>");
        
        sb.append("<grid/>");    
        
        return sb.toString();

    }
            
    public void generateDepData(ChroPeptide peptide)
    {
        if(null == peptide)
        peptide = currentPeptide;
        
        if(null == currentPeptide)
            return;
        
        
        List l = peptide.getDataList();
        StringBuffer xmlData = new StringBuffer();

        /*
        xmlData.append("<?xml version=\"1.0\" standalone=\"no\"?>");   
        xmlData.append("<plot>");
        xmlData.append("<title>Chromatogram</title>");
        xmlData.append("<xLabel>Scan Number</xLabel>");
        xmlData.append("<yLabel>Intensity</yLabel>");
*/
        xmlData.append(chromXMLHeader(peptide));
        
        /*
        xmlData.append("<startRange>").append(peptide.getStartRange()).append("</startRange>");
        xmlData.append("<endRange>").append(peptide.getEndRange()).append("</endRange>");
        xmlData.append("<scanNum>").append(peptide.getScanNum()).append("</scanNum>");
*/
        int startRange = Integer.parseInt(peptide.getStartRange());
        int endRange = Integer.parseInt(peptide.getEndRange());
        //System.out.println("====>>" + startRange+ " " + endRange); 
        
        //xmlData.append("<size width=\"590\" height=\"390\"/>");        

        StringBuffer sampleData = new StringBuffer();
        StringBuffer refData = new StringBuffer();
        StringBuffer ticks = new StringBuffer();
        sampleData.append("<dataset name=\"sample\" marks=\"none\" connected=\"yes\" stems=\"no\">");
        refData.append("<dataset name=\"reference\" marks=\"none\" connected=\"yes\" stems=\"no\">");    

        ticks.append("<xTicks>");
         
        long[] samArr = new long[l.size()];
        long[] refArr = new long[samArr.length];

        int index=0;
        int startIndex=0;
        int endIndex=0;
        
        for(Iterator<ChroData> itr=l.iterator(); itr.hasNext(); )
        {
            ChroData data = itr.next();

            ///rpark
            samArr[index] = data.getSampleIntensity();
            refArr[index] = data.getRefIntensity();            
            
            int scanTemp = data.getScanNum();            

            if(startRange>=scanTemp)
                startIndex = index;
            if(endRange>=scanTemp)
                endIndex = index;
            
            index++;
            
            //<tick label="90-100" position="90" />                     
            sampleData.append("<p x=\"");
            sampleData.append(data.getScanNum());                
            sampleData.append("\" y=\"");
            sampleData.append(data.getSampleIntensity());
            sampleData.append("\"/>");
            
            refData.append("<p x=\"");
            refData.append(data.getScanNum());
            refData.append("\" y=\"");
            refData.append(data.getRefIntensity());
            refData.append("\"/>");
            
            ticks.append("<tick label=\"");
            ticks.append(data.getScanNum());
            ticks.append("\" position=\"");
            ticks.append(data.getScanNum());
            ticks.append("\" />");            

        }
        
        LinearRegression reg = new LinearRegression(samArr, refArr, startIndex, (endIndex!=0)?endIndex:samArr.length, MAX_SHIFT);
        
        double slope = reg.getSlope();
        double intercept = reg.getIntercept();
       
        corrPlot.setData(refArr, samArr, startIndex, (endIndex!=0)?endIndex:samArr.length, slope, intercept, reg.getBestShift());
        corrPlot.clear(true);
        corrPlot.repaint();        
        correlationPanel.add(corrPlot);        
        
        //proteinRatioDistPanel.add(corrPlot);
                        
        //this.corrCoeffField.setText( format.format(reg.getCorr()) );
	if(reg.getCorr()<0)
        {
	    this.rrField.setText("N/A");	 
            this.areaRatioLogField.setText("N/A");
	    this.regressionRatioField.setText("N/A");
            this.areaRatioField.setText("N/A");                
            //this.snRatioField.setText("N/A");
        }
	else
        {            
	    this.rrField.setText( format.format(reg.getCorr()*reg.getCorr()));            
            this.areaRatioLogField.setText( format.format( Math.log(slope) ));
            this.regressionRatioField.setText( format.format(slope) );
            this.areaRatioField.setText( format.format(reg.getAreaRatio()) );
            //this.snRatioField.setText( format.format(snRatio) );
        }

        this.shiftField.setText( String.valueOf(reg.getBestShift()) );
        
        ticks.append("</xTicks>");
        sampleData.append("</dataset>");
        refData.append("</dataset>");

        xmlData.append(ticks.toString());
        xmlData.append(sampleData.toString());
        xmlData.append(refData.toString());

        xmlData.append("</plot>");                        
                    
        this.plot.setScanNum(peptide.getScanNum());
        this.plot.setDtaStartRange( peptide.getDtaStartRange() );
        this.plot.setDtaEndRange( peptide.getDtaEndRange() );
        
//        System.out.println(xmlData.toString());
        drawPlot(xmlData.toString());
        
    }
     
    private DataIndepModel calcFragIons(ChroPeptide peptide)
    {
        
        List l = peptide.getDataList();
        
        int startRange = Integer.parseInt(peptide.getStartRange());
        int endRange = Integer.parseInt(peptide.getEndRange());
        
        int pepLength = ((ChroData)l.get(0)).getResidueLength(); 
        
        long[] samArr = new long[l.size()];
        long[] refArr = new long[samArr.length];
        int[] scanNumArr = new int[samArr.length];

        int index=0;
        int startIndex=0;
        int endIndex=0;
        
        long[][] bsTempArr = new long[pepLength][samArr.length];
        long[][] ysTempArr = new long[pepLength][samArr.length];
        long[][] brTempArr = new long[pepLength][samArr.length];
        long[][] yrTempArr = new long[pepLength][samArr.length];
        
        for(Iterator<ChroData> itr=l.iterator(); itr.hasNext(); )
        {
            ChroData data = itr.next();

            long bsArr[] = data.getBsIntensity();
            long ysArr[] = data.getYsIntensity();
            long brArr[] = data.getBrIntensity();
            long yrArr[] = data.getYrIntensity();

            for(int i=0;i<bsArr.length;i++)
            {
                bsTempArr[i][index] = bsArr[i];
                ysTempArr[i][index] = ysArr[i];
                brTempArr[i][index] = brArr[i];
                yrTempArr[i][index] = yrArr[i];
            }

            scanNumArr[index] = data.getScanNum();
            
            int scanTemp = data.getScanNum();            
            if(startRange>=scanTemp)
                startIndex = index;
            if(endRange>=scanTemp)
                endIndex = index;
            
            index++;
            
        }
        
        DataIndepModel model = new DataIndepModel();
        model.startIndex = startIndex;
        model.endIndex = endIndex;
        
        model.samArr = samArr;
        model.refArr = refArr;
        model.scanNumArr = scanNumArr;
        
        model.bsTempArr = bsTempArr;
        model.ysTempArr = ysTempArr;
        model.brTempArr = brTempArr;
        model.yrTempArr = yrTempArr;
        
        return model;
        
        //
        //return ionList;
    }
    
    private class DataIndepModel
    {
        public int startIndex;
        public int endIndex;
        
        long[] samArr;
        long[] refArr;
        int[] scanNumArr;
        
        long[][] bsTempArr;
        long[][] ysTempArr;
        long[][] brTempArr;
        long[][] yrTempArr;
        
    }
    
    public void generateInDepFragData(ChroPeptide peptide)
    {   
        
        
        if(null == peptide)
        peptide = currentPeptide;
        
        if(null == currentPeptide)
            return;
        
        fragIonPanel.removeAll();        
        
        
        StringBuffer xmlData = new StringBuffer();

	xmlData.append(chromXMLHeader(peptide));

        
        //xmlData.append("<size width=\"590\" height=\"390\"/>");        

        StringBuffer sampleData = new StringBuffer();
        StringBuffer refData = new StringBuffer();
        StringBuffer ticks = new StringBuffer();
        sampleData.append("<dataset name=\"sample\" marks=\"none\" connected=\"yes\" stems=\"no\">");
        refData.append("<dataset name=\"reference\" marks=\"none\" connected=\"yes\" stems=\"no\">");    

        ticks.append("<xTicks>");
    
        
        DataIndepModel model = this.calcFragIons(peptide);
        
        int startIndex=model.startIndex;
        int endIndex=model.endIndex;
        long[] samArr = model.samArr;
        long[] refArr = model.refArr;
        int[] scanNumArr = model.scanNumArr;
        
//        FragIonList ionList = CalcUtil.getBestFragIons(bsTempArr, ysTempArr, brTempArr, yrTempArr, startIndex, endIndex, MAX_SHIFT);
        FragIonList ionList = CalcUtil.getBestFragIons(model.bsTempArr, model.ysTempArr, model.brTempArr, model.yrTempArr, model.startIndex, model.endIndex, MAX_SHIFT);
        
        
        //List<FragIon> ionList = CalcUtil.getBestFragIons(bsTempArr, ysTempArr, brTempArr, yrTempArr, startIndex, endIndex, MAX_SHIFT);

        int listSize = ionList.size();
        StringBuffer[] ionSb = new StringBuffer[(ionList.getBestIndex()+1)*2];
        //StringBuffer[] ionSb = new StringBuffer[listSize*2];
        int tempIndex=0;
        
        for(Iterator<FragIon> itr=ionList.iterator(); itr.hasNext(); )
        {
            FragIon ion = itr.next();

            ionSb[tempIndex*2] = new StringBuffer();
            ionSb[tempIndex*2+1] = new StringBuffer();
            ionSb[tempIndex*2].append("<dataset name=\"").append(ion.isBion()?"bSample":"ySample").append(ion.getIndex()).append("\" marks=\"none\" connected=\"yes\" stems=\"no\">");
            ionSb[tempIndex*2+1].append("<dataset name=\"").append(ion.isBion()?"bRef":"yRef").append(ion.getIndex()).append("\" marks=\"none\" connected=\"yes\" stems=\"no\">");

            long[] tempSArr = ion.getSArr();
            long[] tempRArr = ion.getRArr();

            String ionName = ion.isBion()?"b":"y";
            ionName += ion.getIndex();
            
            FragIonPlot fPlot = new FragIonPlot(ionName, tempSArr, tempRArr, startIndex, (endIndex!=0)?endIndex:tempSArr.length, true);
            fragIonPanel.add(fPlot, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0 + (tempIndex*60), 270, 60));                                    
        
            for(int i=0;i<tempSArr.length;i++)
            {
                samArr[i] += tempSArr[i];
                refArr[i] += tempRArr[i];

                ionSb[tempIndex*2].append("<p x=\"");
                ionSb[tempIndex*2].append(scanNumArr[i]);
                ionSb[tempIndex*2].append("\" y=\"");
                ionSb[tempIndex*2].append(tempSArr[i]);
                ionSb[tempIndex*2].append("\"/>");

                ionSb[tempIndex*2+1].append("<p x=\"");
                ionSb[tempIndex*2+1].append(scanNumArr[i]);
                ionSb[tempIndex*2+1].append("\" y=\"");
                ionSb[tempIndex*2+1].append(tempRArr[i]);
                ionSb[tempIndex*2+1].append("\"/>");
            }

            if(tempIndex==ionList.getBestIndex())
                break;

            tempIndex++;
        }

        // display low quality of fragions
        for(int i=tempIndex+1;i<listSize;i++)
        {
           FragIon ion = ionList.get(i);

            long[] tempSArr = ion.getSArr();
            long[] tempRArr = ion.getRArr();

            String ionName = ion.isBion()?"b":"y";
            ionName += ion.getIndex();
            
            FragIonPlot fPlot = new FragIonPlot(ionName, tempSArr, tempRArr, startIndex, (endIndex!=0)?endIndex:tempSArr.length, false);
            fragIonPanel.add(fPlot, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0 + (i*60), 270, 60));              
        }
        
        this.fragIonPanel.invalidate();
        this.fragIonPanel.validate();
        this.fragIonPanel.repaint();
        
        //this.sigToNoisePanel.removeAll();
        
        /*
        //SigNoisePlot sigPlot = new SigNoisePlot(this.sigToNoisePanel.getWidth(), this.sigToNoisePanel.getHeight(), ionList, tempIndex);
        sigPlot.setBackground(new Color(255, 255, 255)); 
        this.sigToNoisePanel.add(sigPlot);
        this.sigToNoisePanel.invalidate();
        this.sigToNoisePanel.validate();
        this.sigToNoisePanel.repaint();                
        */
        
        for(int i=0;i<scanNumArr.length;i++)
        {
            //<tick label="90-100" position="90" />                     
            sampleData.append("<p x=\"");
            sampleData.append(scanNumArr[i]);
            sampleData.append("\" y=\"");
            sampleData.append(samArr[i]);
            sampleData.append("\"/>");
            
            refData.append("<p x=\"");
            refData.append(scanNumArr[i]);
            refData.append("\" y=\"");
            refData.append(refArr[i]);
            refData.append("\"/>");
            
            ticks.append("<tick label=\"");
            ticks.append(scanNumArr[i]);
            ticks.append("\" position=\"");
            ticks.append(scanNumArr[i]);
            ticks.append("\" />");            
        }

        LinearRegression reg = new LinearRegression(samArr, refArr, startIndex, (endIndex!=0)?endIndex:samArr.length, MAX_SHIFT);
        
//        System.out.println("index222==>>" + startIndex + " " + endIndex + " " + MAX_SHIFT + " " + reg.getSlope());

//
//	           for(int ii=0;ii<samArr.length;ii++)
//		                  System.out.println(samArr[ii] + " " + refArr[ii]);
        
        double slope = reg.getSlope();
        double intercept = reg.getIntercept();
        
        corrPlot.setData(refArr, samArr, startIndex, (endIndex!=0)?endIndex:samArr.length, slope, intercept, reg.getBestShift());
        corrPlot.clear(true);
        corrPlot.repaint();        
        correlationPanel.add(corrPlot);     
        //proteinRatioDistPanel.add(corrPlot);
                       
	if(reg.getCorr()<0)
	{
	    this.rrField.setText("N/A");
            this.areaRatioLogField.setText("N/A");
	    this.regressionRatioField.setText("N/A");            
            this.areaRatioField.setText("N/A");            
	}
	else
	{
	    this.rrField.setText( format.format(reg.getCorr()*reg.getCorr()));
            this.areaRatioLogField.setText( format.format(Math.log(slope)) );
	    this.regressionRatioField.setText( format.format(slope) );
            this.areaRatioField.setText( format.format(reg.getAreaRatio()) );            
	}

        this.shiftField.setText( String.valueOf(reg.getBestShift()) );
        
        ticks.append("</xTicks>");
        sampleData.append("</dataset>");
        refData.append("</dataset>");

        xmlData.append(ticks.toString());
        xmlData.append(sampleData.toString());
        xmlData.append(refData.toString());

        PostOptions options = PostOptions.getInstance();
        if(options.isDisplayFragmentIons())
        {
            for(int i=0;i<ionSb.length;i++)
            {
                ionSb[i].append("</dataset>");
                xmlData.append(ionSb[i].toString());
                System.out.print(".");
            }    
        }
        
      
        xmlData.append("</plot>");                        
                    
        this.plot.setScanNum(peptide.getScanNum());
        this.plot.setDtaStartRange( peptide.getDtaStartRange() );
        this.plot.setDtaEndRange( peptide.getDtaEndRange() );
        
        //System.out.println("indepen" + xmlData.toString());
        drawPlot(xmlData.toString());
        
        System.out.println("done");
    }
    
    public void generateInDepData(ChroPeptide peptide)
    {
        if(null == peptide)
        peptide = currentPeptide;
        
        if(null == currentPeptide)
            return;
        
        
        StringBuffer xmlData = new StringBuffer();
        xmlData.append(chromXMLHeader(peptide));
        

        List l = peptide.getDataList();
        int startRange =0;
        int endRange = 0;
        
        startRange = Integer.parseInt(peptide.getStartRange());
        endRange = Integer.parseInt(peptide.getEndRange());
        int pepLength = ((ChroData)l.get(0)).getResidueLength(); 
        
        long[] samArr = new long[l.size()];
        long[] refArr = new long[samArr.length];

        
        
        //xmlData.append("<size width=\"590\" height=\"390\"/>");        

        StringBuffer sampleData = new StringBuffer();
        StringBuffer refData = new StringBuffer();
        StringBuffer ticks = new StringBuffer();
        sampleData.append("<dataset name=\"sample\" marks=\"none\" connected=\"yes\" stems=\"no\">");
        refData.append("<dataset name=\"reference\" marks=\"none\" connected=\"yes\" stems=\"no\">");    

        
        
        StringBuffer[] bufferArr = new StringBuffer[pepLength*4];
        for(int i=0;i<pepLength;i++)
        {
           bufferArr[i] = new StringBuffer();
           bufferArr[i].append("<dataset name=\"bSample").append(i).append("\" marks=\"none\" connected=\"yes\" stems=\"no\">");
        }
        for(int i=pepLength;i<pepLength*2;i++)
        {
           bufferArr[i] = new StringBuffer();
           bufferArr[i].append("<dataset name=\"ySample").append(i%pepLength).append("\" marks=\"none\" connected=\"yes\" stems=\"no\">");
        }
        for(int i=pepLength*2;i<pepLength*3;i++)
        {
           bufferArr[i] = new StringBuffer();
           bufferArr[i].append("<dataset name=\"bRef").append(i%pepLength).append("\" marks=\"none\" connected=\"yes\" stems=\"no\">");
        }
        for(int i=pepLength*3;i<pepLength*4;i++)
        {
           bufferArr[i] = new StringBuffer();
           bufferArr[i].append("<dataset name=\"yRef").append(i%pepLength).append("\" marks=\"none\" connected=\"yes\" stems=\"no\">");
        }
        
        ticks.append("<xTicks>");
         
        
        int index=0;
        int startIndex=0;
        int endIndex=0;
        
        for(Iterator<ChroData> itr=l.iterator(); itr.hasNext(); )
        {
            ChroData data = itr.next();

            long bsArr[] = data.getBsIntensity();
            long ysArr[] = data.getYsIntensity();
            long brArr[] = data.getBrIntensity();
            long yrArr[] = data.getYrIntensity();

            for(int i=0;i<bufferArr.length;i++)
            {
                bufferArr[i].append("<p x=\"");
                bufferArr[i].append(data.getScanNum());
                bufferArr[i].append("\" y=\"");

//                if(data.getScanNum() == 4731)
//                    System.out.println(bsArr[i%pepLength] + " " + ysArr[i%pepLength] + " " + brArr[i%pepLength] + " " + yrArr[i%pepLength]);

                switch( (int)(i/pepLength) )
                {
                    case 0:
                        bufferArr[i].append(bsArr[i%pepLength]);
                        break;
                    case 1:
                        bufferArr[i].append(ysArr[i%pepLength]);
                        break;
                    case 2:
                        bufferArr[i].append(brArr[i%pepLength]);
                        break;
                    case 3:
                        bufferArr[i].append(yrArr[i%pepLength]);
                        break;
                    default:
                        break;
                }

                bufferArr[i].append("\"/>");
            }

            samArr[index] = data.getSampleIntensity();
            refArr[index] = data.getRefIntensity();            
            
            //if( 1==cr.getDataDependency() )
            {
                int scanTemp = data.getScanNum();            
                if(startRange>=scanTemp)
                    startIndex = index;
                if(endRange>=scanTemp)
                    endIndex = index;
            }
            
            index++;
            
            //<tick label="90-100" position="90" />                     
            sampleData.append("<p x=\"");
            sampleData.append(data.getScanNum());                
            sampleData.append("\" y=\"");
            sampleData.append(data.getSampleIntensity());
            sampleData.append("\"/>");
            
            refData.append("<p x=\"");
            refData.append(data.getScanNum());
            refData.append("\" y=\"");
            refData.append(data.getRefIntensity());
            refData.append("\"/>");
            
            ticks.append("<tick label=\"");
            ticks.append(data.getScanNum());
            ticks.append("\" position=\"");
            ticks.append(data.getScanNum());
            ticks.append("\" />");            

        }
        
        LinearRegression reg = new LinearRegression(samArr, refArr, startIndex, (endIndex!=0)?endIndex:samArr.length, MAX_SHIFT);
        
        double slope = reg.getSlope();
        double intercept = reg.getIntercept();
        
        //for(int i=startIndex;i<=endIndex;i++)
        //    System.out.println("datapoint\t" + samArr[i] + "\t" + refArr[i]);
        
        corrPlot.setData(refArr, samArr, startIndex, (endIndex!=0)?endIndex:samArr.length, slope, intercept, reg.getBestShift());
        corrPlot.clear(true);
        corrPlot.repaint();        
        correlationPanel.add(corrPlot);        
        //proteinRatioDistPanel.add(corrPlot);        
                        
        //System.out.println("=========xcorr====>>" + reg.getCorr());
        //this.corrCoeffField.setText( format.format(reg.getCorr()) );

	if(reg.getCorr()<0)
	{
	    this.rrField.setText("N/A");
            this.areaRatioLogField.setText("N/A");
	    this.regressionRatioField.setText("N/A");
            this.areaRatioField.setText("N/A");
	}
	else
	{
	    this.rrField.setText( format.format(reg.getCorr()*reg.getCorr()));
            this.areaRatioLogField.setText( format.format( Math.log(slope) ));
	    this.regressionRatioField.setText( format.format(slope) );
            this.areaRatioField.setText( format.format(reg.getAreaRatio()) );
	}
	
        this.shiftField.setText( String.valueOf(reg.getBestShift()) );
        
        ticks.append("</xTicks>");
        sampleData.append("</dataset>");
        refData.append("</dataset>");

        xmlData.append(ticks.toString());
        xmlData.append(sampleData.toString());
        xmlData.append(refData.toString());

        PostOptions options = PostOptions.getInstance();
      
        if(options.isDisplayFragmentIons())
        {
            for(int i=0;i<bufferArr.length;i++)
            {
                bufferArr[i].append("</dataset>");
                xmlData.append(bufferArr[i].toString());
            }    
        }
        
        xmlData.append("</plot>");                        
                    
        this.plot.setScanNum(peptide.getScanNum());
        this.plot.setDtaStartRange( peptide.getDtaStartRange() );
        this.plot.setDtaEndRange( peptide.getDtaEndRange() );
        
        
//        System.out.println(xmlData.toString());
        drawPlot(xmlData.toString());
        
        System.out.println("done");
    }
            
    private void proteinSimpleTableKeyPressed(java.awt.event.KeyEvent evt) {
        
        if(evt.getKeyCode() != KeyEvent.VK_DOWN && evt.getKeyCode() != KeyEvent.VK_UP)
            return;
        
        JTable table = (JTable)evt.getSource();
        
        System.out.println("selected row" + table.getSelectedRow());
        
        int selectedRow=0;
        
        if( evt.getKeyCode() == KeyEvent.VK_DOWN ) {
            System.out.println("down");
            if( table.getSelectedRow()+1 >= table.getRowCount() )
                return;
        
            selectedRow = table.getSelectedRow()+1;
            this.currentProtein = list.get( selectedRow );
            
        } else if( evt.getKeyCode() == KeyEvent.VK_UP ) {
            System.out.println("up");
            if( table.getSelectedRow() <=0 )
                return;
            
            selectedRow = table.getSelectedRow()-1;
                    
            this.currentProtein = list.get( selectedRow );
        }  
                        
        proteinSimpleTableActionPerformed(table, selectedRow);
    }
    
    private void proteinSimpleTableMouseClicked(java.awt.event.MouseEvent evt) {                                          
                
        JTable table = (JTable)evt.getSource();
        
        currentProtein = list.get(table.getSelectedRow());
        
        proteinSimpleTableActionPerformed(table, table.getSelectedRow());
        
    }
    
    private void proteinSimpleTableActionPerformed(JTable table, int selectedRow)
    {
        if(null != table)         
        {
            for(int i=selectedRow;i<list.size();i++)
            {
                currentProtein = list.get(i);

                if(currentProtein.getPeptideList().size()>0)
                    break;
            }
        } 
        
        PostOptions options = PostOptions.getInstance();
                
        
        if(cr.getQuantLevel()==1)
            updatePeptideInfo();
        else if(cr.getQuantLevel()==2)
        {
            if(!cr.isLabeled() && null != cr.getFileList() && cr.getFileList().size()>1) //labeling free with multiple samples            
            {
                updateLabelFreeMS2PeptideInfo(table);
            }
            else
            {
                if(options.isFilterFragmentIons())
                    updateMS2PeptideFilterInfo(null, selectedRow);
                else
                    updatePeptideInfo();
                
            }
        }   
    }   
       
    //label free ms2 multiple samples
    private void updateLabelFreeMS2PeptideInfo()
    {
	updateLabelFreeMS2PeptideInfo(null);
    }

    //label free ms2 multiple samples
    private void updateLabelFreeMS2PeptideInfo(JTable table)
    {            
	if(null != table)            
	{
	    currentProtein = list.get(table.getSelectedRow());

	    for(int i=table.getSelectedRow();i<list.size();i++)
	    {
		currentProtein = list.get(i);

		if(currentProtein.getPeptideList().size()>0)
		    break;
	    }
	}

	List<ChroPeptide> peptideList = currentProtein.getPeptideList();
	List<ChroPeptide> tempPepList = new Vector<ChroPeptide>();

	int totalCount=0;

	for(Iterator<ChroPeptide> pepItr = peptideList.iterator(); pepItr.hasNext(); )
	{   
	    ChroPeptide peptide = pepItr.next();                                
	    totalCount++;

	    List l = peptide.getDataList();

	    long[] samArr = new long[l.size()];

//	    int index=0;
//	    int startIndex=0;
//	    int endIndex=samArr.length-1;

	    int startRange = Integer.parseInt(peptide.getStartRange());
	    int endRange = Integer.parseInt(peptide.getEndRange());

	    //normalize the ratio in case overall ratios shifted 
	    //peptide.setSamIntensity(samIntSum);

	    //peptide.setSnRatio(snRatio);

	    tempPepList.add(peptide);
	}
	//if(!noFilter && tempPepList.size()>3 && pValueSelect)
	//    edu.scripps.pms.stats.GrubbsTest.filter(tempPepList, pValue);

	//Remove all existing rows
	int rowCount = peptideTableModel.getRowCount(); 
	for(int i=0;i<rowCount;i++)
	    peptideTableModel.removeRow(0); //note zero here


	this.currentPeptide = (ChroPeptide)currentProtein.getPeptideList().get(0);

	ChroPeptide peptide;

        //peptide distribution panel
        /*
	StringBuffer pepDistSb = new StringBuffer();
	pepDistSb.append("<?xml version=\"1.0\" standalone=\"no\"?>");
	pepDistSb.append("<plot>");
	pepDistSb.append("<title>Peptide Ratio Distribution</title>");
	pepDistSb.append("<xLabel>Ln(Ratio)</xLabel>");
	pepDistSb.append("<yLabel>Determinant Factor(RxR)</yLabel>");
	pepDistSb.append("<noGrid/>");
	pepDistSb.append("<size width=\"550\" height=\"370\"/>");
	pepDistSb.append("<dataset name=\"dmso\" marks=\"none\" connected=\"no\" stems=\"no\">");
	pepDistSb.append("<p x=\"-1.0\" y=\"1.0\" />");
	pepDistSb.append("<p x=\"0.0\" y=\"1.0\" />");
	pepDistSb.append("<p x=\"1.0\" y=\"1.0\" />");

	pepDistPlot.clearData();
*/
	for(Iterator<ChroPeptide> itr= currentProtein.getPeptideList().iterator(); itr.hasNext(); ) 
	{
	    peptide = itr.next();   
	    peptideTableModel.addRow( peptide.getLabelFreePeptideData() );    

	    /*if(peptide.getSlope()>0)
	    {
		this.pepDistPlot.addData(Math.log(peptide.getSlope()), peptide.getCorr()*peptide.getCorr());
		pepDistSb.append("<p x=\"").append(Math.log(peptide.getSlope())).append("\" y=\"").append(peptide.getCorr()*peptide.getCorr()).append("\" />");
	    }  
             */          
	}
        
/*
	pepDistSb.append("</dataset>");
	pepDistSb.append("</plot>");

	//System.out.println(pepDistSb.toString());

	drawPepDist(pepDistSb.toString());
        */               

	peptideListTable.changeSelection(0, 0, false, false);//.set.setSelectionBackground(new Color(102, 102, 153)); 

	PostOptions options = PostOptions.getInstance();

	this.peptideListTable.repaint();                      
	this.selectQuantType();
	//this.peptidePanel.remove( irisPanel );

	peptidePanel.add( this.quanPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 63, 1394, -1) );
	this.peptidePanel.invalidate();
	this.peptidePanel.validate();
	this.peptidePanel.repaint();

	this.proteinLabel.setText( this.currentProtein.getDescription() );
    }
    
    private void updatePeptideInfo()
    {
        updatePeptideInfo(null);
    }
    
    private void updatePeptideInfo(JTable table)
    {
        updatePeptideInfo(table, -1, -1);
    }
    
    private void updatePeptideInfo(JTable table, int startRange, int endRange)
    {            
	if(null != table)            
	{
	    currentProtein = list.get(table.getSelectedRow());

            //System.out.println(currentProtein.getLocus() + " " + table.getSelectedRow());
	    for(int i=table.getSelectedRow();i<list.size();i++)
	    {
		currentProtein = list.get(i);

		if(currentProtein.getPeptideList().size()>0)
		    break;
	    }
	}

	List<ChroPeptide> peptideList = currentProtein.getPeptideList();
	List<ChroPeptide> tempPepList = new Vector<ChroPeptide>();

	int totalCount=0;

	for(Iterator<ChroPeptide> pepItr = peptideList.iterator(); pepItr.hasNext(); )
	{   
	    ChroPeptide peptide = pepItr.next();                                
	    totalCount++;

	    List l = peptide.getDataList();

	    long[] samArr = new long[l.size()];
	    long[] refArr = null;

	    if(cr.isLabeled())
		refArr = new long[samArr.length];
	    //System.out.println("cur protein1==>>" + currentProtein.getLocus() + " " + peptide.getSequence());


	    int index=0;
	    int startIndex=0;
	    int endIndex=samArr.length-1;

	    if(startRange<0 && endRange<0)
	    {
		startRange = Integer.parseInt(peptide.getStartRange());
		endRange = Integer.parseInt(peptide.getEndRange());
	    }

	    LinearRegression reg = null;

	    for(Iterator<ChroData> dataItr = l.iterator(); dataItr.hasNext(); )
	    {
		ChroData data = dataItr.next();

		samArr[index] = data.getSampleIntensity();

		if(cr.isLabeled())
		    refArr[index] = data.getRefIntensity();            

		int scanTemp = data.getScanNum();            
		if(startRange>=scanTemp)
		    startIndex = index;
		if(endRange>=scanTemp)
		    endIndex = index;

		index++;                                        
	    }

	    double samIntSum = 0;
	    double refIntSum = 0;

	    endIndex = (endIndex!=0)?endIndex:samArr.length;
	    for(int ii=startIndex;ii<=endIndex;ii++)
	    {
		samIntSum += samArr[ii];

		if(cr.isLabeled())
		    refIntSum += refArr[ii];
	    }                                    

	    if(cr.isLabeled())
	    {
		reg = new LinearRegression(samArr, refArr, startIndex, endIndex, MAX_SHIFT);
		double slope = reg.getSlope();
		double intercept = reg.getIntercept();
		slope = Math.exp(Math.log(slope));

		peptide.setSlope(slope);
		peptide.setCorr(reg.getCorr());    
		peptide.setRefIntensity(refIntSum);
	    }
            
	    //normalize the ratio in case overall ratios shifted 

	    peptide.setSamIntensity(samIntSum);

	    //peptide.setSnRatio(snRatio);

	    tempPepList.add(peptide);
	}
	//if(!noFilter && tempPepList.size()>3 && pValueSelect)
	//    edu.scripps.pms.stats.GrubbsTest.filter(tempPepList, pValue);

	double averageRatio=0;
	int peptideCount=0;
	double ratioSum=0;


	for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
	{
	    ChroPeptide each = tempItr.next();

	    //  if(!noFilter && each.isFilterOut())
	    //      continue;

	    ratioSum += each.getSlope();
	    peptideCount++;	    
	}


	if(peptideCount>0)
	    averageRatio = ratioSum/peptideCount;

	//proteinSb.append( averageRatio>0?format.format(averageRatio):"" );


	double devSum=0;


	for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
	{
	    ChroPeptide each = tempItr.next();

	    //if(noFilter || !each.isFilterOut())
	    {
		double dev = each.getSlope()-averageRatio;
		devSum += dev*dev;    
	    }
	}                      

	//Remove all existing rows
	int rowCount = peptideTableModel.getRowCount(); 
	for(int i=0;i<rowCount;i++)
	    peptideTableModel.removeRow(0); //note zero here


	this.currentPeptide = (ChroPeptide)currentProtein.getPeptideList().get(0);

	ChroPeptide peptide;

	StringBuffer pepDistSb = new StringBuffer();
	pepDistSb.append("<?xml version=\"1.0\" standalone=\"no\"?>");
	pepDistSb.append("<plot>");
	pepDistSb.append("<title>Peptide Ratio Distribution</title>");
	pepDistSb.append("<xLabel>Ln(Ratio)</xLabel>");
	pepDistSb.append("<yLabel>Determinant Factor(RxR)</yLabel>");
	pepDistSb.append("<noGrid/>");
	pepDistSb.append("<size width=\"550\" height=\"370\"/>");
	pepDistSb.append("<dataset name=\"dmso\" marks=\"none\" connected=\"no\" stems=\"no\">");
	pepDistSb.append("<p x=\"-1.0\" y=\"1.0\" />");
	pepDistSb.append("<p x=\"0.0\" y=\"1.0\" />");
	pepDistSb.append("<p x=\"1.0\" y=\"1.0\" />");

	pepDistPlot.clearData();

	for(Iterator<ChroPeptide> itr= currentProtein.getPeptideList().iterator(); itr.hasNext(); ) 
	{
	    peptide = itr.next();   
	    peptideTableModel.addRow( conf.isLabeling()?peptide.getPeptideData():peptide.getLabelFreePeptideData() );    
System.out.println("pept data===>>" + peptide.getPeptideData() + " " + conf.isLabeling());
String[] strArr = peptide.getPeptideData();
for(int ii=0;ii<strArr.length;ii++)
System.out.println(strArr[ii]);


	    if(peptide.getSlope()>0)
	    {
		this.pepDistPlot.addData(Math.log(peptide.getSlope()), peptide.getCorr()*peptide.getCorr());
		pepDistSb.append("<p x=\"").append(Math.log(peptide.getSlope())).append("\" y=\"").append(peptide.getCorr()*peptide.getCorr()).append("\" />");
	    }            
	}

	pepDistSb.append("</dataset>");
	pepDistSb.append("</plot>");

	//System.out.println(pepDistSb.toString());

	drawPepDist(pepDistSb.toString());

	peptideListTable.changeSelection(0, 0, false, false);//.set.setSelectionBackground(new Color(102, 102, 153)); 

	PostOptions options = PostOptions.getInstance();

	this.peptideListTable.repaint();                      
	this.selectQuantType();
	//this.peptidePanel.remove( irisPanel );

	peptidePanel.add( this.quanPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 63, 1394, -1) );
	this.peptidePanel.invalidate();
	this.peptidePanel.validate();
	this.peptidePanel.repaint();

	this.proteinLabel.setText( this.currentProtein.getDescription() );
    }
        
    private void updateMS2PeptideFilterInfo(JTable table, int selectedRow)
    {   
        if(null != table)         
        {
            currentProtein = list.get(selectedRow);
            
            
            for(int i=selectedRow;i<list.size();i++)
            {
                currentProtein = list.get(i);

                if(currentProtein.getPeptideList().size()>0)
                    break;
            }
        }
        
        List<ChroPeptide> peptideList = currentProtein.getPeptideList();
        List<ChroPeptide> tempPepList = new Vector<ChroPeptide>();
        
        int totalCount=0;

        
        for(Iterator<ChroPeptide> pepItr = peptideList.iterator(); pepItr.hasNext(); )
        {   
            ChroPeptide peptide = pepItr.next();                                
            totalCount++;
    
            DataIndepModel model = this.calcFragIons(peptide);
        
            int startIndex=model.startIndex;
            int endIndex=model.endIndex;
            long[] samArr = model.samArr;
            long[] refArr = model.refArr;
            int[] scanNumArr = model.scanNumArr;


            FragIonList ionList = CalcUtil.getBestFragIons(model.bsTempArr, model.ysTempArr, model.brTempArr, model.yrTempArr, model.startIndex, model.endIndex, MAX_SHIFT);
    
            int listSize = ionList.size();
            int tempIndex=0;
        
            for(Iterator<FragIon> itr=ionList.iterator(); itr.hasNext(); )
            {
                FragIon ion = itr.next();

                
                long[] tempSArr = ion.getSArr();
                long[] tempRArr = ion.getRArr();

                String ionName = ion.isBion()?"b":"y";
                ionName += ion.getIndex();
            
                
                for(int i=0;i<tempSArr.length;i++)
                {
                    samArr[i] += tempSArr[i];
                    refArr[i] += tempRArr[i];


                }

                if(tempIndex==ionList.getBestIndex())
                    break;

                tempIndex++;
            }

            // display low quality of fragions
            for(int i=tempIndex+1;i<listSize;i++)
            {
               FragIon ion = ionList.get(i);

                long[] tempSArr = ion.getSArr();
                long[] tempRArr = ion.getRArr();

                String ionName = ion.isBion()?"b":"y";
                ionName += ion.getIndex();

            }
        

            LinearRegression reg = new LinearRegression(samArr, refArr, startIndex, (endIndex!=0)?endIndex:samArr.length, MAX_SHIFT);
        
        
            double slope = reg.getSlope();
            double intercept = reg.getIntercept();

            
            
            double samIntSum = 0;
            double refIntSum = 0;

            

   
            for(int ii=startIndex;ii<=endIndex;ii++)
            {
                samIntSum += samArr[ii];
                refIntSum += refArr[ii];
            }                                    
           

            //normalize the ratio in case overall ratios shifted 
            slope = Math.exp(Math.log(slope));
            
            peptide.setSlope(slope);
            peptide.setCorr(reg.getCorr());
            peptide.setSamIntensity(samIntSum);
            peptide.setRefIntensity(refIntSum);
            //peptide.setSnRatio(snRatio);

            tempPepList.add(peptide);

            //tempPepCount++;                                
        //}
            
        }
	//if(!noFilter && tempPepList.size()>3 && pValueSelect)
            //    edu.scripps.pms.stats.GrubbsTest.filter(tempPepList, pValue);

            double averageRatio=0;
            int peptideCount=0;
            double ratioSum=0;


            for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
            {
                ChroPeptide each = tempItr.next();

              //  if(!noFilter && each.isFilterOut())
              //      continue;

                ratioSum += each.getSlope();
                peptideCount++;
                //quantifiedCount++;
            }

            
            if(peptideCount>0)
                averageRatio = ratioSum/peptideCount;

            //proteinSb.append( averageRatio>0?format.format(averageRatio):"" );

            
            double devSum=0;

//            StringBuffer pepSb = new StringBuffer();

            for(Iterator<ChroPeptide> tempItr=tempPepList.iterator(); tempItr.hasNext(); )
            {
                ChroPeptide each = tempItr.next();

//                     if(isUniquePeptide && !each.isUnique())
//                         continue;

                //if(noFilter || !each.isFilterOut())
                {
                    double dev = each.getSlope()-averageRatio;
                    devSum += dev*dev;    

                }
            }    
            
        
        //Remove all existing rows
        int rowCount = peptideTableModel.getRowCount(); 
        for(int i=0;i<rowCount;i++)
            peptideTableModel.removeRow(0); //note zero here


        this.currentPeptide = (ChroPeptide)currentProtein.getPeptideList().get(0);
            
        ChroPeptide peptide;
        
        
        StringBuffer pepDistSb = new StringBuffer();
        pepDistSb.append("<?xml version=\"1.0\" standalone=\"no\"?>");              
        pepDistSb.append("<plot>");    
        pepDistSb.append("<title>Peptide Ratio Distribution</title>");
        pepDistSb.append("<xLabel>Ln(Ratio)</xLabel>");
        pepDistSb.append("<yLabel>Determinant Factor(RxR)</yLabel>");
        pepDistSb.append("<noGrid/>");    
        pepDistSb.append("<size width=\"550\" height=\"370\"/>");        
        
        
        /*
        pepDistSb.append("<xTicks/>");
        pepDistSb.append("<tick label=\"-3.0\" position=\"-3.0\" />");
        pepDistSb.append("<tick label=\"-2.0\" position=\"-2.0\" />");
        pepDistSb.append("<tick label=\"-1.0\" position=\"-1.0\" />");
        pepDistSb.append("<tick label=\"0.0\" position=\"0.0\" />");
        pepDistSb.append("<tick label=\"1.0\" position=\"1.0\" />");
        pepDistSb.append("<tick label=\"2.0\" position=\"2.0\" />");
        pepDistSb.append("<tick label=\"3.0\" position=\"3.0\" />");
        pepDistSb.append("</xTicks>");
        
        /*
        pepDistSb.append("<yTicks>");
        pepDistSb.append("<tick label=\"50\" position=\"50\" />");
        pepDistSb.append("<tick label=\"60\" position=\"60\" />");
        pepDistSb.append("<tick label=\"70\" position=\"70\" />");
        pepDistSb.append("</yTicks>");
        */
       
        
        pepDistSb.append("<dataset name=\"dmso\" marks=\"none\" connected=\"no\" stems=\"no\">");    
        //pepDistSb.append("<p x=\"-3.0\" y=\"0.0\" />");
        //pepDistSb.append("<p x=\"-2.0\" y=\"1.0\" />");
        pepDistSb.append("<p x=\"-1.0\" y=\"1.0\" />");
        pepDistSb.append("<p x=\"0.0\" y=\"1.0\" />");
        pepDistSb.append("<p x=\"1.0\" y=\"1.0\" />");
        //pepDistSb.append("<p x=\"2.0\" y=\"1.0\" />");
        //pepDistSb.append("<p x=\"3.0\" y=\"1.0\" />");
        
        
        //sample xml
        //String str = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><plot><title>Paths</title><xLabel>Reference Chromatogram</xLabel><yLabel>Target Chromatogram</yLabel><noGrid /><size width=\"750\" height=\"750\" /><xTicks /><tick label=\"1678\" position=\"1678\" /><tick label=\"1311\" position=\"1311\" /><tick label=\"932\" position=\"932\" /><tick label=\"572\" position=\"572\" /><tick label=\"213\" position=\"213\" /><yTicks />" +
        //            "<tick label=\"1766\" position=\"1766\" /><tick label=\"1378\" position=\"1378\" /><tick label=\"1007\" position=\"1007\" /><tick label=\"617\" position=\"617\" /><tick label=\"226\" position=\"226\" /><dataset name=\"/home/rpark/001/nonlabel/IsotopeFree/SetB/rep1/092106_IsotopeFree_B-01_itms.ms1\" sample=\"SetB\" marks=\"none\" connected=\"yes\" stems=\"no\"><p x=\"2059\" y=\"2136\" /><p x=\"2058\" y=\"2135\" /><p x=\"2057\" y=\"2134\" /><p x=\"2056\" y=\"2133\" />" +
        //            "<p x=\"2055\" y=\"2133\" /><p x=\"2054\" y=\"2132\" /></dataset></plot>";
        
        pepDistPlot.clearData();
        
        for(Iterator<ChroPeptide> itr= currentProtein.getPeptideList().iterator(); itr.hasNext(); ) 
        {
            peptide = itr.next();   
            //peptideTableModel.addRow( peptide.getPeptideData() );    
            peptideTableModel.addRow( conf.isLabeling()?peptide.getPeptideData():peptide.getLabelFreePeptideData() );    
            
            System.out.println("slop==>>" + peptide.getSlope() + " " + peptide.getCorr() + " " + peptide.getCorr()*peptide.getCorr());
         
            if(peptide.getSlope()>0)
            {
                
                this.pepDistPlot.addData(Math.log(peptide.getSlope()), peptide.getCorr()*peptide.getCorr());
                
                pepDistSb.append("<p x=\"").append(Math.log(peptide.getSlope())).append("\" y=\"").append(peptide.getCorr()*peptide.getCorr()).append("\" />");
                
                
        //        pepDistSb.append("<p x=\"").append( Math.log(peptide.getSlope()) ).append("\" y=\"").append( peptide.getCorr()*peptide.getCorr() ).append("\"/>");
        
            }            
        }

        
        
        pepDistSb.append("</dataset>");
        pepDistSb.append("</plot>");
        
        drawPepDist(pepDistSb.toString());

        
        //if(currentProtein.getPeptideList().size()!=tempPepList.size())
        //    System.out.println("x");
        //else
        //    System.out.println("*");

        peptideListTable.changeSelection(0, 0, false, false);//.set.setSelectionBackground(new Color(102, 102, 153)); 
            
        PostOptions options = PostOptions.getInstance();

        this.peptideListTable.repaint();            
            
        if(!this.labeled && this.quantLevel==1)
        {
            generateNonLabelData(currentPeptide);
        }
        else if(this.isDataDependent)
            generateDepData(currentPeptide);
        else if(options.isFilterFragmentIons())
            generateInDepFragData(currentPeptide);
        else
            generateInDepData(currentPeptide);

        //this.peptidePanel.remove( irisPanel );
        peptidePanel.add( this.quanPanel, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 63, 1394, -1) );
        this.peptidePanel.invalidate();
        this.peptidePanel.validate();
        this.peptidePanel.repaint();
        
        this.proteinLabel.setText( this.currentProtein.getDescription() );
        
    }
    
    
    private void proteinTableMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_proteinTableMouseClicked
        // TODO add your handling code here:
        
        //double click
        if(evt.getClickCount() != 2)
            return;
        
        PostOptions options = PostOptions.getInstance();
        
        tabbedPanel.setSelectedIndex(1);
        tabbedPanel.setEnabledAt(1, true);
        JTable table = (JTable)evt.getSource();

        
        if (this.isChroFile){

            if(cr.getQuantLevel()==1)
            {
                updatePeptideInfo(table); 
            }
            else if(cr.getQuantLevel()==2)  
            {
                if(!cr.isLabeled() && null != cr.getFileList() && cr.getFileList().size()>1) //labeling free with multiple samples
                {
		    updateLabelFreeMS2PeptideInfo(table);
                }
                else //typical MRM experiment
                {
                    updatePeptideInfo(table);
                }
            }
    
        }
        else
        {
            for(int i=table.getSelectedRow();i<list.size();i++)
            {
                currentProtein = list.get(i);    
                
//                System.out.println( currentProtein.getPeptideList().size() + " " + list.size() + " " + table.getSelectedColumn());
                if(currentProtein.getPeptideList().size()>0)
                    break;
            }
            
            qualPanel.setCurrentProtein(currentProtein);            
        }
    }//GEN-LAST:event_proteinTableMouseClicked

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
	System.exit(0);

        // TODO add your handling code here:
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    public void dummyOpenChroFile()
    {
        Configuration conf = Configuration.getInstance();
        conf.setSimpleIndexGenerator(true);
        
        this.openChroFile("/home/rpark/001/census_chro.xml");
        
    }
    
    private void OpenChroFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OpenChroFileActionPerformed
        // TODO add your handling code here:
        Configuration conf = Configuration.getInstance();
        conf.setSimpleIndexGenerator(true);
        
        JFileChooser choose = new JFileChooser();
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Select Chro File");
        choose.addChoosableFileFilter( new SimpleFileNameFilter("xml", "Chro File") );

        if(currentDirectory != null && !"".equals(currentDirectory))
	    choose.setCurrentDirectory(new File(currentDirectory));

        int returnVal = choose.showOpenDialog(chroPanel);
        this.chroFile = choose.getSelectedFile();

        if(null==chroFile || returnVal == choose.CANCEL_OPTION)
            return;
       
        currentDirectory = chroFile.getAbsolutePath();
        currentDirectory = currentDirectory.substring(0, currentDirectory.lastIndexOf(File.separator));        

        filePathLabel.setText(chroFile.getAbsolutePath());
        
        cleanupProteinTableModel();
        
        this.openChroFile(chroFile.getAbsolutePath());
            
    }//GEN-LAST:event_OpenChroFileActionPerformed

    private void cleanupProteinTableModel()
    {
        chromatogramPanel.removeAll();
        
        int rowCount = proteinTableModel.getRowCount(); 
            for(int i=0;i<rowCount;i++)
                proteinTableModel.removeRow(0); //note zero here
        
        rowCount = peptideTableModel.getRowCount(); 
            for(int i=0;i<rowCount;i++)
                peptideTableModel.removeRow(0); //note zero here                        
    }
    
    private void resetBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetBtnActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_resetBtnActionPerformed

    public ArrayList getProteinList()
    {
        return list;
    }
    
    private void extractBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_extractBtnActionPerformed
        // TODO add your handling code here:       
        Configuration conf = Configuration.getInstance();
        conf.setSimpleIndexGenerator(false);
        
        final String isFull = quantModeRadioGrp.getSelection().getActionCommand();      
        
        final ChroProgressDialog chroProgress = new ChroProgressDialog(this, false);
        chroProgress.setLocationRelativeTo(this);
        chroProgress.setResizable(false);        
        chroProgress.setVisible(true);
        
        final long start = System.currentTimeMillis();
        System.out.println("start time==>>" + start );
        
        Thread t = new Thread()
        {
            boolean isSuccessful = false;
            
            public void run()
	    {   
		try {                    

		    ChroGenerator chro = new ChroGenerator(
			    chroProgress.getProgressBar(),
			    //chroProgress.getProgressText(),
			    null,
			    Integer.parseInt(scanBefore.getText()),
			    Integer.parseInt(scanAfter.getText()),
			    isotopeFileField.getText().trim(),
			    massTolerance
			    );
		    if( isFull.equals("f") ) //Full Scan
			chro.createFullscanXmlChro();
		    else //msms scan
			chro.createMsmsXmlChro(chroProgress);

		    isSuccessful = true;

		}catch(IOException e) {
		    e.printStackTrace();
		    JOptionPane.showMessageDialog(chroPanel, "Failed to generate a chro file: " + e, "Failed to generate a chro file", JOptionPane.ERROR_MESSAGE);                                        
		}catch(Exception e) {
		    e.printStackTrace();
		    JOptionPane.showMessageDialog(chroPanel, "Failed to generate a chro file: " + e, "Failed to generate a chro file", JOptionPane.ERROR_MESSAGE);                                        

		}


		SwingUtilities.invokeLater(new Runnable()
			{
			public void run()
			{
			chroProgress.setVisible(false);
			chroProgress.hide();

			//System.out.println("time =============>>" + (start-System.currentTimeMillis()));

			/*
			   if(isSuccessful)
			   {
			   JOptionPane.showMessageDialog(
			   chroPanel, 
			   "Chro file is successfully created", 
			   "Chro file Creation", 
			   JOptionPane.PLAIN_MESSAGE);
			   }
			 */
			}
			});
	    }
	};

        try {
            t.start();
        } catch(Exception e)
        {
            t = null;
            
            //chroProgress.setVisible(false);
        }
        
    }//GEN-LAST:event_extractBtnActionPerformed

    private void fileSelectBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fileSelectBtnActionPerformed
        // TODO add your handling code here:
        JFileChooser choose = new JFileChooser();
        choose.setMultiSelectionEnabled(false);
        choose.setDialogTitle("Select Isotope File");
        choose.addChoosableFileFilter( new SimpleFileNameFilter("ini", "Isotope File") );

        if(currentDirectory != null && !"".equals(currentDirectory))
	    choose.setCurrentDirectory(new File(currentDirectory));

        int returnVal = choose.showOpenDialog(chroPanel);
        File file = choose.getSelectedFile();

        isotopeFileField.setText(file.getAbsolutePath());
    }//GEN-LAST:event_fileSelectBtnActionPerformed

    public void changePeakArea(int startPeak, int endPeak)
    {
	int oldStartRange = Integer.parseInt(this.currentPeptide.getStartRange());
	int oldEndRange = Integer.parseInt(this.currentPeptide.getEndRange());

	if(startPeak == oldStartRange && endPeak== oldEndRange) 
	    return;

        this.currentPeptide.setStartRange(String.valueOf(startPeak));        
        this.currentPeptide.setEndRange(String.valueOf(endPeak));
        
        PostOptions options = PostOptions.getInstance();
        
        
        //non label
        if(!this.labeled)
        {
            if(this.quantLevel==1)
            {
                List l = currentPeptide.getDataList();

                updatePeptideInfo(); 
            }
            else if(cr.getQuantLevel() == 2)
            {
                List l = currentPeptide.getDataList();

                updateLabelFreeMS2PeptideInfo(); 
            }           
        }
        else if(this.isDataDependent)
        {
            List l = currentPeptide.getDataList();

            int startRange = startPeak;
            int endRange = endPeak;

            long[] samArr = new long[l.size()];
            long[] refArr = new long[samArr.length];

            int index=0;
            int startIndex=0;
            int endIndex=0;

            for(Iterator<ChroData> itr=l.iterator(); itr.hasNext(); )
            {
                ChroData data = itr.next();

                samArr[index] = data.getSampleIntensity();
                refArr[index] = data.getRefIntensity();            

                int scanTemp = data.getScanNum();            

                if(startRange>=scanTemp)
                    startIndex = index;
                if(endRange>=scanTemp)
                    endIndex = index;

                index++;
            }

            LinearRegression reg = new LinearRegression(samArr, refArr, startIndex, (endIndex!=0)?endIndex:samArr.length, MAX_SHIFT);

            double slope = reg.getSlope();
            double intercept = reg.getIntercept();

            corrPlot.setData(refArr, samArr, startIndex, (endIndex!=0)?endIndex:samArr.length, slope, intercept, reg.getBestShift());
            corrPlot.clear(true);
            corrPlot.repaint();        
            correlationPanel.add(corrPlot);        
            //proteinRatioDistPanel.add(corrPlot);        

            if(reg.getCorr()<0)
            {
                this.rrField.setText("N/A");	 
                this.areaRatioLogField.setText("N/A");
                this.regressionRatioField.setText("N/A");
                this.areaRatioField.setText("N/A");                        
            }
            else
            {
                this.rrField.setText( format.format(reg.getCorr()*reg.getCorr()));
                this.areaRatioLogField.setText( format.format( Math.log(slope) ));
                this.regressionRatioField.setText( format.format(slope) );
                this.areaRatioField.setText( format.format(reg.getAreaRatio()) );
            }

            this.shiftField.setText( String.valueOf(reg.getBestShift()) );
        }
        else if(options.isFilterFragmentIons())
	{
	    fragIonPanel.removeAll();        

	    List l = currentPeptide.getDataList();

	    int startRange =0;
	    int endRange = 0;

	    startRange = Integer.parseInt(currentPeptide.getStartRange());
	    endRange = Integer.parseInt(currentPeptide.getEndRange());

	    //StringBuffer sampleData = new StringBuffer();
	    //StringBuffer refData = new StringBuffer();
	    //StringBuffer ticks = new StringBuffer();

	    int pepLength = ((ChroData)l.get(0)).getResidueLength(); 

	    long[] samArr = new long[l.size()];
	    long[] refArr = new long[samArr.length];
	    int[] scanNumArr = new int[samArr.length];

	    int index=0;
	    int startIndex=0;
	    int endIndex=0;

	    long[][] bsTempArr = new long[pepLength][samArr.length];
	    long[][] ysTempArr = new long[pepLength][samArr.length];
	    long[][] brTempArr = new long[pepLength][samArr.length];
	    long[][] yrTempArr = new long[pepLength][samArr.length];

	    for(Iterator<ChroData> itr=l.iterator(); itr.hasNext(); )
	    {
		ChroData data = itr.next();

		long bsArr[] = data.getBsIntensity();
		long ysArr[] = data.getYsIntensity();
		long brArr[] = data.getBrIntensity();
		long yrArr[] = data.getYrIntensity();

		for(int i=0;i<bsArr.length;i++)
		{
		    bsTempArr[i][index] = bsArr[i];
		    ysTempArr[i][index] = ysArr[i];
		    brTempArr[i][index] = brArr[i];
		    yrTempArr[i][index] = yrArr[i];
		}

		scanNumArr[index] = data.getScanNum();

		int scanTemp = data.getScanNum();            
		if(startRange>=scanTemp)
		    startIndex = index;
		if(endRange>=scanTemp)
		    endIndex = index;

		index++;

	    }

	    FragIonList ionList = CalcUtil.getBestFragIons(bsTempArr, ysTempArr, brTempArr, yrTempArr, startIndex, endIndex, MAX_SHIFT);

	    int listSize = ionList.size();
	    int tempIndex=0;

	    for(Iterator<FragIon> itr=ionList.iterator(); itr.hasNext(); )
	    {
		FragIon ion = itr.next();

		long[] tempSArr = ion.getSArr();
		long[] tempRArr = ion.getRArr();

		String ionName = ion.isBion()?"b":"y";
		ionName += ion.getIndex();

		FragIonPlot fPlot = new FragIonPlot(ionName, tempSArr, tempRArr, startIndex, (endIndex!=0)?endIndex:tempSArr.length, true);
		fragIonPanel.add(fPlot, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0 + (tempIndex*60), 270, 60));                                    

		for(int i=0;i<tempSArr.length;i++)
		{
		    samArr[i] += tempSArr[i];
		    refArr[i] += tempRArr[i];

		}

		if(tempIndex==ionList.getBestIndex())
		    break;

		tempIndex++;
	    }

	    // display low quality of fragions
	    for(int i=tempIndex+1;i<listSize;i++)
	    {
		FragIon ion = ionList.get(i);

		long[] tempSArr = ion.getSArr();
		long[] tempRArr = ion.getRArr();

		String ionName = ion.isBion()?"b":"y";
		ionName += ion.getIndex();

		FragIonPlot fPlot = new FragIonPlot(ionName, tempSArr, tempRArr, startIndex, (endIndex!=0)?endIndex:tempSArr.length, false);
		fragIonPanel.add(fPlot, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0 + (i*60), 270, 60));              
	    }

	    this.fragIonPanel.invalidate();
	    this.fragIonPanel.validate();
	    this.fragIonPanel.repaint();

            
            /*
	    this.sigToNoisePanel.removeAll();

	    SigNoisePlot sigPlot = new SigNoisePlot(this.sigToNoisePanel.getWidth(), this.sigToNoisePanel.getHeight(), ionList, tempIndex);
	    sigPlot.setBackground(new Color(255, 255, 255)); 
	    this.sigToNoisePanel.add(sigPlot);
	    this.sigToNoisePanel.invalidate();
	    this.sigToNoisePanel.validate();
	    this.sigToNoisePanel.repaint();                
*/
	    LinearRegression reg = new LinearRegression(samArr, refArr, startIndex, (endIndex!=0)?endIndex:samArr.length, MAX_SHIFT);

	    double slope = reg.getSlope();
	    double intercept = reg.getIntercept();

	    corrPlot.setData(refArr, samArr, startIndex, (endIndex!=0)?endIndex:samArr.length, slope, intercept, reg.getBestShift());
	    corrPlot.clear(true);
	    corrPlot.repaint();        
	    correlationPanel.add(corrPlot);        
            //proteinRatioDistPanel.add(corrPlot);        

	    if(reg.getCorr()<0)
	    {
		this.rrField.setText("N/A");
                this.areaRatioLogField.setText("N/A");
		this.regressionRatioField.setText("N/A");
		this.areaRatioField.setText("N/A");            
	    }
	    else
	    {
		this.rrField.setText( format.format(reg.getCorr()*reg.getCorr()));
                this.areaRatioLogField.setText( format.format( Math.log(slope) ));
		this.regressionRatioField.setText( format.format(slope) );
		this.areaRatioField.setText( format.format(reg.getAreaRatio()) );            
	    }

	    this.shiftField.setText( String.valueOf(reg.getBestShift()) );



	    this.plot.setScanNum(currentPeptide.getScanNum());
	    this.plot.setDtaStartRange( currentPeptide.getDtaStartRange() );
	    this.plot.setDtaEndRange( currentPeptide.getDtaEndRange() );

	    //System.out.println(xmlData.toString());
	    //drawPlot(xmlData.toString());
	}
        else
	{
	    List l = currentPeptide.getDataList();
	    StringBuffer xmlData = new StringBuffer();

	    int startRange =0;
	    int endRange = 0;

	    startRange = Integer.parseInt(currentPeptide.getStartRange());
	    endRange = Integer.parseInt(currentPeptide.getEndRange());

	    int pepLength = ((ChroData)l.get(0)).getResidueLength(); 

	    long[] samArr = new long[l.size()];
	    long[] refArr = new long[samArr.length];

	    int index=0;
	    int startIndex=0;
	    int endIndex=0;

	    for(Iterator<ChroData> itr=l.iterator(); itr.hasNext(); )
	    {
		ChroData data = itr.next();

		long bsArr[] = data.getBsIntensity();
		long ysArr[] = data.getYsIntensity();
		long brArr[] = data.getBrIntensity();
		long yrArr[] = data.getYrIntensity();

		samArr[index] = data.getSampleIntensity();
		refArr[index] = data.getRefIntensity();            

		//if( 1==cr.getDataDependency() )
		{
		    int scanTemp = data.getScanNum();            
		    if(startRange>=scanTemp)
			startIndex = index;
		    if(endRange>=scanTemp)
			endIndex = index;
		}

		index++;
	    }

	    LinearRegression reg = new LinearRegression(samArr, refArr, startIndex, (endIndex!=0)?endIndex:samArr.length, MAX_SHIFT);

	    double slope = reg.getSlope();
	    double intercept = reg.getIntercept();

	    corrPlot.setData(refArr, samArr, startIndex, (endIndex!=0)?endIndex:samArr.length, slope, intercept, reg.getBestShift());
	    corrPlot.clear(true);
	    corrPlot.repaint();        
	    correlationPanel.add(corrPlot);        
            //proteinRatioDistPanel.add(corrPlot);        

	    if(reg.getCorr()<0)
	    {
		this.rrField.setText("N/A");
                this.areaRatioLogField.setText("N/A");
		this.regressionRatioField.setText("N/A");
		this.areaRatioField.setText("N/A");
	    }
	    else
	    {
		this.rrField.setText( format.format(reg.getCorr()*reg.getCorr()));
                this.areaRatioLogField.setText( format.format( Math.log(slope) ));
		this.regressionRatioField.setText( format.format(slope) );
		this.areaRatioField.setText( format.format(reg.getAreaRatio()) );
	    }

	    this.shiftField.setText( String.valueOf(reg.getBestShift()) );
	    this.plot.setScanNum(currentPeptide.getScanNum());
	    this.plot.setDtaStartRange( currentPeptide.getDtaStartRange() );
	    this.plot.setDtaEndRange( currentPeptide.getDtaEndRange() );

	}
	    
        
        /*
         *
        
        JTable table = (JTable)evt.getSource();
        
        ChroPeptide peptide=null;
        
        if( evt.getKeyCode() == KeyEvent.VK_DOWN )
        {
            if( table.getSelectedRow()+1 >= pepSize )
                return;
            
            peptide = (ChroPeptide)currentProtein.getPeptideList().get( table.getSelectedRow()+1 );
        } 
        else if( evt.getKeyCode() == KeyEvent.VK_UP )
        {
            if( table.getSelectedRow() <=0 )
                return;
            
            peptide = (ChroPeptide)currentProtein.getPeptideList().get( table.getSelectedRow()-1 );
        }
        
        if(null==peptide) return;
        
        */
    }
    
    /**
     * @param args the command line arguments

    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new RelExFileFilter().setVisible(true);
            }
        });
    }
     */    
    /*
     *new javax.swing.table.DefaultTableModel(        
    new Object [][] {
        {"fdsa", null, null, null, null, null, null, null},
        {null, "fdsa", null, null, null, null, null, null},
        {null, null, null, null, null, null, null, null},
        {null, null, null, null, null, null, null, null}
        },
    new String [] {
        "Locus", "Sequence Count", "Spectrum Count", "Sequence Coverage", "Length", "MolWt", "pI", "Description"
    }
) {
    Class[] types = new Class [] {
        java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class, java.lang.Object.class
    };
    boolean[] canEdit = new boolean [] {
        false, true, true, true, true, true, true, true
    };

    public Class getColumnClass(int columnIndex) {
        return types [columnIndex];
    }

    public boolean isCellEditable(int rowIndex, int columnIndex) {
        return canEdit [columnIndex];
    }
}*/
   
    
    
    private DefaultTableModel proteinTableModel = 
        new DefaultTableModel( CensusConstants.PROTEIN_COLUMNS, 0 ) 
    {
        public boolean isCellEditable(int row, int column)
        {
          return false;
        }        
    };
    
    private DefaultTableModel proteinSimpleTableModel = 
        new DefaultTableModel( CensusConstants.PROTEIN_SIMPLE_COLUMNS, 0 ) 
    {
        public boolean isCellEditable(int row, int column)
        {
          return false;
        }        
    };
    
    //Unique\tFile Name\tScan Num\tSequence\tXCorr\tDentaCN\tCharge
    //private final String [] PEPTIDE_COLUMNS = {"Unique", "File Name", "Scan Num", "Sequence", "XCorr", "DeltCN", "Charge", };
    Configuration conf = Configuration.getInstance();
    
    private DefaultTableModel peptideTableModel = 
        new DefaultTableModel( conf.isLabeling()?CensusConstants.PEPTIDE_COLUMNS:CensusConstants.PEPTIDE_LABEL_FREE_COLUMNS, 0 ) 
    {
        public boolean isCellEditable(int row, int column)
        {
          return false;
        }        
    };

    public void setCurrentDirectory(File file)
    {
        this.currentDirectory = file.getAbsolutePath();
    }
    
    public String getCurrentDirectory()
    {
        return this.currentDirectory;
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem alignSpectra;
    private javax.swing.JTextField areaRatioField;
    private javax.swing.JTextField areaRatioLogField;
    private javax.swing.JLabel chorNoteLabel1;
    private javax.swing.JLabel chroNoteLabel2;
    private javax.swing.JPanel chroPanel;
    private javax.swing.JPanel chromatogramPanel;
    private javax.swing.JMenuItem confItem;
    private javax.swing.JPanel correlationPanel;
    private javax.swing.JButton export;
    private javax.swing.JButton extractBtn;
    private javax.swing.JPanel extractPanel;
    private javax.swing.ButtonGroup extractRadioGrp;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JLabel filePathLabel;
    private javax.swing.JButton fileSelectBtn;
    private javax.swing.JButton filterBtn;
    private javax.swing.JPanel fragIonPanel;
    private javax.swing.JScrollPane fragIonScrollPanel;
    private javax.swing.JRadioButton fullMassScan;
    private javax.swing.JTextField isotopeFileField;
    private javax.swing.JLabel isotopeLabel;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JCheckBox jCheckBox2;
    private javax.swing.JCheckBox jCheckBox3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JRadioButton jRadioButton1;
    private javax.swing.JRadioButton jRadioButton2;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSplitPane jSplitPane;
    private javax.swing.JTextField jTextField5;
    private javax.swing.JTextField jTextField6;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JPanel mainPanel;
    private javax.swing.JLabel measuredRatioLabel;
    private javax.swing.JLabel measuredRatioLabel1;
    private javax.swing.JMenuItem mergeItem;
    private javax.swing.JMenuItem mrmCsv;
    private javax.swing.JRadioButton msmsScan;
    private javax.swing.JButton open;
    private javax.swing.JMenuItem openItem;
    private javax.swing.JMenuItem openSpectra;
    private javax.swing.JMenuItem optionItem;
    private javax.swing.JPanel paramPanel;
    private javax.swing.JTabbedPane pepTabbedPanel;
    private javax.swing.JScrollPane peptideList;
    private javax.swing.JPanel peptideListBox;
    private javax.swing.JPanel peptidePanel;
    private javax.swing.JPanel proteinInfoPanel;
    private javax.swing.JLabel proteinLabel;
    private javax.swing.JScrollPane proteinListPanel;
    private javax.swing.JPanel proteinPanel;
    private javax.swing.JScrollPane proteinSimplePane;
    private javax.swing.JTable proteinTable;
    private javax.swing.JPanel quanPanel;
    private javax.swing.ButtonGroup quantModeRadioGrp;
    private javax.swing.JTextField regressionRatioField;
    private javax.swing.JMenuItem reportItem;
    private javax.swing.JButton resetBtn;
    private javax.swing.JTextField rrField;
    private javax.swing.JMenuItem runItem;
    private javax.swing.JMenu runMenu;
    private javax.swing.JMenuItem runNonLabel;
    private javax.swing.JButton save;
    private javax.swing.JTextField scanAfter;
    private javax.swing.JTextField scanBefore;
    private javax.swing.JButton searchBtn;
    private javax.swing.JTextField searchField;
    private javax.swing.JTextField shiftField;
    private javax.swing.JLabel shiftLabel;
    private javax.swing.JTabbedPane tabbedPanel;
    private javax.swing.JMenu toolMenu;
    private javax.swing.JLabel welcomeLabel;
    // End of variables declaration//GEN-END:variables
    //private List<Element> list;
    
    private javax.swing.JTable proteinSimpleTable;
    private javax.swing.JTable peptideListTable;

    public javax.swing.JPanel getProteinPanel()
    {
        return this.proteinPanel;
        
    }
    
    private ArrayList<ChroProtein> list;
    
    private BaseChroPlot plot;
    private PeptideDistPlot pepDistPlot;
    
    private CorrelationPlot corrPlot;
    private StringBuffer xmlData;
    private ChroProtein currentProtein;
    private PlotBoxMLParser chroXmlParser;
    private PlotMLParser peptideDistParser;
    
    private final int INTEGRATION_WINDOW = 15;
    private final double PEAK_THRESHOLD = 0.15;
    private final int PEAK_SCAN_BEFORE = 4;
    private final int PEAK_SCAN_AFTER = 4;
    private ChroXmlReader cr;
    
    private String currentDirectory="";
    private int MAX_SHIFT=0;
    private DecimalFormat format = new DecimalFormat("0.000");
    private DecimalFormat twoDigitFormat = new DecimalFormat("0.00");       
    private NumberFormat scientificFormat = new DecimalFormat("0.###E0");
    
    private float massTolerance = 0.3f;

    //private PostOptions options = new PostOptions();
    
    private ChroPeptide currentPeptide=null;
    private boolean isDataDependent;

    /**************** experiment Type *********/
    private int experimentType=0;

    private int quantLevel=1; //default it is for ms1
    private boolean labeled=true; //default it is labeled

    private IrisPanel irisPanel=null;
    private Hashtable ht=null; //indexed Hashtable
    private File chroFile=null;
    private File specFile=null;

    private int searchIndex = 0;

    private DTASelectFilterReader dtaReader;
    private boolean isChroFile = true;

    private QualificationPanel qualPanel = new QualificationPanel();

    private JPanel nonLabelPanel = new JPanel();
    private JPanel nonLabelSummaryPanel = new JPanel();
    
    //private JTextArea nonlabelText = new JTextArea();
    private JScrollPane nonlabelScrollPane = new JScrollPane();
    private JScrollPane nonlabelSummaryScrollPane = new JScrollPane();
    
    private DefaultTableModel nonlabelTableModel = 
        new DefaultTableModel( CensusConstants.NONLABEL_COLUMNS, 0 ) 
    {
        public boolean isCellEditable(int row, int column)
        {
          return false;
        }        
    };
    
    private DefaultTableModel nonlabelSummaryTableModel = 
        new DefaultTableModel( CensusConstants.NONLABEL_SUMMARY_COLUMNS, 0 ) 
    {
        public boolean isCellEditable(int row, int column)
        {
          return false;
        }        
    };
    
    
    private JTable nonlabelTable = new JTable();      
    private JTable nonlabelSummaryTable = new JTable();
    private JPanel proteinRatioDistPanel = new JPanel();    
        
    /**************** Configuration parameters ***************/
      
}
