/*
 * ChroGenerator.java
 *
 * Created on March 21, 2005, 10:22 AM
 */

package edu.scripps.pms.census;

import java.util.*;
import java.text.DecimalFormat;
import java.io.*;
import javax.swing.JProgressBar;
import javax.swing.JTextArea;

import edu.scripps.pms.util.io.*;
import edu.scripps.pms.util.spectrum.*;
        
import edu.scripps.pms.util.dtaselect.Protein;
import edu.scripps.pms.util.dtaselect.Peptide;
import edu.scripps.pms.census.model.IsotopeTable;

import edu.scripps.pms.census.io.*;
import edu.scripps.pms.census.io.SpecRangeGenerator;
import edu.scripps.pms.census.model.SpecRange;
import edu.scripps.pms.census.tools.Formatter;

import edu.scripps.pms.census.util.*;
import edu.scripps.pms.census.ElementComposition;

import edu.scripps.pms.census.util.RelExFileFilter;
import edu.scripps.pms.census.hash.*;
import edu.scripps.pms.census.conf.Configuration;
import edu.scripps.pms.census.exception.*;

import gnu.trove.TDoubleArrayList;
import gnu.trove.TIntLongHashMap;
import gnu.trove.TIntDoubleHashMap;

import org.jdom.*;
import org.jdom.output.*;
import org.jdom.input.*;

import java.io.*;

import edu.scripps.pms.census.model.*;
import edu.scripps.pms.census.model.mrm.*;
import scripts.mrm.*;


/**
 *
 * @author rpark
 * @version $Id: ChroGenerator.java,v 1.39 2010/02/24 20:50:51 rpark Exp $
 */
public class ChroGenerator {
    private int scanBefore;
    private int scanAfter;
    private String isotopeFile;
    //private String dtaSelectFilterFile = "DTASelect-filter.txt";
    //private String dtaSelectFile = "DTASelect.txt";
    
    private String filePath = null;
    //private JProgressBar bar;
    //private JTextArea text;
    //private String newline = "\n";
    public static final String CENSUS_CONFIG = "census_config.xml";
    //private final String INDEX_FILE = "index";
    private final double PROTON_MASS = 1.00728; 

    private double massTolerance;
    private static Configuration conf;
    private DecimalFormat formatter = new DecimalFormat("0.000");
    
    private Element confRootEle = null;
    
    private String refMS1File;
    private String[] targetMS1Files;
    private int[][][] pathArray;

    private static ChroProgressDialog progress;
    

    private long startTime;

    public ChroGenerator() {
	startTime = System.currentTimeMillis();
    }
    
    /** Creates a new instance of ChroGenerator. To be deprecated. */
    public ChroGenerator(
            JProgressBar bar,
            JTextArea text,
            int scanBefore, 
            int scanAfter,
            String isotopeFile,
            double massTolerance
            ) throws IOException
    {
	startTime = System.currentTimeMillis();
        //this.text = text;
        this.scanBefore = scanBefore;
        this.scanAfter = scanAfter;
        this.isotopeFile = isotopeFile;
        this.filePath = isotopeFile.substring(0, isotopeFile.lastIndexOf(File.separator) + 1);
        //this.dtaSelectFilterFile = filePath + dtaSelectFilterFile;        
        this.massTolerance = massTolerance;
               
        conf = Configuration.getInstance();

	
    }

    /** new ChroGenerator constractor */
    public ChroGenerator(
            ChroProgressDialog progress
            //JTextArea text
            ) throws IOException
    {
        //this.bar = bar;
        this.progress = progress;
	startTime = System.currentTimeMillis();
    
       // this.text = text;
//        this.isotopeFile = isotopeFile;
//        this.filePath = isotopeFile.substring(0, isotopeFile.lastIndexOf(File.separator) + 1);
//        this.dtaSelectFilterFile = filePath + dtaSelectFilterFile;
//        this.massTolerance = massTolerance;
               
        conf = Configuration.getInstance();
        this.filePath = conf.getFilePath();

	if(conf.isXmlConf())
	    this.confRootEle = conf.getRootConfEle();
	
        this.massTolerance = conf.getMassTolerance();
        
    }
    
    //* non-labeling quantification */
    public ChroGenerator(
            ChroProgressDialog progress,
            JTextArea text,
            String refMS1File,
            String[] targetMS1Files,
            Element confRootEle,
            int[][][] pathArray
            )
    {
        this.progress = progress;
        //this.text = text;
    
        
        this.refMS1File = refMS1File;
        this.targetMS1Files = targetMS1Files;
        this.pathArray = pathArray;
        
        //this.isotopeFile = isotopeFile;
        
        //if(!this.filePath.endsWith("/"))
        //    this.filePath += File.separator;
        
        //this.dtaSelectFilterFile = dtaFile;
        
        //SAXBuilder builder = new SAXBuilder();
        //Document doc = builder.build(new File(configFile));
        this.confRootEle = confRootEle; //doc.getRootElement();
        
        //this.dtaSelectFilterFile = filePath + dtaSelectFilterFile;
        //this.massTolerance = massTolerance;
               
        conf = Configuration.getInstance();
        this.filePath = conf.getFilePath();

	startTime = System.currentTimeMillis();
        
    }
    
    //non labeling //label free based on direct id comparison new approach
    public void createLabelFreeBasedOnDirectId(boolean autoAnswer) throws IOException, Exception {
	conf = Configuration.getInstance();
	//List<String> pathFileNameList = conf.getNonlabelFilenameList();
        Set pathSet = conf.getNonlabelFilePaths();
	//List tmpFileNameList = conf.getNonlabelFilenameList();

	String chroTmpFileName = "census_chro_temp.xml";

	int fileCount=0;
	boolean isReadAll=false;

	if(autoAnswer) 
	    isReadAll = true;

	for(Iterator<String> pathItr=pathSet.iterator(); pathItr.hasNext(); )
	{
	    String eachPath = pathItr.next();

	    if(!eachPath.endsWith(File.separator))
		eachPath += File.separator;

	    File tmpF = new File(eachPath + chroTmpFileName);

	    boolean isRead=false;
	    
	    if(tmpF.exists() && !isReadAll)
	    {

		if(autoAnswer) 
		    isRead= true;
		else {
		    System.out.print(eachPath + chroTmpFileName + " are found.  Do you want to read them? (y|n|ya(yes all)) : ");
		    while(true)
		    {
			try {

			    BufferedReader ibr = new BufferedReader(new InputStreamReader(System.in));
			    String input = ibr.readLine();
			    if("y".equals(input))
			    {
				isRead= true;
				break;
			    }
			    else if("n".equals(input))
			    {
				isRead= false;
				break;
			    }
			    else if("ya".equals(input))
			    {
				isRead= true;
				isReadAll= true;
				break;
			    }

			    System.out.print("y or n?");
			    //    userName = br.readLine();
			} catch (IOException ioe) {
			    System.out.println("IO error trying to read your input!");
			    System.exit(1);
			}

		    }
		}
	    }

	    if(isRead || (isReadAll && tmpF.exists()))
		continue;

	    String eachIdPath = eachPath + CensusConstants.SEARCH_OUTPUT;
	    //System.out.println(eachPath);

	    Hashtable<String, IndexedFile> ht = null;

	    switch(conf.getSpectrumFormat())
	    {

		case Configuration.MS_FILE_FORMAT: 
		    ht = createIndexedFiles(eachPath, CensusConstants.MS1_FILE);
		    break;

		case Configuration.MZXML_FILE_FORMAT:                                
		    ht = createIndexedFiles(eachPath, CensusConstants.MZXML);
		    break;

		default:
		    break;
	    }

	    int[] keys;

	    IndexedFile iFile=null;
	    BufferedOutputStream out = null;
	    PrintStream p = null;
        
	    try
	    {                
		/*******************************************************************
		 *  Read DTASelect.txt file to find spectrum range for each peptide
		 ******************************************************************/
		//TIntLongHashMap index;            
		System.out.print("Parsing " + eachIdPath + "...");
		conf.setIdFileName(eachIdPath);

		if(null != progress)
		    progress.addMessage("\nParsing Identified Peptides...");

		if(null != progress)
		    progress.addMessage("\ndone.");

		IsotopeReader isoReader = null;

		if(null != isotopeFile)
		    isoReader = new IsotopeReader(isotopeFile);                        
		else 
		    isoReader = new IsotopeReader(this.confRootEle);                        

		IdentificationReader idReader = BaseIdentificationReader.getIdentificationInst(isoReader);                        
		System.out.println("done.");

		SpecRangeGenerator rangeGen = null;

//		File dtaFile = new File(filePath + "DTASelect.txt");

/*
		System.out.print("Parsing DTASelect.txt...");
		if(null != progress)
		    progress.addMessage("\nParsing DTASelect.txt...");

		DTASelectForLabelfreeParser generator = new DTASelectForLabelfreeParser(eachPath + "DTASelect.txt", 0.05);
		Hashtable<String, Hashtable> dtaHt = generator.getUnfilteredPeptides();

		System.out.println("\nParsing DTASelect.txt complete.");
*/		
		rangeGen = new SpecRangeGenerator();

		Element rootEle = this.createXmlChroHeader(1);
		ElementComposition totalElement;

		Element proteinEle=null;

		Element filteredEle = new Element("filtered_peptides");

		Iterator<Protein> pitr = idReader.getProteins(); //need to run to calculate redundnat peptides
		int redundantPeptideNum = idReader.getTotalPeptideNumber();
		double percent = 0.0;
		double eachSeg = 100.0/redundantPeptideNum;
		int pepCount=0;

		List<Element> proteinEleList = new ArrayList<Element>();

		for (Iterator<Protein> itr = pitr; itr.hasNext(); ) {
		    Protein protein = itr.next();

		    proteinEle = new Element("protein");
		    proteinEle.setAttribute("locus", protein.getLocus());
		    proteinEle.setAttribute("seq_ct", protein.getSeqCount());
		    proteinEle.setAttribute("spec_ct", protein.getSpectrumCount());
		    proteinEle.setAttribute("seq_cov", protein.getSeqCoverage());
		    proteinEle.setAttribute("length", protein.getLength());
		    proteinEle.setAttribute("molwt", protein.getMolWt());
		    proteinEle.setAttribute("pi", protein.getPI());
		    proteinEle.setAttribute("val", protein.getValidation());

		    try {
			proteinEle.setAttribute("desc", protein.getDescription());
		    } catch (org.jdom.IllegalDataException ide) {
			proteinEle.setAttribute("desc", StringUtil.removeIsoControlChar(protein.getDescription()) );
		    }

//		    List<Peptide> additionPepList = new ArrayList<Peptide>();
		    
		    for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); ) 
		    {
			Peptide peptide = pepItr.next();                    
			pepCount++;
			String pepSequence = peptide.getSequence();
			String pepKey = pepSequence.substring(2, pepSequence.length()-2) + peptide.getChargeState();
//			System.out.println(pepSequence.substring(2, pepSequence.length()-2) + peptide.getChargeState() + " " + peptide.getFileName());
			//Hashtable<String,String> pepFileHt = dtaHt.get(pepKey);

			/*
			for(Iterator<String> pepFileItr = pepFileHt.keySet().iterator(); pepFileItr.hasNext(); ) {

			    String pepFileKey = pepFileItr.next();

			    if(peptide.getFileName().equals(pepFileKey))
				continue;

			    String tmpPepLine = pepFileHt.get(pepFileKey);
			    Peptide tmpPep = new Peptide();
			    tmpPep.setDTASelectTxtPeptideLine(tmpPepLine);
			    additionPepList.add(tmpPep);

			}
			*/

			percent += eachSeg;

			System.out.print(pepCount);
			System.out.print("/");
			System.out.print(redundantPeptideNum);
			System.out.print(" peptides, ");
			System.out.print((int)percent);
			System.out.print(" % is complete\r");

			if(null != progress)
			{
			    progress.setProgress((int)percent);
			}

			Element peptideEle = getPeptideDomElement(peptide, isoReader, eachPath, ht);
			if(null != peptideEle)
			    proteinEle.addContent(peptideEle);

		    }

/*
		    for(Iterator<Peptide> additr=additionPepList.iterator(); additr.hasNext(); ) {
			Peptide peptide = additr.next();

			Element peptideEle = getPeptideDomElement(peptide, isoReader, eachPath, ht);
			if(null != peptideEle)
			    proteinEle.addContent(peptideEle);
		    }
*/
//		    System.out.println("------" + protein.getLocus() + " " + proteinEle.getChildren().size());
		    if(proteinEle.getChildren().size()>0) {
			

                        
			for(Iterator<Element> proEleItr=proteinEleList.iterator(); proEleItr.hasNext(); ) {
			    Element protempEle = proEleItr.next();

			    List<Element> pepchildList = proteinEle.getChildren();

                            for(Iterator<Element> pepItr=pepchildList.iterator(); pepItr.hasNext(); ) {
                                Element pepcopy = pepItr.next();
                                protempEle.addContent((Element)pepcopy.clone());
                            }
                          
                            //protempEle.addContent(proteinEle.getChildren().);
                            rootEle.addContent(protempEle);

                        }

                        rootEle.addContent(proteinEle);
                        proteinEleList.clear();

                    }

		    else {
			proteinEleList.add(proteinEle);
		    }

		}

		Document doc = new Document(rootEle);
		OutputStream os = new FileOutputStream(eachPath + chroTmpFileName);
		XMLOutputter outputter = new XMLOutputter();
		outputter.setFormat(Format.getPrettyFormat());
		outputter.output(doc, os);
		os.close();

		System.out.println("\n100% complete");
	    }
	    catch (IOException e)
	    {
		System.out.println("IO Error while generating msms chro file : " + e);
		e.printStackTrace();
		throw new IOException(e.toString());
	    } 
	    catch (Exception e)
	    {
		System.out.println("Error while generating msms chro file : " + e);
		e.printStackTrace();
		throw new Exception(e.toString());
	    }
	    finally
	    {
		if(null != p)
		    p.close();

		if(null != out)
		    out.close();

		//Close all random files
		for (Enumeration e = ht.keys(); e.hasMoreElements(); ) 
		{
		    iFile = ht.get(e.nextElement());

		    if(null != iFile)
			iFile.close();
		}

	    }


	    System.out.println( (System.currentTimeMillis() - startTime)*0.001 + " seconds taken");
	}

        
        MergeLabelFreeChro.mergeLabelFreeChro(conf.getSampleList(), chroTmpFileName);
        
    }

    private Element getPeptideDomElement(Peptide peptide, IsotopeReader isoReader, String eachPath, Hashtable<String, IndexedFile> ht) throws IOException, Exception {
			String pepSequence = peptide.getSequence();
			String fileName=peptide.getFileName();
			fileName = cleanFileName(fileName);
			//trim additional characters from peptide sequence at both ends
			
			char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();

			ElementComposition element = new ElementComposition(ch, 0, ch.length, isoReader.getIsotope());

			try {
			    element.calculate();
			} catch (InvalidAAException invE)
			{
			    System.out.println("Not Quantifiable peptide : " + pepSequence);
			    return null;
			}

			if(!element.isQuantifiable())
			{
			    System.out.print("\nError : ");
			    System.out.println(pepSequence + " is not quantifiable.");                        
			    return null;
			}


			IsotopeDist sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    
			IsotopeDist refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);

			Element peptideEle=this.createXmlChroPeptideTitle(true, peptide); //true is for full scan
			conf.setCalcSamAvgMass(sampleDist.getAvgMass());
			conf.setCalcRefAvgMass(refDist.getAvgMass());
			peptideEle.setAttribute("lightStartMass", String.valueOf(sampleDist.getStartMass()));  
			peptideEle.setAttribute("heavyStartMass", String.valueOf(refDist.getStartMass()));
			peptideEle.setAttribute("lightAvgMass", String.valueOf(conf.getCalcSamAvgMass()));  
			peptideEle.setAttribute("heavyAvgMass", String.valueOf(conf.getCalcRefAvgMass()));

			//String fileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf(".")+1) + "ms1";

			SpecRange range = null;

			int tmpScanNum = Integer.parseInt(peptide.getScanNum());
			range = new SpecRange( tmpScanNum, tmpScanNum );                        
			peptideEle.setAttribute("start_scan", peptide.getScanNum());
			peptideEle.setAttribute("end_scan", peptide.getScanNum());

			peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
			peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));
			int scanNum = Integer.parseInt(peptide.getScanNum());

			switch(conf.getSpectrumFormat())
			{
			    case Configuration.MS_FILE_FORMAT: 
				fileName += ".ms1";
				break;

			    case Configuration.MZXML_FILE_FORMAT:
				fileName += ".mzXML";
				break;

			    default:
				break;
			}

			IndexedFile iFile = ht.get(eachPath + fileName);

			//iFile = ht.get(fileName);
			if(null == iFile)
			{
			    iFile = ht.get(eachPath + fileName.substring(1, fileName.length()));
			    if(null == iFile) {
				System.out.println("Error : cannot find the file " + fileName);
				throw new IOException("Error : cannot find the file " + eachPath + fileName);
			    }
			    //System.exit(0);
			}

			int[] keys = iFile.getKeys();
			int keyIndex=-1;
			keyIndex = Arrays.binarySearch(keys, scanNum);

			if(keyIndex<0) //Cannot find index
			    keyIndex=-(++keyIndex); //Math.abs(++keyIndex);

			if(keyIndex>=keys.length)
			    keyIndex--;

			Element chro = new Element("chro");

			int chargeState = Integer.parseInt(peptide.getChargeState());

			if( conf.isHighRes() )
			{
			    double[] samIsoArr = sampleDist.getHighMassList();
			    double[] refIsoArr = refDist.getHighMassList();

			    for(int i=0;i<samIsoArr.length;i++)
			    {
				samIsoArr[i] = (samIsoArr[i]+chargeState*PROTON_MASS)/chargeState;
                                
			    }

			    for(int i=0;i<refIsoArr.length;i++)
			    {
				refIsoArr[i] = (refIsoArr[i]+chargeState*PROTON_MASS)/chargeState;
			    }

			    if(conf.isUseProline() && pepSequence.substring(2, pepSequence.length()-2).contains("P"))
			    {
				double[] refProlineIsoArr = new double[refIsoArr.length*2];

				for(int i=0;i<refIsoArr.length;i++)
				{
				    refProlineIsoArr[i] = refIsoArr[i];
				}

				for(int i=refIsoArr.length;i<refProlineIsoArr.length;i++)
				{
				    refProlineIsoArr[i] = refIsoArr[i-refIsoArr.length] + Configuration.PROLINE_SHIFT/chargeState;
				}

				chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, samIsoArr, refProlineIsoArr, range) );    
			    } else
			    {
				//chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, samIsoArr, refIsoArr, range) );    
				chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, samIsoArr, null, range) );    
			    }



			}
			else
			{

			    double sampleStartMass = (sampleDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
			    double sampleEndMass = (sampleDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;

			    double refStartMass = (refDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
			    double refEndMass = (refDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;

			    chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, sampleStartMass, sampleEndMass, refStartMass, refEndMass, range) );
			}

			peptideEle.addContent(chro);

			return peptideEle;



    }

    public void getUnfilteredPeptideChro() {
//	chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, samIsoArr, null, range) );
    }

    //non labeling //label free
    public void createNonlabelXmlChro() throws IOException, Exception {
       

        //Element outRootEle = createXmlChroHeader(conf.getQuantLevel());
        ElementComposition element;
        ElementComposition totalElement;
        
        IndexedFile iFile;
        
        /******************************************************************
         *  Read DTASelect.txt file to find spectrum range for each peptide
         ******************************************************************/
        
        Hashtable<String, IndexedFile> ht = new Hashtable<String, IndexedFile>();
        Hashtable<String, IndexedFile> ht2 = new Hashtable<String, IndexedFile>(); //for tandem mass
        
        //DTASelectFilterReader dtaReader;
        IdentificationReader idReader;
        Set pathSet = conf.getNonlabelFilePaths();
	List fileNameList = conf.getNonlabelFilenameList();
	
        IsotopeReader isoReader = new IsotopeReader(this.confRootEle);
        //for tandem scans
        IsotopeTable<String, int[]> isoTable = isoReader.getIsotope();
        int[] sampleNterm = isoTable.get("sampleNTERM");
        int[] sampleCterm = isoTable.get("sampleCTERM");
        int[] refNterm = isoTable.get("refNTERM");
        int[] refCterm = isoTable.get("refCTERM");
        
	//build sp hashtable
	List tmpFileNameList = conf.getNonlabelFilenameList();

	Hashtable<String, int[]> spHt = new Hashtable<String, int[]>();

	int fileCount=0;
	for(Iterator<String> itr=tmpFileNameList.iterator(); itr.hasNext(); )
	{
	    String eachPath = itr.next();
	    eachPath = eachPath.substring(0, eachPath.lastIndexOf(File.separator) + 1);
	    //eachPath += "DTASelect-filter.txt";
	    eachPath += CensusConstants.SEARCH_OUTPUT;

	    DTASelectFilterReader idReadert = new DTASelectFilterReader(eachPath);

	    for (Iterator<Protein> itr1 = idReadert.getProteins(); itr1.hasNext(); )
	    {
		Protein protein = itr1.next();
		String accession = protein.getLocus();
		int[] tmpArr = spHt.get(accession);

		if(null == tmpArr)
		{
		    tmpArr = new int[tmpFileNameList.size()];
		    tmpArr[fileCount] = Integer.parseInt(protein.getSpectrumCount());

		    spHt.put(accession, tmpArr);
		}
		else
		{
		    tmpArr[fileCount] = Integer.parseInt(protein.getSpectrumCount());
		}

	    }

	    fileCount++;
	}

	conf.setSpHt(spHt);

        Hashtable<String, SpecRangeGenerator> specRangeHt = new Hashtable<String, SpecRangeGenerator>();
        Hashtable<String, Protein> proteinHt = new Hashtable<String, Protein>();
        
        System.out.println("Checking duplicate proteins and peptides...");
        //populate index hashtable
        int totalPeptideCount = 0;
        for(Iterator<String> itr=pathSet.iterator(); itr.hasNext(); ) {
            String path = itr.next();
            
            
            //file could be generated from either linux or window
            if( !path.endsWith("/") && !path.endsWith("\\") ) {
                //for linux
                if(path.startsWith("/"))
                    path += "/";
                else //for window
                    path += "\\";
            }
            
            
            //if(1==conf.getQuantLevel())

            ht.putAll( ChroGenerator.createIndexedFiles(path, CensusConstants.MS1_FILE) );
            
            if(2==conf.getQuantLevel())
                ht2.putAll( ChroGenerator.createIndexedFiles(path, CensusConstants.MS2_FILE) );
           
            idReader = new DTASelectFilterReader(path + CensusConstants.SEARCH_OUTPUT);

            //SpecRangeGenerator rangeGen = new SpecRangeGenerator(path + "DTASelect.txt", dtaReader.isVersion2(), dtaReader.getConfidence());
            SpecRangeGenerator rangeGen = SpecRangeGenerator.getSpecRangeGenerator(idReader);
            
            specRangeHt.put(path, rangeGen);
            
            for (Iterator<Protein> itr1 = idReader.getProteins(); itr1.hasNext(); ) {
                Protein protein = itr1.next();
                
                Protein tempPro = proteinHt.get(protein.getLocus());
                
                if(null == tempPro) {
                    protein.populatePeptideHt(path);
                    proteinHt.put(protein.getLocus(), protein);
                    
                    totalPeptideCount += protein.getPeptideSize();
                    
                    continue;
                }
                
                totalPeptideCount += tempPro.addPeptideHt( protein.getPeptides(), path );
            }
        }
        
        NonLabelMappingModel mapModel = conf.getMapModel();
        if(conf.getQuantLevel() == 2)
            mapModel.setMsmsMap(ht, ht2);
        
        //increase status bar
        //int redundantPeptideNum = dtaReader.getRedundantPeptideNum();
        double percent = 30.0;
        double eachSeg = 70.0/totalPeptideCount;
        int pepCount=0;
        
        
        Element proteinEle=null;
        Element peptideEle=null;
        TIntLongHashMap index;
                
        Element outRootEle = createXmlChroHeader(conf.getQuantLevel());
                        
        Element labelTypeEle = new Element("label_type");
        labelTypeEle.setText("false");
        
        outRootEle.addContent(labelTypeEle);
        
        Element alignEle = new Element("align");
        
        if(conf.isAlign())
            alignEle.setText("true");
        else
            alignEle.setText("false");
        
        outRootEle.addContent(alignEle);
        
        
        for(Iterator<Element> itr2=this.confRootEle.getChildren("sample").iterator(); itr2.hasNext(); ) {
            Element each = itr2.next();
            
            Element sample = new Element("sample");
            sample.addContent( new Element("name").addContent(each.getChildText("name")) );
            Element msFile = new Element("ms_files");
            
            for(Iterator<Element> fileItr=each.getChild("ms_files").getChildren("file").iterator(); fileItr.hasNext(); ) {
                Element fileEach = fileItr.next();
                //Element fileEle = new Element("file");
                
                msFile.addContent(new Element("file").addContent(fileEach.getText()));
            }
            
            sample.addContent(msFile);
            
            outRootEle.addContent(sample);
        }
        
        if(conf.isAlign()) {
            Element ref = new Element("ref");
            Element confRefEle = this.confRootEle.getChild("ref");
            
            ref.addContent( new Element("sample_name").addContent( confRefEle.getChildText("sample_name") ) );
            ref.addContent( new Element("file_name").addContent( confRefEle.getChildText("file_name") ) );
            outRootEle.addContent(ref);
        }
       
	System.exit(0);

        /****  read spec count info ****/
        for(Iterator<Protein> itr=proteinHt.values().iterator(); itr.hasNext(); ) {
            Protein protein = itr.next();
            
            int[] spcArr = spHt.get(protein.getLocus());
            
            StringBuffer spcSb = new StringBuffer();
            
            for(int i=0;i<spcArr.length;i++)
                spcSb.append(spcArr[i]).append(",");
            
            proteinEle = new Element("protein");
            proteinEle.setAttribute("locus", protein.getLocus());
            proteinEle.setAttribute("seq_ct", protein.getSeqCount());
            //proteinEle.setAttribute("spec_ct", protein.getSpectrumCount());
            proteinEle.setAttribute("spec_ct", spcSb.toString());
            proteinEle.setAttribute("seq_cov", protein.getSeqCoverage());
            proteinEle.setAttribute("length", protein.getLength());
            proteinEle.setAttribute("molwt", protein.getMolWt());
            proteinEle.setAttribute("pi", protein.getPI());
            proteinEle.setAttribute("val", protein.getValidation());

	    try {
		proteinEle.setAttribute("desc", protein.getDescription());
	    } catch (org.jdom.IllegalDataException ide) {
		proteinEle.setAttribute("desc", StringUtil.removeIsoControlChar(protein.getDescription()) );
	    }

            //for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); )
            for(Iterator<Peptide> pepItr=protein.getPeptideHt().values().iterator(); pepItr.hasNext(); ) {
                Peptide peptide = pepItr.next();
                pepCount++;
                
                String pepSequence = peptide.getSequence();
		
                char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();
                //element = new ElementComposition(peptide.getSequence().substring(2, peptide.getSequence().length()-2), isoReader.getIsotope());
                                                    
                try {
                    //element = new ElementComposition(ch, 0, ch.length, isoReader.getIsotope());
                    totalElement = new ElementComposition(ch, 0, ch.length, isoTable);                    
                    totalElement.calculate();
                    
                } catch (InvalidAAException aaEx) {
                    
                    System.out.println("Not Quantifiable peptide : " + pepSequence);
                    percent += eachSeg;

		    if(null != progress)
		    {
			ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			progress.setProgress((int)percent);
		    }
                    continue;
                    
                }
                
                if(!totalElement.isQuantifiable()) {
                    System.out.print("\nError : ");
                    System.out.println(pepSequence + " is not quantifiable.");
                    
                    percent += eachSeg;
                    progress.setProgress((int)percent);
                    System.out.print(pepCount);
                    System.out.print("/");
                    System.out.print(totalPeptideCount);
                    System.out.print(" peptides, ");
                    System.out.print((int)percent);
                    System.out.print(" % is complete\r");
                    
                    
                    if(null != this.progress) {
                        progress.addMessage("\nError : ");
                        progress.addMessage(pepSequence);
                        progress.addMessage(" is not quantifiable.\n");
                        
                        System.out.print(String.valueOf(pepCount));
                        System.out.print("/");
                        System.out.print(String.valueOf(totalPeptideCount));
                        System.out.print(" peptides, ");
                        System.out.print(String.valueOf((int)percent));
                        System.out.print(" % is complete\r");
                    }
                    
                    continue;
                }
                
                
                int chargeState = Integer.parseInt(peptide.getChargeState());
                
                IsotopeDist sampleDist = null;
                //IsotopeDist refDist = null;
                
                String fileName=peptide.getFileName();
                
                for(int i=0;i<3;i++)
                    fileName = fileName.substring(0, fileName.lastIndexOf("."));
                
                String fpath = peptide.getFilePath();
                SpecRangeGenerator rangeGen = specRangeHt.get(fpath);
                
                StringBuffer rangeKey = new StringBuffer();
                rangeKey.append(protein.getLocus());
                rangeKey.append(fileName);                
                rangeKey.append(peptide.getSequence().substring(2, peptide.getSequence().length()-2));

                SpecRange range = rangeGen.getSpecRange( rangeKey.toString() );
                //sb.append("\tStartScan\tEndScan\tDTAPeakStart\tDTAPeakEnd\n");

                /*
                if(null==range) {
                    System.out.println("Error : cannot find peptide in DTASelect.txt file " + protein.getLocus() + " " + peptide.getSequence());

                    if(null != progress) {
                        System.out.println("\nError : cannot find peptide in DTASelect.txt file " + protein.getLocus() + " " + peptide.getSequence());
                    }

                    continue;
                }*/
                
               
		peptideEle = this.createXmlChroPeptideTitle(false, peptide);

                if(null==range)
                {
                    int tmpScanNum = Integer.parseInt(peptide.getScanNum());
                    range = new SpecRange( tmpScanNum, tmpScanNum );                        
                    peptideEle.setAttribute("start_scan", peptide.getScanNum());
                    peptideEle.setAttribute("end_scan", peptide.getScanNum());
                }
                else
                {
                    peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                    peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));                        
                }


                Element chro = new Element("chro");
                
                if(1==conf.getQuantLevel())
                {
                    peptideEle = this.createXmlChroPeptideTitle(true, peptide); //true for full scan
                    fileName += ".";
                    fileName += CensusConstants.MS1_FILE;
                    iFile = ht.get(fpath + fileName);                
                }
                else //level is 2
                {
                    peptideEle = this.createXmlChroPeptideTitle(false, peptide);                    
                    fileName += ".";
                    fileName += CensusConstants.MS2_FILE;
                    iFile = ht2.get(fpath + fileName);                
                }

                peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));
                
                
                if(null == iFile) {
                    System.out.println("Error : cannot find the file " + fpath + fileName);
                    throw new IOException("Error : cannot find the file " + fpath + fileName);
                    //System.exit(0);
                }
                
                int[] keys = iFile.getKeys();
                int keyIndex = Arrays.binarySearch(keys, Integer.parseInt(peptide.getScanNum()));

                if(keyIndex<0) //Cannot find index
                    keyIndex=-(++keyIndex); //Math.abs(++keyIndex);

                if(keyIndex>=keys.length)
                    keyIndex--;

                if( conf.getQuantLevel()==1 ) {                    
                    
                    sampleDist = new IsotopeDist(totalElement.getElementSampleArr(), totalElement.getModShift(), true);
                    
                   
                    if( conf.isHighRes() ) {
                        double[] samIsoArr = sampleDist.getHighMassList();
                        //double[] refIsoArr = refDist.getHighMassList();
                        
                        for(int i=0;i<samIsoArr.length;i++) {
                            samIsoArr[i] = (samIsoArr[i]+chargeState*PROTON_MASS)/chargeState;
                        }
                   
			try {

			    chro.setText( CalcUtil.calculateNonlabelMS(keyIndex, fileName, ht, pathArray, samIsoArr, range, fpath) );
			    //System.out.println( CalcUtil.calculateNonlabelMS(keyIndex, fileName, ht, pathArray, samIsoArr, range, path) );
			} catch(CensusIndexOutOfBoundException ciob)
			{
			    percent += eachSeg;
			    System.out.print("Warning: the peptide is not quantifiable - the peptide seems to be outside of chromatogram alignment range.\r");
			    continue;
			}
                        
                    } else {
			double sampleStartMass = sampleStartMass = (sampleDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
			double sampleEndMass = sampleEndMass = (sampleDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;

			chro.setText( CalcUtil.calculateNonlabelMS(keyIndex, fileName, ht, pathArray, sampleStartMass, sampleEndMass, range, fpath) );
			
       //        System.out.println("aaaaaaaaaaaaaaaaaa");
	 //      System.exit(0);
                        
//                        throw new Exception("not supporting low resolution yet. Robin.");
                        
                        //refStartMass = (refDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
                        //refEndMass = (refDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;
                        //System.out.println("mass range==>>" + sampleStartMass + "\t" + sampleEndMass + "\t" + refStartMass  + "\t" + refEndMass);                        
                        //chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, sampleStartMass, sampleEndMass, refStartMass, refEndMass, conf, range) );
                    }
                    
                    peptideEle.addContent(chro);
                    proteinEle.addContent(peptideEle);
                    
                } else if( conf.getQuantLevel() == 2) {
                    
                    double[][] bionSample;
                    double[][] bionRef;
                    double[][] yionSample;
                    double[][] yionRef;
                                        
                    int pepLength=0;
                    
                    for(int i=0;i<ch.length;i++) {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;
                        
                        pepLength++;
                    }
                    
                    bionSample = new double[pepLength][chargeState*3];
                    bionRef = new double[pepLength][chargeState*3];
                    //Yions
                    yionSample = new double[pepLength][chargeState*3];
                    yionRef = new double[pepLength][chargeState*3];
                    
                    int pepIndex=0;
                    
                    
                    for(int i=0;i<ch.length;i++) {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;

			try {    
			    element = new ElementComposition(ch, 0, i+1, isoTable);
			    element.calculate();
			} catch (InvalidAAException ive)
			{
			    System.out.println("Not Quantifiable peptide : " + pepSequence);

			    percent += eachSeg;
			    if(null != progress)
			    {
				ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
				progress.setProgress((int)percent);

			    }
			    continue;                        
			}
                        
                        //Y ions
                        sampleDist = new IsotopeDist(
                                getComplementaryComposition(totalElement.getElementSampleArr(), element.getElementSampleArr(), sampleNterm, sampleCterm), element.getModShift(), true);
                        
                        //refDist = new IsotopeDist(
                        //        getComplementaryComposition(totalElement.getElementRefArr(), element.getElementRefArr(), refNterm, refCterm), false);   //fix this
                        
                        switch(chargeState) {
                            case 3:
                                yionSample[(pepIndex+1)%pepLength][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                                yionSample[(pepIndex+1)%pepLength][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;
                          //      yionRef[(pepIndex+1)%pepLength][8] = (refDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                          //      yionRef[(pepIndex+1)%pepLength][7] = (refDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                          //      yionRef[(pepIndex+1)%pepLength][6] = (refDist.getAvgMass()+3*PROTON_MASS)/3;
                                
                            case 2:
                                yionSample[(pepIndex+1)%pepLength][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                                yionSample[(pepIndex+1)%pepLength][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                          //      yionRef[(pepIndex+1)%pepLength][5] = (refDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                          //      yionRef[(pepIndex+1)%pepLength][4] = (refDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                          //      yionRef[(pepIndex+1)%pepLength][3] = (refDist.getAvgMass()+2*PROTON_MASS)/2;
                                
                            case 1:
                                yionSample[(pepIndex+1)%pepLength][2] = sampleDist.getEndMass()+1*PROTON_MASS+massTolerance; //add proton to give b fragment ion
                                yionSample[(pepIndex+1)%pepLength][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][0] = sampleDist.getAvgMass()+1*PROTON_MASS;
                           //     yionRef[(pepIndex+1)%pepLength][2] = refDist.getEndMass()+1*PROTON_MASS+massTolerance;
                           //     yionRef[(pepIndex+1)%pepLength][1] = refDist.getStartMass()+1*PROTON_MASS-massTolerance;
                           //     yionRef[(pepIndex+1)%pepLength][0] = refDist.getAvgMass()+1*PROTON_MASS;
                                
                            default:
                                break;
                        }
                        
                        element.calculateBion();
                        //element.printComposition();
                        
                        sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);
                        
                        switch(chargeState) {
                            case 3:
                                bionSample[pepIndex][8] = (sampleDist.getEndMass()+2*PROTON_MASS)/3+massTolerance;
                                bionSample[pepIndex][7] = (sampleDist.getStartMass()+2*PROTON_MASS)/3-massTolerance;
                                bionSample[pepIndex][6] = (sampleDist.getAvgMass()+2*PROTON_MASS)/3;
                          //      bionRef[pepIndex][8] = (refDist.getEndMass()+2*PROTON_MASS)/3+massTolerance;
                          //      bionRef[pepIndex][7] = (refDist.getStartMass()+2*PROTON_MASS)/3-massTolerance;
                          //      bionRef[pepIndex][6] = (refDist.getAvgMass()+2*PROTON_MASS)/3;
                                
                            case 2:
                                bionSample[pepIndex][5] = (sampleDist.getEndMass()+1*PROTON_MASS)/2+massTolerance;
                                bionSample[pepIndex][4] = (sampleDist.getStartMass()+1*PROTON_MASS)/2-massTolerance;
                                bionSample[pepIndex][3] = (sampleDist.getAvgMass()+1*PROTON_MASS)/2;
                          //      bionRef[pepIndex][5] = (refDist.getEndMass()+1*PROTON_MASS)/2+massTolerance;
                          //      bionRef[pepIndex][4] = (refDist.getStartMass()+1*PROTON_MASS)/2-massTolerance;
                          //      bionRef[pepIndex][3] = (refDist.getAvgMass()+1*PROTON_MASS)/2;
                                
                            case 1:
                                bionSample[pepIndex][2] = sampleDist.getEndMass()+massTolerance;
                                bionSample[pepIndex][1] = sampleDist.getStartMass()-massTolerance;
                                bionSample[pepIndex][0] = sampleDist.getAvgMass();
                           //     bionRef[pepIndex][2] = refDist.getEndMass()+massTolerance;
                           //     bionRef[pepIndex][1] = refDist.getStartMass()-massTolerance;
                           //     bionRef[pepIndex][0] = refDist.getAvgMass();
                                
                            default:
                                break;
                                
                        }
                        
                        pepIndex++;
                    }
                    
		    try {
			element = new ElementComposition(ch, 0, ch.length, isoTable);
			element.calculate();
                    } catch (InvalidAAException ive)
                    {
                        System.out.println("Not Quantifiable peptide : " + pepSequence);

                        percent += eachSeg;
			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);

			}
                        continue;                        
                    }
                    sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);
                    
                    int[] tempA = element.getElementSampleArr();
                    
//                    for(int i=0;i<tempA.length;i++)
                    
                    switch(chargeState) {
                        case 3:
                            yionSample[0][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                            yionSample[0][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                            yionSample[0][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;
                      //      yionRef[0][8] = (refDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                      //      yionRef[0][7] = (refDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                      //      yionRef[0][6] = (refDist.getAvgMass()+3*PROTON_MASS)/3;
                            
                        case 2:
                            yionSample[0][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                            yionSample[0][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                            yionSample[0][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                      //      yionRef[0][5] = (refDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                      //      yionRef[0][4] = (refDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                      //      yionRef[0][3] = (refDist.getAvgMass()+2*PROTON_MASS)/2;
                            
                        case 1:
                            yionSample[0][2] = sampleDist.getEndMass()+1*PROTON_MASS+massTolerance; //add proton to give b fragment ion
                            yionSample[0][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                            yionSample[0][0] = sampleDist.getAvgMass()+1*PROTON_MASS;
                      //      yionRef[0][2] = refDist.getEndMass()+1*PROTON_MASS+massTolerance;
                      //      yionRef[0][1] = refDist.getStartMass()+1*PROTON_MASS-massTolerance;
                      //      yionRef[0][0] = refDist.getAvgMass()+1*PROTON_MASS;
                            
                        default:
                            break;
                            
                    }
                    
//                    peptideEle = this.createXmlChroPeptideTitle(false, peptide);
                    
                    //String ms2FileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf("."));
                    

                    
                   // iFile = ht.get( this.filePath + fileName + "." + "ms2");
                    
                    //keys = iFile.getKeys();
                    
                   // keyIndex = Arrays.binarySearch(keys, Integer.parseInt(peptide.getScanNum()));
                    
                   // if(keyIndex<0) //Cannot find index
                   //     keyIndex=-(++keyIndex); //Math.abs(++keyIndex);
                    
                    
                            
                    //System.out.println("key" + keyIndex);
                    
                    /**
                     * Find start scan number same as a precursor of sampleAvgMass
                     * Then, later the program will find following scan # quicker.
                     **/
                    /* End of finding start spectrum number */
                    
                    /*
                    samplePrecursor=1;
                    refPrecursor=1;
                    
                    TIntDoubleHashMap precursorMap = iFile.getPrecursorMap();
                   */ 
                    double calcSamMass = (sampleDist.getAvgMass()+chargeState*PROTON_MASS)/chargeState;
                   // double calcRefMass = (refDist.getAvgMass()+chargeState*PROTON_MASS)/chargeState;
                    
                    conf.setCalcSamAvgMass(calcSamMass);
		    peptideEle.setAttribute("lightStartMass", String.valueOf(sampleDist.getStartMass()));  
		    peptideEle.setAttribute("lightAvgMass", String.valueOf(conf.getCalcSamAvgMass()));  
                    //conf.setCalcRefAvgMass(calcRefMass);
                    
                   
		  if( conf.isHighRes() ) {
			System.out.println("high resolution for tandem spectra is not supported yet.  Please change it to low resolution or contact Robin by rpark@scripps.edu");
			System.exit(0);
		  }
		  else { //low resolution
			double[] samIsoArr = sampleDist.getHighMassList();
			//double[] refIsoArr = refDist.getHighMassList();

			for(int i=0;i<samIsoArr.length;i++) {
			    samIsoArr[i] = (samIsoArr[i]+chargeState*PROTON_MASS)/chargeState;
			    //System.out.println("\t\t" + samIsoArr[i]);
			}

			try {
			    String outStr = CalcUtil.calculateNonlabelMS(keyIndex, fileName, ht2, pathArray, samIsoArr, range, fpath, bionSample, yionSample, iFile);
                        
                        
			    if(outStr == null)
			    {
				percent += eachSeg;
				continue;
			    }
                        
			    chro.setText(outStr);                        
			} catch(CensusIndexOutOfBoundException ciob)
			{
			    percent += eachSeg;
			    System.out.print("Warning: the peptide is not quantifiable - the peptide seems to be outside of chromatogram alignment range.\r");

			    continue;
			} catch(Exception e)
			{
			    percent += eachSeg;
			    System.out.print("Warning: the peptide is not quantifiable.\r");

			    continue;
			}
                        
		  }

                    peptideEle.addContent(chro);
                    
                    Element fragEle = new Element("frag");
                    
                    Element bSample = new Element("bs");
                    StringBuffer tempSb = new StringBuffer();
                    for(int i=0;i<bionSample.length;i++) {
                        int j;
                        for(j=0;j<bionSample[i].length-1;j++) {
                            tempSb.append( formatter.format(bionSample[i][j]) ).append(" ");
                        }
                        
                        tempSb.append( formatter.format(bionSample[i][j]) ).append(",");
                    }
                    
                    bSample.setText(tempSb.toString());
                    fragEle.addContent(bSample);
                    
                    Element bRef = new Element("br");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<bionRef.length;i++) {
                        int j;
                        for(j=0;j<bionRef[i].length-1;j++) {
                            tempSb.append( formatter.format(bionRef[i][j]) ).append(" ");
                        }
                        
                        tempSb.append( formatter.format(bionRef[i][j]) ).append(",");
                        
                    }
                    
                    bRef.setText(tempSb.toString());
                    fragEle.addContent(bRef);
                    
                    Element ySample = new Element("ys");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<yionSample.length;i++) {
                        int j;
                        for(j=0;j<yionSample[i].length-1;j++) {
                            tempSb.append( formatter.format(yionSample[i][j]) ).append(" ");
                        }
                        
                        tempSb.append( formatter.format(yionSample[i][j]) ).append(",");
                    }
                    
                    ySample.setText(tempSb.toString());
                    fragEle.addContent(ySample);
                    
                    Element yRef = new Element("yr");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<yionRef.length;i++) {
                        int j;
                        for(j=0;j<yionRef[i].length-1;j++) {
                            tempSb.append( formatter.format(yionRef[i][j]) ).append(" ");
                        }
                        
                        tempSb.append( formatter.format(yionRef[i][j]) ).append(",");
                    }
                    
                    yRef.setText(tempSb.toString());
                    fragEle.addContent(yRef);
                    
                    peptideEle.addContent(fragEle);
                    
                    //peptideEle.addContent(chro);
                    
                    proteinEle.addContent(peptideEle);
                                                            
                }                
                
                percent += eachSeg;
                
                System.out.print(pepCount);
                
                System.out.print("/");
                System.out.print(totalPeptideCount);
                System.out.print(" peptides, ");
                System.out.print((int)percent);
                System.out.print(" % is complete\r");
                
                if(null != progress) {
                    progress.setProgress((int)percent);
                    //progress.addMessageOffset(pepCount + "/" + totalPeptideCount + " Peptide, " + (int)percent +  "% is complete");
                }
            }

            
            if(proteinEle.getChildren().size()>0)
                outRootEle.addContent(proteinEle);

        }
        
        Document doc = new Document(outRootEle);
	OutputStream os = null;


	if(conf.getFilePath().endsWith(File.separator))
	    os = new FileOutputStream(conf.getFilePath() + "census_chro.xml");
	else
	    os = new FileOutputStream(conf.getFilePath() + File.separator + "census_chro.xml");

        XMLOutputter outputter = new XMLOutputter();
        outputter.setFormat(Format.getPrettyFormat());
        outputter.output(doc, os);
        os.close();
        
        System.out.println("\n100% complete");
        ChroProgressDialog.addMessageWithLine(progress, "\n100% complete");        
        System.out.println("done.");
        ChroProgressDialog.addMessageWithLine(progress, "done.");        
    }

    public static Hashtable createIndexedFiles(String filePath, String extension) throws IOException, CensusGeneralException
    {
        //for non-labeling quantification, same file names may appear in different folders.  That means
        // it is dangerous to use file names as keys.  Fix me later.
        //System.out.println("==" + conf.getFilePath());
        
        if( !filePath.endsWith(File.separator) )
            filePath += File.separator;
      
        File f = new File(filePath);

        String[] list = f.list(new RelExFileFilter(extension));

        Hashtable<String, IndexedFile> ht = new Hashtable<String, IndexedFile>();
        IndexedFile iFile = null;
        
        String indexFileName;
        File indexFile;

	if(null == list || list.length<=0) {
	    throw new CensusGeneralException("Error: Spectral files are ot found at " + filePath + " If you use mzXML, please use option '-x'");
	}
	
	switch(conf.getSpectrumFormat())
	{
	    case Configuration.MS_FILE_FORMAT: 
		for(int i=0;i<list.length;i++)
		{   
		    indexFileName = filePath + list[i] + ".index";
		    indexFile = new File(indexFileName);

		    //System.out.println(indexFileName + " " + indexFile.exists());
		    //Create index file
		    if(!indexFile.exists() || indexFile.length()<=0)
		    {
			System.out.println("creating index file " + indexFileName);        

			ChroProgressDialog.addMessageWithLine(progress, "creating index file " + indexFileName);
			MSIndexFileCreator.createIndexFile(filePath + list[i]); //text.append("Index files are required");
		    }

		    //System.out.println("Reading index file for " +  indexFile + " & " + list[i] + " & " + filePath);

		    //if index file is corrupted, delete the file and re-try to read it.
		    try {
			iFile = new IndexedFile(indexFile, filePath + list[i]);
		    } catch(FileNotFoundException fnfe) {
                        System.out.println("Error: Spectral files are not found.  If you use mzXML, please use option '-x'");
                        
                        System.exit(0);
                    } catch (Exception ioe) {
			System.out.println("re-creating index file " + indexFileName);        

			ChroProgressDialog.addMessageWithLine(progress, "re-creating index file " + indexFileName);
			MSIndexFileCreator.createIndexFile(filePath + list[i]); //text.append("Index files are required");
		    }

		    ht.put(filePath + list[i], iFile);   
		}

		break;

	    case Configuration.MZXML_FILE_FORMAT:
		for(int i=0;i<list.length;i++)
		{   
		    try {
                        System.out.print("Indexing on " + list[i] + "...");
                        ChroProgressDialog.addMessageWithLine(progress, "Indexing on " + list[i] + "...");       
			iFile = new IndexedFile(filePath + list[i]);
                        System.out.println("done");
                        ChroProgressDialog.addMessageWithLine(progress, "done");       
                        
		    } catch(FileNotFoundException fnfe) {
                        System.out.println("Error: Spectral file is not found");
                        
                        System.exit(0);
                    } catch (Exception ioe) {
                    
			System.out.println("re-creating index file "); // + indexFileName);        
                        
			//ChroProgressDialog.addMessageWithLine(progress, "re-creating index file " + indexFileName);
			//MSIndexFileCreator.createIndexFile(filePath + list[i]); //text.append("Index files are required");
		    }

                    //System.out.println(ht + " " + iFile + " " + list[i]);
		    ht.put(filePath + list[i], iFile);   
		}
		
		break;

	    case Configuration.MS2_FILE_FORMAT: 
		for(int i=0;i<list.length;i++)
		{   
		    indexFileName = filePath + list[i] + ".index";
		    indexFile = new File(indexFileName);

		    if(!indexFile.exists() || indexFile.length()<=0)
		    {
			System.out.println("creating index file " + indexFileName);        

			ChroProgressDialog.addMessageWithLine(progress, "creating index file " + indexFileName);
			MSIndexFileCreator.createIndexFile(filePath + list[i]); //text.append("Index files are required");
		    }

		    try {
			iFile = new IndexedFile(indexFile, filePath + list[i]);
		    } catch(FileNotFoundException fnfe) {
                        System.out.println("Error: Spectral file is not found");
                        
                        System.exit(0);
                    } catch (Exception ioe) {
			ioe.printStackTrace();
			System.out.println(ioe);
			System.out.println("re-creating index file " + indexFileName);        

			ChroProgressDialog.addMessageWithLine(progress, "re-creating index file " + indexFileName);
			MSIndexFileCreator.createIndexFile(filePath + list[i]); //text.append("Index files are required");
		    }

		    ht.put(filePath + list[i], iFile);   
		}

		break;
	    default:
		break;
	}

        
        return ht;
    }
    
    private int[] getComplementaryComposition(int[] totalEle, int[] element, int[] nterm, int[] cterm)
    {
        int[] temp = new int[element.length];
        
        for(int i=0;i<element.length;i++)
        {
            temp[i] = totalEle[i]-element[i] + nterm[i] + cterm[i];
            //System.out.println("ele==>>" + temp[i]);
        }                   
       
        return temp;
    }

/*
    private static Element createXmlChroHeader(boolean isDataDependent)
    {
        return createXmlChroHeader( isDataDependent?0:1 );
    }
  */
    private static Element createXmlChroHeader(int quantLevel)
    {
        return createXmlChroHeader(quantLevel, -1);
    }
    
    //quantLevel 1 for MS1, 2 for MS2, and so on
    private static Element createXmlChroHeader(int quantLevel, int expType)
    {
        //expType 13: iTRAQ single spectrum
        //expType 14: iTRAQ multiple spectra
        Element root = new Element("relex_chro");

        Element version = new Element("version");
        version.setText("Census v. " + conf.getVersion() + " Chro file");
        root.addContent(version);

        Element author = new Element("author");
        author.setAttribute("name", "Robin, Sung Kyu Park");
        author.setAttribute("email", "rpark@scripps.edu");
        root.addContent(author);

        author = new Element("author");
        author.setAttribute("name", "John Venable");
        author.setAttribute("email", "jvenable@gnf.org");        
        root.addContent(author);

        Element createdDate = new Element("created_date");
        createdDate.setText(new Date().toString());
        root.addContent(createdDate);

        Element dataDependency = new Element("data_dependency");        
        dataDependency.setText( String.valueOf(quantLevel) );
        /*
        if(isDataDependent)
            dataDependency.setText("0");
        else
            dataDependency.setText("1");
*/
        Element quantLevelEle = new Element("quantLevel");
        quantLevelEle.setText( String.valueOf(quantLevel) );
        
        //System.out.println("exp type==============" + expType);
        
        if(expType>0)
        {
            Element expTypeEle = new Element("experiment_type");
            expTypeEle.setText( String.valueOf(expType) );
            root.addContent(expTypeEle);
        }
        
        root.addContent(dataDependency);
        root.addContent(quantLevelEle);

        //0:data dependent, 1:data independent\n");

        return root; 
    }

    private String createChroHeader(boolean isDataDependent)
    {
        StringBuffer sb = new StringBuffer();
        sb.append("H\t").append("Census v. 2.0 Chro file\n");        
        sb.append("H\t").append("Create by John Venable jvenable@scripps.edu\n");
        sb.append("H\t").append("Robin, Sung Kyu Park rpark@scripps.edu\n");
//        sb.append("H\t").append("Michael J. MacCoss \n");
        sb.append("H\t").append("The Scripps Research Institute, La Jolla, CA\n");
        sb.append("H\t").append("created date\t").append(new Date()).append("\n");
        sb.append("H\t").append("data_dependency\t");
        
        if(isDataDependent)
            sb.append("0");
        else
            sb.append("1");
        
        sb.append("\t; 0:data dependent, 1:data independent\n");
        sb.append("H\t\n");

        return sb.toString();
                    
    }

  
  
    private Element createXmlChroPeptideTitle(boolean isDataDependent, Peptide peptide)
    {
        Element peptideEle = new Element("peptide");
        peptideEle.setAttribute("unique", peptide.isUnique()?"*":"");
        peptideEle.setAttribute("file", peptide.getFileName());
        peptideEle.setAttribute("scan", peptide.getScanNum());
        peptideEle.setAttribute("seq", peptide.getSequence());
        peptideEle.setAttribute("xcorr", peptide.getXCorr());
	if(null == peptide.getDeltCN())
	    peptideEle.setAttribute("deltaCN", "");

        peptideEle.setAttribute("charge", peptide.getChargeState());
        peptideEle.setAttribute("spC", peptide.getRedundancy());  

//        if(conf.getCalcRefAvgMass()>0)
//        {
//            peptideEle.setAttribute("lightMass", String.valueOf(conf.getCalcSamAvgMass()));  
  //          peptideEle.setAttribute("heavyMass", String.valueOf(conf.getCalcRefAvgMass()));
  //      }


	Hashtable<String, String> scoreHt = peptide.getScoreHt();
	for(Iterator<String> itrScr=scoreHt.keySet().iterator(); itrScr.hasNext(); )
	{
	    String score = itrScr.next();
	    String value = scoreHt.get(score);

	    Element scoreEle = new Element("search_score");
	    scoreEle.setAttribute("name", score);
	    scoreEle.setAttribute("value", value);
	    peptideEle.addContent(scoreEle);
	} 


	return peptideEle;
    }

    private Element createXmlMrmChroPeptideTitle(boolean isDataDependent, Peptide peptide)
    {
        Element peptideEle = new Element("peptide");
        peptideEle.setAttribute("unique", peptide.isUnique()?"*":"");
        peptideEle.setAttribute("file", peptide.getFileName());
//        peptideEle.setAttribute("scan", peptide.getScanNum());
        peptideEle.setAttribute("seq", peptide.getSequence());
        peptideEle.setAttribute("xcorr", peptide.getXCorr());
        peptideEle.setAttribute("deltaCN", peptide.getDeltCN()); 
        peptideEle.setAttribute("charge", peptide.getChargeState());

        return peptideEle;
    }

/*
    private String createChroPeptideTitle(boolean isDataDependent, Peptide peptide)
    {
        StringBuffer sb = new StringBuffer();
        
        sb.append("[PEPTIDE]Unique\tFile Name\tScan Num\tSequence\tXCorr\tDentaCN\tCharge");
        
        if(isDataDependent)
            sb.append("\n");
        else
            sb.append("\tStartScan\tEndScan\n");
            //sb.append("\tStartScan\tEndScan\tDTAPeakStart\tDTAPeakEnd\n");
        
        sb.append(peptide.isUnique()?"*":"").append("\t");
        sb.append(peptide.getFileName()).append("\t");
        sb.append(peptide.getScanNum()).append("\t");
        sb.append(peptide.getSequence()).append("\t");
        sb.append(peptide.getXCorr()).append("\t");
        sb.append(peptide.getDeltCN()).append("\t");
        sb.append(peptide.getChargeState());
        
        if(isDataDependent)
            sb.append("\n");
        else
            sb.append("\t");
        
        return sb.toString();
    }
  */ 
    public void createMRMFragmentIons(ChroProgressDialog progress) throws IOException, Exception
    {


        this.progress = progress;
        int[] keys;

        this.filePath = conf.getFilePath();
                    
	conf.readSimpleXml(filePath + "census_config.xml");
	conf.setIdFileName(filePath + "DTASelect-filter.txt");
 
        Hashtable<String, IndexedFile> ht = createIndexedFiles(filePath, CensusConstants.MS2_FILE);
        
        IndexedFile iFile;
        BufferedOutputStream out = null;
        PrintStream p = null;
        
        long startTime = System.currentTimeMillis();
        String pepSequence=null;
        
        try
        {    
            
            /******************************************************************
             *  Read DTASelect.txt file to find spectrum range for each peptide
             ******************************************************************/
            
            ChroProgressDialog.addMessageWithLine(progress, "");
            
            IsotopeReader isoReader = new IsotopeReader(conf.getRootConfEle());
            
            SpecRangeGenerator rangeGen = null;            
            File dtaFile = new File(filePath + "DTASelect.txt");
            IdentificationReader idReader = BaseIdentificationReader.getIdentificationInst(isoReader);

            if(dtaFile.exists()) {                
                System.out.print("Parsing DTASelect.txt...");
                ChroProgressDialog.addMessageWithLine(progress, "Parsing DTASelect.txt...");                
                rangeGen = SpecRangeGenerator.getSpecRangeGenerator(idReader);
    
                System.out.println("done.");

            } else {
                rangeGen = new SpecRangeGenerator();
            }
            
            
            
            
//            ChroProgressDialog.addMessageWithLine(progress, "done");
            TIntLongHashMap index;
            
            
            IsotopeTable<String, int[]> isoTable = isoReader.getIsotope();
            //IsotopeTable<String, int[]> isoTable = IsotopeReader.getStandardIsotopeTable();
            
            int[] sampleNterm = isoTable.get("sampleNTERM");
            int[] sampleCterm = isoTable.get("sampleCTERM");
           
            //int redundantPeptideNum = idReader.getRedundantPeptideNum();
            int redundantPeptideNum = idReader.getTotalPeptideNumber();
            //increase status bar
            double percent = 0.0;
            double eachSeg = 100.0/redundantPeptideNum;
            int pepCount=0;
                        
            IsotopeDist sampleDist;
            Protein protein;
            Peptide peptide;
            
            Element rootEle = this.createXmlChroHeader(2);
            
            ElementComposition element;
            ElementComposition totalElement;
            
            //int[] elementSampleArr;            
            int keyIndex;
            int start;
            int last;

            double samplePrecursor;
            double refPrecursor;
            
            double[][] bionSample;
            double[][] bionRef;
            double[][] yionSample;
            double[][] yionRef;
            
            Element proteinEle=null;
            Element peptideEle=null;

            for (Iterator<Protein> itr = idReader.getProteins(); itr.hasNext(); ) {
                protein = itr.next();
              
                proteinEle = new Element("protein");
                proteinEle.setAttribute("locus", protein.getLocus());
                proteinEle.setAttribute("seq_ct", protein.getSeqCount());
                proteinEle.setAttribute("spec_ct", protein.getSpectrumCount());
                proteinEle.setAttribute("seq_cov", protein.getSeqCoverage());
                proteinEle.setAttribute("length", protein.getLength());
                proteinEle.setAttribute("molwt", protein.getMolWt());
                proteinEle.setAttribute("pi", protein.getPI());
                proteinEle.setAttribute("val", protein.getValidation());

		try {
		    proteinEle.setAttribute("desc", protein.getDescription());
		} catch (org.jdom.IllegalDataException ide) {
		    proteinEle.setAttribute("desc", StringUtil.removeIsoControlChar(protein.getDescription()) );
		}

                for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); ) 
                {                    
                    peptide = pepItr.next();
                    pepCount++;

                    pepSequence = peptide.getSequence();

		    //System.out.println(pepSequence);
		    //System.out.println("");

                    //What is the purpose of hs???
                    char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();
                    
                    try {
                        totalElement = new ElementComposition(ch, 0, ch.length, isoTable);                    
                        totalElement.lightCalculate();

                    } catch (InvalidAAException ive)
                    {
                        System.out.println("Not Quantifiable peptide : " + pepSequence);
		    
			percent += eachSeg;
			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);
			}
                        continue;                        
                    }                    
                    
                    int chargeState = Integer.parseInt(peptide.getChargeState());
                    
                    IsotopeDist totalDist = new IsotopeDist(totalElement.getElementSampleArr(), totalElement.getModShift(), true);

                    
                    
                    int pepLength=0;
                    
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;

                        pepLength++;
                    }

                    bionSample = new double[pepLength][chargeState*3];
                  //  bionRef = new double[pepLength][chargeState*3];
                    //Yions
                    yionSample = new double[pepLength][chargeState*3];
                    //yionRef = new double[pepLength][chargeState*3];

                    int pepIndex=0;

                    
                    //System.out.println("aamass" + massTolerance + " " + conf.getMassTolerance());
  
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;

                        element = new ElementComposition(ch, 0, i+1, isoTable);
                        element.lightCalculate();

                        //Y ions
                        sampleDist = new IsotopeDist(
                                getComplementaryComposition(totalElement.getElementSampleArr(), element.getElementSampleArr(), sampleNterm, sampleCterm), element.getModShift(), true);
                        
                        switch(chargeState)
                        {
                            case 3:
                                yionSample[(pepIndex+1)%pepLength][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                                yionSample[(pepIndex+1)%pepLength][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;
                                
                            case 2:
                                yionSample[(pepIndex+1)%pepLength][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                                yionSample[(pepIndex+1)%pepLength][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                                
                            case 1:
                                yionSample[(pepIndex+1)%pepLength][2] = sampleDist.getEndMass()+1*PROTON_MASS+massTolerance; //add proton to give b fragment ion
                                yionSample[(pepIndex+1)%pepLength][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][0] = sampleDist.getAvgMass()+1*PROTON_MASS;

                            default:
                                break;         
                        }
                      
                        element.calculateBion();
                        sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    
                        //refDist = new IsotopeDist(element.getElementRefArr(), false);            
    
                        switch(chargeState)
                        {
                            case 3:
                                bionSample[pepIndex][8] = (sampleDist.getEndMass()+2*PROTON_MASS)/3+massTolerance;
                                bionSample[pepIndex][7] = (sampleDist.getStartMass()+2*PROTON_MASS)/3-massTolerance;
                                bionSample[pepIndex][6] = (sampleDist.getAvgMass()+2*PROTON_MASS)/3;
                                
                            case 2:
                                bionSample[pepIndex][5] = (sampleDist.getEndMass()+1*PROTON_MASS)/2+massTolerance;
                                bionSample[pepIndex][4] = (sampleDist.getStartMass()+1*PROTON_MASS)/2-massTolerance;
                                bionSample[pepIndex][3] = (sampleDist.getAvgMass()+1*PROTON_MASS)/2;
                                
                            case 1:
                                bionSample[pepIndex][2] = sampleDist.getEndMass()+massTolerance;
                                bionSample[pepIndex][1] = sampleDist.getStartMass()-massTolerance;
                                bionSample[pepIndex][0] = sampleDist.getAvgMass();

                            default:
                                break;                                
                                
                        }                        
                        
                        pepIndex++;
                     
                    }
                    
                    element = new ElementComposition(ch, 0, ch.length, isoTable);                    
                    element.lightCalculate();
                    
                    sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    

                    switch(chargeState)
                    {
                        case 3:
                            yionSample[0][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                            yionSample[0][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                            yionSample[0][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;

                        case 2:
                            yionSample[0][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                            yionSample[0][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                            yionSample[0][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                        case 1:                        
                            yionSample[0][2] = sampleDist.getEndMass()+1*PROTON_MASS+massTolerance; //add proton to give b fragment ion
                            yionSample[0][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                            yionSample[0][0] = sampleDist.getAvgMass()+1*PROTON_MASS;

                            //System.out.println(sampleDist.getAvgMass() + " " + yionSample[0][0] + " " + yionSample[0][1] + " " + yionSample[0][2]);                            
                        default:
                            break;                                

                    }
                    
                    peptideEle = this.createXmlChroPeptideTitle(false, peptide);
                     
                    String ms2FileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf("."));                    
                    
                    StringBuffer rangeKey = new StringBuffer();                    
                    rangeKey.append(protein.getLocus());
                    rangeKey.append(ms2FileName);
                    rangeKey.append(peptide.getSequence().substring(2, peptide.getSequence().length()-2));
                    SpecRange range = rangeGen.getSpecRange( rangeKey.toString() );
                    
		    if(null==range)
		    {
                        int tmpScanNum = Integer.parseInt(peptide.getScanNum());
                        range = new SpecRange( tmpScanNum, tmpScanNum );                        
                        peptideEle.setAttribute("start_scan", peptide.getScanNum());
                        peptideEle.setAttribute("end_scan", peptide.getScanNum());
                    }
                    else
                    {
                        peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                        peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));                        
                    }

                    peptideEle.setAttribute("MHPlus", String.valueOf(Formatter.formatDecimal(totalDist.getAvgMass() + PROTON_MASS)));
                    peptideEle.setAttribute("CalcMHplus", peptide.getCalcMHplus());
                    
                    Element chro = new Element("chro"); //scan # and intensity
                    //output.append("[CHROMATOGRAMS]\tSCAN\tSAMPLE\tREFERENCE\n");
                    
                    iFile = ht.get( this.filePath + ms2FileName + "." + "ms2");
                    keys = iFile.getKeys();                   
                    keyIndex = Arrays.binarySearch(keys, Integer.parseInt(peptide.getScanNum()));
                    
                    if(keyIndex<0) //Cannot find index
                        keyIndex=-(++keyIndex); //Math.abs(++keyIndex);                    

                    //System.out.println("key" + keyIndex);
                    
                    samplePrecursor=1;
                    refPrecursor=1;
                    

                    TIntDoubleHashMap precursorMap = iFile.getPrecursorMap();

                    double calcSamMass = (sampleDist.getAvgMass()+chargeState*PROTON_MASS)/chargeState;
                    
                    conf.setCalcSamAvgMass(calcSamMass);
		    peptideEle.setAttribute("lightStartMass", String.valueOf(sampleDist.getStartMass()));  
		    peptideEle.setAttribute("lightAvgMass", String.valueOf(conf.getCalcSamAvgMass()));  
                    

                    try {
                        
                        double[] d = CalcUtil.readSpectrum(keys, keyIndex, iFile, bionSample, yionSample );
                        StringBuffer sb = new StringBuffer();

                        for(int i=0;i<2;i++)
                            sb.append(d[i]).append(" ");
                        
                        sb.append(";");
                        for(int i=2;i<d.length;i++)
                        {
                                if(i==(d.length/2+1))
                                sb.append(";");

                                sb.append(d[i]).append(" ");
                        }
//	System.out.println(d[i]);
                       chro.setText(sb.toString()); //CalcUtil.readSpectrum(keys, keyIndex, iFile, bionSample, yionSample ));                

                    //} catch (PrecursorNotFoundException ive)
                    } catch (Exception ive)
                    {
                        System.out.println("Precursor not found for " + pepSequence);                        
                        ChroProgressDialog.addMessageWithLine(progress, "Error : Precursor not found for " + pepSequence);
                        percent += eachSeg;
		
			if(null != progress)
                        progress.setProgress((int)percent);
                        
                        continue;                        
                    }                    

                    
                    peptideEle.addContent(chro);

                    Element fragEle = new Element("frag");
                    
                    Element bSample = new Element("bs");
                    StringBuffer tempSb = new StringBuffer();
                    for(int i=0;i<bionSample.length;i++)
                    {
                        int j;
                        for(j=0;j<bionSample[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(bionSample[i][j]) ).append(" ");
                        }
                      
                        tempSb.append( formatter.format(bionSample[i][j]) ).append(",");
                    }

                    bSample.setText(tempSb.toString());
                    fragEle.addContent(bSample);
                   
//                    Element bRef = new Element("br");
                    tempSb.delete(0, tempSb.length());

                    Element ySample = new Element("ys");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<yionSample.length;i++)
                    {
                        int j;
                        for(j=0;j<yionSample[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(yionSample[i][j]) ).append(" ");
                            
                        }
                        
                        tempSb.append( formatter.format(yionSample[i][j]) ).append(",");
                    }

                    ySample.setText(tempSb.toString());
                    fragEle.addContent(ySample);
                    tempSb.delete(0, tempSb.length());

                    peptideEle.addContent(fragEle);

                    percent += eachSeg;

			if(null != progress)
                    progress.setProgress((int)percent);         
                    
                    System.out.print(pepCount);
                    System.out.print("/");
                    System.out.print(redundantPeptideNum);
                    System.out.print(" peptides, ");
                    System.out.print((int)percent);
                    //System.out.print(" % is complete\n");
                    System.out.print(" % is complete\r");

                    proteinEle.addContent(peptideEle);
                    
                }

                
                if(proteinEle.getChildren().size()>0)
                    rootEle.addContent(proteinEle);

            }
          
            Document doc = new Document(rootEle);
            OutputStream os = new FileOutputStream(filePath + "mrm_frags.xml");
            XMLOutputter outputter = new XMLOutputter();
	    outputter.setFormat(Format.getPrettyFormat());
            outputter.output(doc, os);
            os.close();
            System.out.println("\n100% complete");
            //System.out.println( System.out.println"\n100% complete");
          
        }
        catch (IOException e)
        {
            System.out.println("IO Error while generating chro file : " + pepSequence + e);
            e.printStackTrace();
            throw new IOException(e.toString());
        }
        catch (Exception e)
        {
            System.out.println("Error while generating chro file : " + pepSequence + e);
            e.printStackTrace();
            throw new Exception(e.toString());
        }
        finally
        {
            if(null != p)
                p.close();
            
            if(null != out)
                out.close();

            //Close all random files
            for (Enumeration e = ht.keys(); e.hasMoreElements(); ) 
            {
                iFile = ht.get(e.nextElement());

                if(null != iFile)
                    iFile.close();
            }
   
        }
    }
    
    //iTRAQ data
    public void createMsmsSpecificChro() throws IOException, Exception
    {
        createMsmsSpecificChro(null);
    }
    
    public void createMsmsSpecificChro(ChroProgressDialog progress) throws IOException, Exception
    {

        this.progress = progress;
        int[] keys;
        
        this.filePath = conf.getFilePath();
                       
        Hashtable<String, IndexedFile> ht = createIndexedFiles(filePath, CensusConstants.MS2_FILE);

	//////////////////// remove this later robin
//	Hashtable<String, IndexedFile> hcdht = createIndexedFiles("/home/rpark/rpark_on_data/project/xmhan/pqd_hcd_comparison/hcd_cid_comparison/CIDHCD-091808OT3/hcd", CensusConstants.MS2_FILE);

       
        IndexedFile iFile;
        BufferedOutputStream out = null;
        PrintStream p = null;

        long startTime = System.currentTimeMillis();
        String pepSequence=null;
        
        try
        {    
            
            /******************************************************************
             *  Read DTASelect.txt file to find spectrum range for each peptide
             ******************************************************************/         
            ChroProgressDialog.addMessageWithLine(progress, "");

            IsotopeReader isoReader = null;
            
            if(conf.isXmlConf())
                isoReader = new IsotopeReader(conf.getRootConfEle());
            else
                isoReader = new IsotopeReader(isotopeFile);
            
            SpecRangeGenerator rangeGen = null;            
            File dtaFile = new File(filePath + "DTASelect.txt");
            IdentificationReader idReader = BaseIdentificationReader.getIdentificationInst(isoReader);                        
            int redundantPeptideNum = idReader.getTotalPeptideNumber();
            
            if(dtaFile.exists()) {                
                System.out.print("Parsing DTASelect.txt...");
                ChroProgressDialog.addMessageWithLine(progress, "Parsing DTASelect.txt...");
                rangeGen = SpecRangeGenerator.getSpecRangeGenerator(idReader);    
                System.out.println("done.");                
            } else {
                rangeGen = new SpecRangeGenerator();                
            }            
            
            //DTASelectFilterReader dtaReader = new DTASelectFilterReader(conf.getIdFileName());


            //SpecRangeGenerator rangeGen = new SpecRangeGenerator(this.filePath + this.dtaSelectFile, idReader.isVersion2(), idReader.getConfidence());
            
            Hashtable tempht = rangeGen.getTable();
            
            
            ChroProgressDialog.addMessageWithLine(progress, "done");
            TIntLongHashMap index;
            
            
            IsotopeTable<String, int[]> isoTable = isoReader.getIsotope();
            
            //increase status bar
            double percent = 0.0;
            double eachSeg = 100.0/redundantPeptideNum;
            int pepCount=0;
                        
            Protein protein;
            Peptide peptide;
            
            Element rootEle = null;
            
            
            
            if(conf.getMsmsSpectrumNum() == conf.MSMS_SINGLE_SPECTRUM)
            {
                rootEle = this.createXmlChroHeader(2, CensusConstants.MSMS_SPECIFIC_SINGLE_MASS);
            }
            else if(conf.getMsmsSpectrumNum() == conf.MSMS_MULTIPLE_SPECTRA)
            {
                rootEle = this.createXmlChroHeader(2, CensusConstants.MSMS_SPECIFIC_MULTIPLE_MASS);
            }
            else
            {
                System.out.println("Cannot find spectral extraction type");
                throw new Exception("Cannot find spectral extraction type");
            }
                
            ElementComposition element;
            ElementComposition totalElement;
            
            //int[] elementSampleArr;            
            int keyIndex;
            int start;
            int last;

            double samplePrecursor;
            double refPrecursor;
            
//            double[][] bionSample;
//            double[][] bionRef;
//            double[][] yionSample;
//            double[][] yionRef;
            
            Element proteinEle=null;
            Element peptideEle=null;

            for (Iterator<Protein> itr = idReader.getProteins(); itr.hasNext(); ) {
                protein = itr.next();
              
                proteinEle = new Element("protein");
                proteinEle.setAttribute("locus", protein.getLocus());
                proteinEle.setAttribute("seq_ct", protein.getSeqCount());
                proteinEle.setAttribute("spec_ct", protein.getSpectrumCount());
                proteinEle.setAttribute("seq_cov", protein.getSeqCoverage());
                proteinEle.setAttribute("length", protein.getLength());
                proteinEle.setAttribute("molwt", protein.getMolWt());
                proteinEle.setAttribute("pi", protein.getPI());
                proteinEle.setAttribute("val", protein.getValidation());

		try {
		    proteinEle.setAttribute("desc", protein.getDescription());
		} catch (org.jdom.IllegalDataException ide) {
		    proteinEle.setAttribute("desc", StringUtil.removeIsoControlChar(protein.getDescription()) );
		}

                for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); ) 
                {                    
                    peptide = pepItr.next();
                    pepCount++;

                    pepSequence = peptide.getSequence();


		    //System.out.println(pepSequence);
		    //System.out.println("");
                    //System.out.println("");
                    
                    char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();
                    
                    try {
                        totalElement = new ElementComposition(ch, 0, ch.length, isoTable);                    
                        totalElement.lightCalculate();
                    } catch (InvalidAAException ive)
                    {
                        System.out.println("Not Quantifiable peptide - invalid amino acid : " + pepSequence);

                        percent += eachSeg;
			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide - invalid amino acid : " + pepSequence);
			    progress.setProgress((int)percent);
			}

                        continue;                        
                    }
                    
                    int chargeState = Integer.parseInt(peptide.getChargeState());
                   
                    int pepLength=0;
                    
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;

                        pepLength++;
                    }

                    //bionSample = new double[pepLength][chargeState*3];
                    //bionRef = new double[pepLength][chargeState*3];
                    //Yions
                    //yionSample = new double[pepLength][chargeState*3];
                    //yionRef = new double[pepLength][chargeState*3];

                    int pepIndex=0;

                    
                    //System.out.println("aamass" + massTolerance + " " + conf.getMassTolerance());
                    
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;
                    
			try {
			    element = new ElementComposition(ch, 0, i+1, isoTable);
			    element.lightCalculate(); 
                            
			} catch (InvalidAAException ive)
			{
			    System.out.println("Not Quantifiable peptide : " + pepSequence);

			    percent += eachSeg;
			    if(null != progress)
			    {
				ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
				progress.setProgress((int)percent);

			    }
			    continue;                        
			}

                        pepIndex++;
                    }
                    

                    
                    peptideEle = this.createXmlChroPeptideTitle(false, peptide);
                   
                    //String ms2FileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf("."));                    
                    String ms2FileName = peptide.getFileName();

                    StringBuffer rangeKey = new StringBuffer();                    
                    rangeKey.append(protein.getLocus());
                    rangeKey.append(ms2FileName);
                    rangeKey.append(peptide.getSequence().substring(2, peptide.getSequence().length()-2));
                    SpecRange range = rangeGen.getSpecRange( rangeKey.toString() );
                    
		    if(null==range)
		    {
                        int tmpScanNum = Integer.parseInt(peptide.getScanNum());
                        range = new SpecRange( tmpScanNum, tmpScanNum );                        
                        peptideEle.setAttribute("start_scan", peptide.getScanNum());
                        peptideEle.setAttribute("end_scan", peptide.getScanNum());
                    }
                    else
                    {
                        peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                        peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));                        
                    }

                    //sb.append("\tStartScan\tEndScan\tDTAPeakStart\tDTAPeakEnd\n");
                   
                    Element chro = new Element("chro");
                    //output.append("[CHROMATOGRAMS]\tSCAN\tSAMPLE\tREFERENCE\n");
                    
                    iFile = ht.get( this.filePath + ms2FileName + "." + "ms2");

                    keys = iFile.getKeys();

                    keyIndex = Arrays.binarySearch(keys, Integer.parseInt(peptide.getScanNum()));
                    
                    if(keyIndex<0) //Cannot find index
                        keyIndex=-(++keyIndex); //Math.abs(++keyIndex);                    

                    samplePrecursor=1;
                    refPrecursor=1;
                    
                    TIntDoubleHashMap precursorMap = iFile.getPrecursorMap();

		   
/*
		    boolean cid_hcd_convert=false;
		    if(cid_hcd_convert) {
			double precursor = precursorMap.get(keys[keyIndex]);

			IndexedFile iHcdFile = hcdht.get("/home/rpark/rpark_on_data/project/xmhan/pqd_hcd_comparison/hcd_cid_comparison/CIDHCD-091808OT3/hcd/" + ms2FileName.replace("cid", "hcd") + "." + "ms2");
			int[] hcdKeys = iHcdFile.getKeys();
			int hcdKeyIndex = Arrays.binarySearch(hcdKeys, Integer.parseInt(peptide.getScanNum()));
                    
			if(hcdKeyIndex<0) //Cannot find index
			    hcdKeyIndex=-(++hcdKeyIndex); //Math.abs(++keyIndex);                    

			TIntDoubleHashMap hcdPrecursorMap = iHcdFile.getPrecursorMap();

		//	System.out.println("");
		//	System.out.println("");
		//	System.out.println(peptide.getSequence() + "\t" + peptide.getScanNum() + "\t" + hcdKeys[hcdKeyIndex] + "\t" + hcdPrecursorMap.get(hcdKeys[hcdKeyIndex]));		

			int findRange=5;
			boolean found=false;
			
			for(int ii=hcdKeyIndex-findRange;ii<hcdKeyIndex+findRange;ii++) {
			    if(precursor== hcdPrecursorMap.get(hcdKeys[ii])) {
				found=true;
				hcdKeyIndex = ii;
				break;
			    }
			}

			if(!found) {
			    System.out.println("Oops... couldn't find mapping precursor");
			    System.out.println(peptide.getSequence() + "\t" + peptide.getScanNum() + "\t" + hcdKeys[hcdKeyIndex] + "\t" + hcdPrecursorMap.get(hcdKeys[hcdKeyIndex]));		
			    System.exit(0);
			}

			//System.out.println(peptide.getSequence() + "\t" + peptide.getScanNum() + "\t" + hcdKeys[hcdKeyIndex] + "\t" + hcdPrecursorMap.get(hcdKeys[hcdKeyIndex]));		

		//	System.out.println("");
		//	System.out.println("");
		//	System.out.println("");

			iFile = iHcdFile;
			keyIndex = hcdKeyIndex;

		    }
		*/	


                    try {
                        String outStr = CalcUtil.calculateMS2Mass( iFile, range, keyIndex, null, null, null, null, conf, chargeState); 
			chro.setText(outStr);                        
                    } catch (PrecursorNotFoundException ive)
                    {
                        System.out.println("Precursor not found for " + pepSequence);                        
                        ChroProgressDialog.addMessageWithLine(progress, "Error : Precursor not found for " + pepSequence);
                        percent += eachSeg;
                        progress.setProgress((int)percent);

                        continue;                        
                    }                    

                    peptideEle.addContent(chro);


                    percent += eachSeg;

		    if(null != progress)
			progress.setProgress((int)percent);         
       
                    System.out.print(pepCount);
                    System.out.print("/");
                    System.out.print(redundantPeptideNum);
                    System.out.print(" peptides, ");
                    System.out.print((int)percent);
                    //System.out.print(" % is complete\n");
                    System.out.print(" % is complete\r");

                    proteinEle.addContent(peptideEle);
                }

                if(proteinEle.getChildren().size()>0)
                    rootEle.addContent(proteinEle);
            }
          

            Document doc = new Document(rootEle);
            OutputStream os = new FileOutputStream(filePath + "census_chro.xml");
            XMLOutputter outputter = new XMLOutputter();
	    outputter.setFormat(Format.getPrettyFormat());
            outputter.output(doc, os);
            os.close();

            System.out.println("\n100% complete");
            //System.out.println( System.out.println"\n100% complete");
        
        }
        catch (IOException e)
        {
            System.out.println("IO Error while generating msms chro file : " + pepSequence + e);
            e.printStackTrace();
            throw new IOException(e.toString());
        }
        catch (java.lang.IndexOutOfBoundsException e)
        {
            System.out.println("Error while generating msms chro file : " + pepSequence + e);
            e.printStackTrace();
            throw new Exception(e.toString());
        }
        catch (Exception e)
        {
            System.out.println("Error while generating msms chro file : " + pepSequence + e);
            e.printStackTrace();
            throw new Exception(e.toString());
        }
        finally
        {
            if(null != p)
                p.close();
            
            if(null != out)
                out.close();

            //Close all random files
            for (Enumeration e = ht.keys(); e.hasMoreElements(); ) 
            {
                iFile = ht.get(e.nextElement());

                if(null != iFile)
                    iFile.close();
            }

            
        }

    }
   
    //include data independent
    public void createMsmsXmlChro() throws IOException, Exception
    {
        createMsmsXmlChro(null);
    }
    
    public void createMsmsXmlChro(ChroProgressDialog progress) throws IOException, Exception
    {

        this.progress = progress;
        int[] keys;
        
        this.filePath = conf.getFilePath();
                
        //if( !filePath.endsWith(File.separator) )
        //    filePath += File.separator;
        
/*
        //file could be generated from either linux or window
        if( !this.filePath.endsWith("/") && !this.filePath.endsWith("\\") ) {
            //for linux
            if(this.filePath.startsWith("/"))
                this.filePath += "/";
            else //for window
                this.filePath += "\\";
        }
        */
        
        Hashtable<String, IndexedFile> ht = createIndexedFiles(filePath, CensusConstants.MS2_FILE);
       
        IndexedFile iFile;
        BufferedOutputStream out = null;
        PrintStream p = null;
        
        long startTime = System.currentTimeMillis();
        String pepSequence=null;
        
        try
        {    
            
            /******************************************************************
             *  Read DTASelect.txt file to find spectrum range for each peptide
             ******************************************************************/         
            ChroProgressDialog.addMessageWithLine(progress, "");

            IsotopeReader isoReader = null;
            
            if(conf.isXmlConf())
                isoReader = new IsotopeReader(conf.getRootConfEle());
            else
                isoReader = new IsotopeReader(isotopeFile);

            IdentificationReader idReader = BaseIdentificationReader.getIdentificationInst(isoReader);
            SpecRangeGenerator rangeGen = new SpecRangeGenerator();
            int redundantPeptideNum = idReader.getTotalPeptideNumber();

/*
            System.out.print("Parsing DTASelect.txt...");
            ChroProgressDialog.addMessageWithLine(progress, "Parsing DTASelect.txt...");
            IdentificationReader idReader = BaseIdentificationReader.getIdentificationInst(filePath);
            int redundantPeptideNum = idReader.getTotalPeptideNumber();
            SpecRangeGenerator rangeGen = SpecRangeGenerator.getSpecRangeGenerator(idReader);
            Hashtable tempht = rangeGen.getTable();
            System.out.println("done.");
            ChroProgressDialog.addMessageWithLine(progress, "done");
*/
            TIntLongHashMap index;
            
                
            //IsotopeReader isoReader = new IsotopeReader(isotopeFile);
            
            
            IsotopeTable<String, int[]> isoTable = isoReader.getIsotope();
            int[] sampleNterm = isoTable.get("sampleNTERM");
            int[] sampleCterm = isoTable.get("sampleCTERM");
            int[] refNterm = isoTable.get("refNTERM");
            int[] refCterm = isoTable.get("refCTERM");
           
            //int redundantPeptideNum = -1; //dtaReader.getRedundantPeptideNum();
            //int redundantPeptideNum = DTASelectFilterReader.getTotalPeptideNumber(conf.getIdFileName());

            //increase status bar
            double percent = 0.0;
            double eachSeg = 100.0/redundantPeptideNum;
            int pepCount=0;
                        
            //IsotopeDist sampleDist;
            //IsotopeDist refDist;
            IsotopeDist sampleDist;
            IsotopeDist refDist;
            Protein protein;
            Peptide peptide;
            
            Element rootEle = this.createXmlChroHeader(2, conf.getExpType());
            
            ElementComposition element;
            ElementComposition totalElement;
            
            //int[] elementSampleArr;            
            int keyIndex;
            int start;
            int last;

            double samplePrecursor;
            double refPrecursor;
            
            double[][] bionSample;
            double[][] bionRef;
            double[][] yionSample;
            double[][] yionRef;
            
            Element proteinEle=null;
            Element peptideEle=null;

            for (Iterator<Protein> itr = idReader.getProteins(); itr.hasNext(); ) {
                protein = itr.next();
              
                proteinEle = new Element("protein");
                proteinEle.setAttribute("locus", protein.getLocus());
                proteinEle.setAttribute("seq_ct", protein.getSeqCount());
                proteinEle.setAttribute("spec_ct", protein.getSpectrumCount());
                proteinEle.setAttribute("seq_cov", protein.getSeqCoverage());
                proteinEle.setAttribute("length", protein.getLength());
                proteinEle.setAttribute("molwt", protein.getMolWt());
                proteinEle.setAttribute("pi", protein.getPI());
                proteinEle.setAttribute("val", protein.getValidation());

		try {
		    proteinEle.setAttribute("desc", protein.getDescription());
		} catch (org.jdom.IllegalDataException ide) {
		    proteinEle.setAttribute("desc", StringUtil.removeIsoControlChar(protein.getDescription()) );
		}

                for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); ) 
                {                    
                    peptide = pepItr.next();
                    pepCount++;

                    pepSequence = peptide.getSequence();

                    //What is the purpose of hs???
                    char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();
                    
                    try {
                        totalElement = new ElementComposition(ch, 0, ch.length, isoTable);                    
                        totalElement.calculate();
                    } catch (InvalidAAException ive)
                    {
                        System.out.println("Not Quantifiable peptide : " + pepSequence);

                        percent += eachSeg;
			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);

			}
                        continue;                        
                    }
                    
                    int chargeState = Integer.parseInt(peptide.getChargeState());
                   
                    int pepLength=0;
                    
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;

                        pepLength++;
                    }

                    bionSample = new double[pepLength][chargeState*3];
                    bionRef = new double[pepLength][chargeState*3];
                    //Yions
                    yionSample = new double[pepLength][chargeState*3];
                    yionRef = new double[pepLength][chargeState*3];

                    int pepIndex=0;

                    
                    //System.out.println("aamass" + massTolerance + " " + conf.getMassTolerance());
                    
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;
                    
			try {
			    element = new ElementComposition(ch, 0, i+1, isoTable);
			    element.calculate();

			} catch (InvalidAAException ive)
			{
			    System.out.println("Not Quantifiable peptide : " + pepSequence);

			    percent += eachSeg;
			    if(null != progress)
			    {
				ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
				progress.setProgress((int)percent);

			    }
			    continue;                        
			}

                        //Y ions
                        sampleDist = new IsotopeDist(
                                getComplementaryComposition(totalElement.getElementSampleArr(), element.getElementSampleArr(), sampleNterm, sampleCterm), element.getModShift(), true);
                        
                        refDist = new IsotopeDist(
                                getComplementaryComposition(totalElement.getElementRefArr(), element.getElementRefArr(), refNterm, refCterm), element.getModShift(), false);   //fix this
                        
                        switch(chargeState)
                        {
                            case 3:
                                yionSample[(pepIndex+1)%pepLength][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                                yionSample[(pepIndex+1)%pepLength][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;
                                yionRef[(pepIndex+1)%pepLength][8] = (refDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                                yionRef[(pepIndex+1)%pepLength][7] = (refDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                                yionRef[(pepIndex+1)%pepLength][6] = (refDist.getAvgMass()+3*PROTON_MASS)/3;
                                
                            case 2:
                                yionSample[(pepIndex+1)%pepLength][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                                yionSample[(pepIndex+1)%pepLength][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                                yionRef[(pepIndex+1)%pepLength][5] = (refDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                                yionRef[(pepIndex+1)%pepLength][4] = (refDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                                yionRef[(pepIndex+1)%pepLength][3] = (refDist.getAvgMass()+2*PROTON_MASS)/2;
                                
                            case 1:
                                yionSample[(pepIndex+1)%pepLength][2] = sampleDist.getEndMass()+1*PROTON_MASS+massTolerance; //add proton to give b fragment ion
                                yionSample[(pepIndex+1)%pepLength][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][0] = sampleDist.getAvgMass()+1*PROTON_MASS;
                                yionRef[(pepIndex+1)%pepLength][2] = refDist.getEndMass()+1*PROTON_MASS+massTolerance;
                                yionRef[(pepIndex+1)%pepLength][1] = refDist.getStartMass()+1*PROTON_MASS-massTolerance;
                                yionRef[(pepIndex+1)%pepLength][0] = refDist.getAvgMass()+1*PROTON_MASS;

                            default:
                                break;         
                        }
                      
                        element.calculateBion();
                        //element.printComposition();

                        sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    
                        refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);            
    
                        switch(chargeState)
                        {
                            case 3:
                                bionSample[pepIndex][8] = (sampleDist.getEndMass()+2*PROTON_MASS)/3+massTolerance;
                                bionSample[pepIndex][7] = (sampleDist.getStartMass()+2*PROTON_MASS)/3-massTolerance;
                                bionSample[pepIndex][6] = (sampleDist.getAvgMass()+2*PROTON_MASS)/3;
                                bionRef[pepIndex][8] = (refDist.getEndMass()+2*PROTON_MASS)/3+massTolerance;
                                bionRef[pepIndex][7] = (refDist.getStartMass()+2*PROTON_MASS)/3-massTolerance;
                                bionRef[pepIndex][6] = (refDist.getAvgMass()+2*PROTON_MASS)/3;
                                
                            case 2:
                                bionSample[pepIndex][5] = (sampleDist.getEndMass()+1*PROTON_MASS)/2+massTolerance;
                                bionSample[pepIndex][4] = (sampleDist.getStartMass()+1*PROTON_MASS)/2-massTolerance;
                                bionSample[pepIndex][3] = (sampleDist.getAvgMass()+1*PROTON_MASS)/2;
                                bionRef[pepIndex][5] = (refDist.getEndMass()+1*PROTON_MASS)/2+massTolerance;
                                bionRef[pepIndex][4] = (refDist.getStartMass()+1*PROTON_MASS)/2-massTolerance;
                                bionRef[pepIndex][3] = (refDist.getAvgMass()+1*PROTON_MASS)/2;
                                
                            case 1:
                                bionSample[pepIndex][2] = sampleDist.getEndMass()+massTolerance;
                                bionSample[pepIndex][1] = sampleDist.getStartMass()-massTolerance;
                                bionSample[pepIndex][0] = sampleDist.getAvgMass();
                                bionRef[pepIndex][2] = refDist.getEndMass()+massTolerance;
                                bionRef[pepIndex][1] = refDist.getStartMass()-massTolerance;
                                bionRef[pepIndex][0] = refDist.getAvgMass();

                            default:
                                break;                                
                                
                        }                        

                        pepIndex++;
                    }
                   
		    try {
			element = new ElementComposition(ch, 0, ch.length, isoTable);                    
			element.calculate();
                    } catch (InvalidAAException ive)
                    {
                        System.out.println("Not Quantifiable peptide : " + pepSequence);

                        percent += eachSeg;
			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);

			}
                        continue;                        
                    }

                    sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    

                    int[] tempA = element.getElementSampleArr();

//                    for(int i=0;i<tempA.length;i++)
//                        System.out.println("===>> "+ tempA[i]);

                    refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);

                    switch(chargeState)
                    {
                        case 3:
                            yionSample[0][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                            yionSample[0][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                            yionSample[0][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;
                            yionRef[0][8] = (refDist.getEndMass()+3*PROTON_MASS)/3+massTolerance;
                            yionRef[0][7] = (refDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                            yionRef[0][6] = (refDist.getAvgMass()+3*PROTON_MASS)/3;

                        case 2:
                            yionSample[0][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                            yionSample[0][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                            yionSample[0][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                            yionRef[0][5] = (refDist.getEndMass()+2*PROTON_MASS)/2+massTolerance;
                            yionRef[0][4] = (refDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                            yionRef[0][3] = (refDist.getAvgMass()+2*PROTON_MASS)/2;

                        case 1:                        
                            yionSample[0][2] = sampleDist.getEndMass()+1*PROTON_MASS+massTolerance; //add proton to give b fragment ion
                            yionSample[0][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                            yionSample[0][0] = sampleDist.getAvgMass()+1*PROTON_MASS;
                            yionRef[0][2] = refDist.getEndMass()+1*PROTON_MASS+massTolerance;
                            yionRef[0][1] = refDist.getStartMass()+1*PROTON_MASS-massTolerance;
                            yionRef[0][0] = refDist.getAvgMass()+1*PROTON_MASS;

                        default:
                            break;                                

                    }

/*
                    for(int i=0;i<bionSample.length;i++)
                    {
                        for(int j=0;j<bionSample[i].length;j++)
                            System.out.print(bionSample[i][j] + " ");

                        System.out.println(" ");
                    }
                    System.out.println(" ");

                    for(int i=0;i<yionSample.length;i++)
                    {
                        for(int j=0;j<yionSample[i].length;j++)
                            System.out.print(yionSample[i][j] + " ");

                        System.out.println(" ");
                    }
                    System.out.println(" ");

                    for(int i=0;i<bionRef.length;i++)
                    {
                        for(int j=0;j<bionRef[i].length;j++)
                            System.out.print(bionRef[i][j] + " ");

                        System.out.println(" ");
                    }
                    System.out.println(" ");

                    for(int i=0;i<yionRef.length;i++)
                    {
                        for(int j=0;j<yionRef[i].length;j++)
                            System.out.print(yionRef[i][j] + " ");

                        System.out.println(" ");
                    }
                    System.out.println(" ");


                    System.exit(1);
                    */
                    double calcSamMass = (sampleDist.getAvgMass()+chargeState*PROTON_MASS)/chargeState;
                    double calcRefMass = (refDist.getAvgMass()+chargeState*PROTON_MASS)/chargeState;
                    
                    conf.setCalcSamAvgMass(calcSamMass);
                    conf.setCalcRefAvgMass(calcRefMass);

		    peptideEle.setAttribute("lightStartMass", String.valueOf(sampleDist.getStartMass()));  
		    peptideEle.setAttribute("heavyStartMass", String.valueOf(refDist.getStartMass()));
		    peptideEle.setAttribute("lightAvgMass", String.valueOf(conf.getCalcSamAvgMass()));  
		    peptideEle.setAttribute("heavyAvgMass", String.valueOf(conf.getCalcRefAvgMass()));
                    
                    peptideEle = this.createXmlChroPeptideTitle(false, peptide);
                     
                    String ms2FileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf("."));                    

                    StringBuffer rangeKey = new StringBuffer();                    
                    rangeKey.append(protein.getLocus());
                    rangeKey.append(ms2FileName);
                    rangeKey.append(peptide.getSequence().substring(2, peptide.getSequence().length()-2));
                    SpecRange range = rangeGen.getSpecRange( rangeKey.toString() );
                    
		    if(null==range)
		    {
                        int tmpScanNum = Integer.parseInt(peptide.getScanNum());
                        range = new SpecRange( tmpScanNum, tmpScanNum );                        
                        peptideEle.setAttribute("start_scan", peptide.getScanNum());
                        peptideEle.setAttribute("end_scan", peptide.getScanNum());
                    }
                    else
                    {
                        peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                        peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));                        
                    }

                    //sb.append("\tStartScan\tEndScan\tDTAPeakStart\tDTAPeakEnd\n");
                   
                    Element chro = new Element("chro");
                    //output.append("[CHROMATOGRAMS]\tSCAN\tSAMPLE\tREFERENCE\n");
                   
                    iFile = ht.get( this.filePath + ms2FileName + "." + "ms2");
                    keys = iFile.getKeys();
                   
                    
                    //samplePrecursor = conf.getPrecursor( (sampleDist.getAvgMass()+chargeState)/chargeState );
                    //refPrecursor = conf.getPrecursor( (refDist.getAvgMass()+chargeState)/chargeState );
                  
//                  System.out.println("sample precur==>>" + sampleDist.getAvgMass() + " " + refDist.getAvgMass());

                    keyIndex = Arrays.binarySearch(keys, Integer.parseInt(peptide.getScanNum()));
                    
                    if(keyIndex<0) //Cannot find index
                        keyIndex=-(++keyIndex); //Math.abs(++keyIndex);                    

                    /**  
                     * Find start scan number same as a precursor of sampleAvgMass 
                     * Then, later the program will find following scan # quicker.
                     **/                    
                    /* End of finding start spectrum number */                    

                    samplePrecursor=1;
                    refPrecursor=1;
                    
		    //System.out.println("==>>" + refPrecursor + " " + samplePrecursor + " " + conf.getIsolationWindow());
                    //int diff = (int)(refPrecursor - samplePrecursor)/(int)conf.getIsolationWindow();

                    TIntDoubleHashMap precursorMap = iFile.getPrecursorMap();

                    //System.out.println("==>>" + keys[keyIndex] + " " + samplePrecursor + " " + (sampleDist.getAvgMass()+chargeState)/chargeState + " " + precursorMap.get(keys[keyIndex]));
                    //System.out.println("==>>" + keys[keyIndex+diff] + " " + refPrecursor + " " + (refDist.getAvgMass()+chargeState)/chargeState  + " " + precursorMap.get(keys[keyIndex+diff]));

                    //if(precursorMap.get(keys[keyIndex]) != samplePrecursor)
		   // {
                     //   System.out.println("Outside isowindow for sample precursor " + keys[keyIndex] + " " + (sampleDist.getAvgMass()+chargeState)/chargeState + " " + precursorMap.get(keys[keyIndex]) + " " + samplePrecursor);

			
                    //}
                    //if(precursorMap.get(keys[keyIndex+diff]) != refPrecursor)
                    //   System.out.println("Outside isowindow for ref precursor " + keys[keyIndex+diff] + " " + (refDist.getAvgMass()+chargeState)/chargeState  + " " + precursorMap.get(keys[keyIndex+diff]) + " " + refPrecursor);
		    //System.out.println("set text" + iFile + " " + range  + " " + keyIndex + " " + diff + " " + bionSample + " " + bionRef + " " + yionSample + " " + yionRef + " " + samplePrecursor + " " + refPrecursor + " " + conf + " " + chargeState);

                    //chro.setText( CalcUtil.calculateMS2Mass( iFile, range, keyIndex, diff, bionSample, bionRef, yionSample, yionRef, samplePrecursor, refPrecursor, conf, chargeState) ); 



                    try {
			String outStr = CalcUtil.calculateMS2Mass( iFile, range, keyIndex, bionSample, bionRef, yionSample, yionRef, conf, chargeState); 

			if(outStr == null)
			    continue;
                        
			chro.setText(outStr);                        
                    } catch (PrecursorNotFoundException ive)
                    {
                        System.out.println("Precursor not found for " + pepSequence);                        

			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Error : Precursor not found for " + pepSequence);
			    percent += eachSeg;
			    progress.setProgress((int)percent);
			}

			ive.printStackTrace();
                        
                        continue;                        
                    } catch (Exception e) {
                        System.out.println("Precursor not found for " + pepSequence);                        

			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Error : Precursor not found for " + pepSequence);
			    percent += eachSeg;
			    progress.setProgress((int)percent);
			}
			e.printStackTrace();
                        

                        continue;                        
		    }
		    
		    

                    peptideEle.addContent(chro);

                    Element fragEle = new Element("frag");
                    
                    Element bSample = new Element("bs");
                    StringBuffer tempSb = new StringBuffer();
                    for(int i=0;i<bionSample.length;i++)
                    {
                        int j;
                        for(j=0;j<bionSample[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(bionSample[i][j]) ).append(" ");
                        }
                      
                        tempSb.append( formatter.format(bionSample[i][j]) ).append(",");
                    }

                    bSample.setText(tempSb.toString());
                    fragEle.addContent(bSample);
                   
                    Element bRef = new Element("br");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<bionRef.length;i++)
                    {
                        int j;
                        for(j=0;j<bionRef[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(bionRef[i][j]) ).append(" ");
                        }

                        tempSb.append( formatter.format(bionRef[i][j]) ).append(",");
                        
                    }

                    bRef.setText(tempSb.toString());
                    fragEle.addContent(bRef);

                    Element ySample = new Element("ys");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<yionSample.length;i++)
                    {
                        int j;
                        for(j=0;j<yionSample[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(yionSample[i][j]) ).append(" ");
                        }
                        
                        tempSb.append( formatter.format(yionSample[i][j]) ).append(",");
                    }

                    ySample.setText(tempSb.toString());
                    fragEle.addContent(ySample);

                    Element yRef = new Element("yr");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<yionRef.length;i++)
                    {
                        int j;
                        for(j=0;j<yionRef[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(yionRef[i][j]) ).append(" ");
                        }

                        tempSb.append( formatter.format(yionRef[i][j]) ).append(",");
                    }

                    yRef.setText(tempSb.toString());
                    fragEle.addContent(yRef);

                    peptideEle.addContent(fragEle);

                    percent += eachSeg;

		    if(null != progress)
			progress.setProgress((int)percent);         
                    
                    System.out.print(pepCount);
                    System.out.print("/");
                    System.out.print(redundantPeptideNum);
                    System.out.print(" peptides, ");
                    System.out.print((int)percent);
                    //System.out.print(" % is complete\n");
                    System.out.print(" % is complete\r");

                    proteinEle.addContent(peptideEle);
                }

                if(proteinEle.getChildren().size()>0)
                    rootEle.addContent(proteinEle);
            }
          
            Document doc = new Document(rootEle);
            OutputStream os = new FileOutputStream(filePath + "census_chro.xml");
            XMLOutputter outputter = new XMLOutputter();
	    outputter.setFormat(Format.getPrettyFormat());
            outputter.output(doc, os);
            os.close();

            System.out.println("\n100% complete");
            //System.out.println( System.out.println"\n100% complete");

            //Create relex.chro file
            /*
            out = new BufferedOutputStream(new FileOutputStream(filePath + "relex.chro"));
            p = new PrintStream(out);
            p.print(output.toString());
            */
            
        }
        catch (IOException e)
        {
            System.out.println("IO Error while generating msms chro file : " + pepSequence + e);
            e.printStackTrace();
            throw new IOException(e.toString());
        }
        catch (Exception e)
        {
            System.out.println("Error while generating msms chro file : " + pepSequence + e);
            e.printStackTrace();
            throw new Exception(e.toString());
        }
        finally
        {
            if(null != p)
                p.close();
            
            if(null != out)
                out.close();

            //Close all random files
            for (Enumeration e = ht.keys(); e.hasMoreElements(); ) 
            {
                iFile = ht.get(e.nextElement());

                if(null != iFile)
                    iFile.close();
            }

            
        }


    }
            
    /*
     * Find first scan number matching avgMass
     */
    private int findStartScanNum(int scanNum, RandomAccessFile file, int[] keys, double precursor) throws IOException
    {
        System.out.println("scan" + scanNum);
        System.out.println("scan" + keys[scanNum]);
        file.seek( keys[scanNum] );
        String str = file.readLine();    
        System.out.println("sss" + str);
        
        double d = Double.parseDouble( str.substring(str.lastIndexOf("\t")) );
        
        System.out.println(d + "\t" + precursor);
        
        while(d != precursor)
        {
            System.out.println(d + "\t" + precursor);
            
            file.seek( keys[++scanNum] );            
            str = file.readLine();
            d = Double.parseDouble( str.substring(str.lastIndexOf("\t")) );
        }
        
        return 0;
    }
    
    private double findScanNum(RandomAccessFile file, int scanNum, long pos, double avgMass) throws IOException
    {
        file.seek(pos);
        String str = file.readLine();
        
        double d = Double.parseDouble( str.substring(str.lastIndexOf("\t")) );
       
        return 0;
    }

    private String cleanFileName(String fileName)
    {
	// this is a problem of mzxml data format inconsistency
	if(null != fileName && fileName.contains("rawFile") )
	{
	    fileName = fileName.substring( fileName.indexOf("rawFile") ).trim();
	    fileName = fileName.substring( fileName.indexOf(":")+1 ).trim();
	    fileName = fileName.substring( 0, fileName.lastIndexOf(".") );
	}
	else
	{
	    int index = fileName.indexOf(".");

	    if(index>0)
		fileName = fileName.substring(0, index);


	    //for(int i=0;i<3;i++)
	//	fileName = fileName.substring(0, fileName.lastIndexOf("."));
//	    fileName = fileName.substring(0, fileName.lastIndexOf("."));
	}

	return fileName;
    }
                    
    public void runMRMWithoutId() throws IOException, CensusGeneralException, Exception 
    {
	
	this.conf = Configuration.getInstance();
        this.filePath = conf.getFilePath();
        Element mrmParamsEle = conf.getRootConfEle().getChild("params").getChild("mrm_params");

        List<scripts.mrm.PeptideModel> pepList = new ArrayList<scripts.mrm.PeptideModel>();
        
        for(Iterator<Element> itr=mrmParamsEle.getChildren("peptide").iterator(); itr.hasNext(); )
        {
            Element pepEle = itr.next();

            //System.out.println(pgroupEle);

            scripts.mrm.PeptideModel peptide = new scripts.mrm.PeptideModel(pepEle.getAttributeValue("name"));

            
            for(Iterator<Element> pepitr=pepEle.getChildren("precursor").iterator(); pepitr.hasNext(); )
            {
                Element preEle = pepitr.next();

                double pmass = Double.parseDouble(preEle.getAttributeValue("mass"));

                scripts.mrm.Precursor p = new scripts.mrm.Precursor(pmass);

                for(Iterator<Element> ditr=preEle.getChildren("transition").iterator(); ditr.hasNext(); )
                {
                    Element dauEle = ditr.next();
                    double dmass = Double.parseDouble(dauEle.getAttributeValue("mass"));

                    p.addDaughter(dmass);
                }

                peptide.addPrecursor(p);
            }             
            
            pepList.add(peptide);

        }

	String ms2File = mrmParamsEle.getChildText("ms2_file");
        //SpectrumReader sr = new SpectrumReader("/home/rpark/rpark_on_data/project/jcopping/mrm_012910/CF301hrrep1-01.ms2", "ms2");
        SpectrumReader sr = new SpectrumReader(ms2File, "ms2");
	Hline h = new Hline(sr.getHlines());

        Iterator<PeakList> it = sr.getSpectra();
        Hashtable<Double, scripts.mrm.Precursor> pht = new Hashtable<Double, scripts.mrm.Precursor>();

        for(Iterator<scripts.mrm.PeptideModel> itr=pepList.iterator(); itr.hasNext(); ) {
            scripts.mrm.PeptideModel pmodel = itr.next();

            for(Iterator<scripts.mrm.Precursor> pitr=pmodel.getPlist().iterator(); pitr.hasNext(); ) {
                scripts.mrm.Precursor precursor = pitr.next();

                pht.put(precursor.getMass(), precursor);
            }

        }

//        int counter = 0;
//        int numPeaks = 0;
        //boolean sortByIntensity = true;
        while (it.hasNext()) {
            PeakList list = it.next();
            
	    StringBuffer sb = new StringBuffer();


            scripts.mrm.Precursor precursor = pht.get(list.getPrecursorMass());

            if(null == precursor)
                continue;

//            System.out.println("===>>" + precursor);
            
            //precursor.addIntensity(p.getM2z(), p.getIntensity());
	    
	    precursor.addIntensity(list.getPeakList(), list.getLoscan(), list.getRetentionTime());
/*
            for(Iterator<Peak> itr=list.getPeaks(); itr.hasNext(); )
            {
                Peak p = itr.next();
                        
                precursor.addIntensity(p.getM2z(), p.getIntensity(), list.getLoscan());

		//System.out.println("====" + list.getPrecursorMass() + " " + list.getLoscan() + " " + p.getM2z() + " " +  p.getIntensity());
            } */

        }

       // peptide.print(0);
        //peptide.calculateRatio();
        //peptide.print();

	Element rootEle = this.createXmlChroHeader(1);

	for(Iterator<PeptideModel> itr=pepList.iterator(); itr.hasNext(); ) {
	    PeptideModel peptide = itr.next(); //pepList.get(0);

	    Element proteinEle = new Element("protein");
	    proteinEle.setAttribute("locus", peptide.getName());
	    proteinEle.setAttribute("seq_ct", "");
	    proteinEle.setAttribute("spec_ct", "");
	    proteinEle.setAttribute("seq_cov", "");
	    proteinEle.setAttribute("length", "");
	    proteinEle.setAttribute("molwt", "");
	    proteinEle.setAttribute("pi", "");
	    proteinEle.setAttribute("val", "");

            List<Precursor> preList = peptide.getPlist();
            for(Iterator<Precursor> pitr=preList.iterator(); pitr.hasNext(); ) {
                Precursor precursor = pitr.next();

		int peakIndex = precursor.findpeak();
		//daughterSize += pre.getDmassList().size();

		for(int i=0;i<precursor.getDmassList().size();i++) {
		    Daughter d = precursor.getDaughter(i);
		    d.findPeakArea(peakIndex);

		    Element peptideEle = new Element("peptide");
		    peptideEle.setAttribute("unique", "*");
		    peptideEle.setAttribute("file", String.valueOf(d.getRt(peakIndex)));
		    peptideEle.setAttribute("scan", String.valueOf(d.getScan(peakIndex)));
		    peptideEle.setAttribute("seq", String.valueOf(d.getMass())); 
		    peptideEle.setAttribute("xcorr", "0");
		    peptideEle.setAttribute("deltaCN", "0");
		    peptideEle.setAttribute("charge", "0");
		    peptideEle.setAttribute("spC", "0");
		    peptideEle.setAttribute("start_scan", String.valueOf(d.getStartScan()));
		    peptideEle.setAttribute("end_scan", String.valueOf(d.getEndScan()));
                    proteinEle.addContent(peptideEle);

//		    System.out.println("--------" + d.getScan(peakIndex) + " " + d.getStartScan() + " " + d.getEndScan());
		    Element chro = new Element("chro");

///		    System.out.println("== " + peakIndex  + " " + d.getMass() + " " + d.getScan(peakIndex) + " " + d.getIntensity(peakIndex));


		    StringBuffer sb = new StringBuffer();
		    int range = 150;
		    sb.append("P ").append(d.getStartScan()).append(" ").append(d.getEndScan()).append(";");
		    for(int ii=peakIndex-range;ii<peakIndex+range;ii++) {
			sb.append(d.getScan(ii)).append(" ").append((int)d.getIntensity(ii));
			for(int j=0;j<7;j++)
			    sb.append(" 0");

			sb.append(";");
		    }

		    chro.setText(sb.toString());                        

		    //chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, sampleStartMass, sampleEndMass, refStartMass, refEndMass, range) );
      //<chro>P 7651 7779;7532 301798 0 6 7 2 0 0.02081426666666175 -1.0;7538 405049 0 6 7 1 0 0.01874126666666598 -1.0;7544 0 0 6 7 0 0 -1.0 -1.0;7550 143416 0 6 7 1 0 0.019541266666692536 -1.0;7556 101896 0 6 7 1 0 0.01864126666669108 -1.0;7561 0 0 6 7 0 0 -1.0 -1.0;7567 0 0 6 7 0 0 -1.0 -1.0;7573 0 0 6 7 0 0 -1.0 -1.0;7579 0 0 6 7 0 0 -1.0 -1.0;7585 0 0 6 7 0 0 -1.0 -1.0;7591 88080 0 6 7 1 0 0.023107399999958034 -1.0;7597 0 0 6 7 0 0 -1.0 -1.0;7603 0 0 6 7 0 0 -1.0 -1.0;7609 0 0 6 7 0 0 -1.0 -1.0;7615 0 0 6 7 0 0 -1.0 -1.0;7621 0 0 6 7 0 0 -1.0 -1.0;7627 0 0 6 7 0 0 -1.0 -1.0;7633 0 0 6 7 0 0 -1.0 -1.0;7639 0 0 6 7 0 0 -1.0 -1.0;7645 71517 138077 6 7 1 1 0.024858733333303462 4.707333332589769E-4;7651 0 0 6 7 0 0 -1.0 -1.0;7657 0 0 6 7 0 0 -1.0 -1.0;7663 0 0 6 7 0 0 -1.0 -1.0;7669 0 0 6 7 0 0 -1.0 -1.0;7675 0 0 6 7 0 0 -1.0 -1.0;7681 149706 0 6 7 2 0 0.004214266666679123 -1.0;7687 85787 99826 6 7 1 1 0.0016439333332982642 9.707333332471535E-4;7692 0 567381 6 7 0 3 -1.0 8.415777777296777E-4;7698 821825 744934 6 7 3 4 0.0023592666667203352 0.0033786000000759486;7704 1235302 1168124 6 7 6 5 0.00200722222219459 0.004089266666687763;7710 1664041 977082 6 7 4 4 0.0018719666666697776 0.0021536000000423883;7716 1199666 962760 6 7 5 3 0.0018212666667295706 0.0019292666667449037;7722 1139038 243499 6 7 4 2 

		    peptideEle.addContent(chro);

		}

	    }


            rootEle.addContent(proteinEle);
            
	    //Element peptideEle=null;

	    //peptide.findpeak();
	}

	Document doc = new Document(rootEle);
	OutputStream os = new FileOutputStream(filePath + File.separator + "census_chro.xml");
	XMLOutputter outputter = new XMLOutputter();
	outputter.setFormat(Format.getPrettyFormat());
	outputter.output(doc, os);
	os.close();
	System.out.println("\n100% complete");

    }

    public void runMRMWithoutId_old() throws IOException, CensusGeneralException, Exception
    {
	this.conf = Configuration.getInstance();
        this.filePath = conf.getFilePath();

        Hashtable<String, IndexedFile> ht = null;
        
        File ff = new File(filePath);
        String[] flist=null;
        
        //System.out.println(conf.getSpectrumFormat());
        //System.out.println(Configuration.MS_FILE_FORMAT + " " + Configuration.MZXML_FILE_FORMAT + " " + Configuration.MS2_FILE_FORMAT);
	//
	//
	switch(conf.getSpectrumFormat())
	{
	    case Configuration.MS_FILE_FORMAT: 
		ht = createIndexedFiles(filePath, CensusConstants.MS1_FILE);
                flist = ff.list(new RelExFileFilter(CensusConstants.MS1_FILE));               
		break;
	    
	    case Configuration.MZXML_FILE_FORMAT:
		ht = createIndexedFiles(filePath, CensusConstants.MZXML);
                flist = ff.list(new RelExFileFilter(CensusConstants.MZXML));
		break;

	    case Configuration.MS2_FILE_FORMAT:
		ht = createIndexedFiles(filePath, CensusConstants.MS2_FILE);
                flist = ff.list(new RelExFileFilter(CensusConstants.MS2_FILE));
		break;

	    default:
		break;
	}


        
        Arrays.sort(flist);
        
        if( !filePath.endsWith(File.separator) )
            filePath += File.separator;
                
        IndexedFile iFile=null;
        BufferedOutputStream out = null;
        PrintStream p = null;
        
        try
        {   
            /******************************************************************
             *  Read DTASelect.txt file to find spectrum range for each peptide
             ******************************************************************/
	     List<MRMPeptideGroup> mrmPeptideGroupList = conf.getMrmPeptideGroupList();
//System.out.println( conf.getMrmPeptideSize() );

            int peptideNum = conf.getMrmPeptideSize(); 

            double percent = 0.0;
            double eachSeg = 100.0/peptideNum;
            int pepCount=0;
            
           // System.out.println(conf.getRootConfEle());
            
            IsotopeReader isoReader = new IsotopeReader(conf.getRootConfEle());
            IsotopeTable<String, int[]> isoTable = isoReader.getIsotope();
            
            Element rootEle = this.createXmlChroHeader(2);

            Element proteinEle=null;
            Element peptideEle=null;
            int[] sampleNterm = isoTable.get("sampleNTERM");
            int[] sampleCterm = isoTable.get("sampleCTERM");
            int[] refNterm = isoTable.get("refNTERM");
            int[] refCterm = isoTable.get("refCTERM");
           
            double samplePrecursor;
            double refPrecursor;
            IsotopeDist sampleDist;     
            IsotopeDist refDist;
                                
            double[][] bionSample;
            double[][] bionRef;
            double[][] yionSample;
            double[][] yionRef;
            
            int redundantPeptideNum = -1; 
            
                
            for (Iterator<MRMPeptideGroup> itr = mrmPeptideGroupList.iterator(); itr.hasNext(); ) {
            proteinEle = new Element("protein");

                MRMPeptideGroup pGroup = itr.next();
                
                List<MRMPeptideModel> pepList = new ArrayList<MRMPeptideModel>();

                for (Iterator<MRMPeptideModel> pepItr = pGroup.getPeptideList().iterator(); pepItr.hasNext(); ) 
                {
		    MRMPeptideModel peptide = pepItr.next();                    

                    List<MRMPeptideModel.Daughter> daughterList = peptide.getDaughters();
                    
                    for (Iterator<MRMPeptideModel.Daughter> dItr = daughterList.iterator(); dItr.hasNext(); ) 
                    {
                        MRMPeptideModel.Daughter d = dItr.next();
                        
                     //   System.out.println(d.getMass() + " " + d.getRt());    
                        
                    }
                    
                   
                    pepCount++;
                        
                    //trim additional characters from peptide sequence at both ends
                    String pepSequence = peptide.getSequence();
                    char[] ch = pepSequence.toCharArray();
                    //element = new ElementComposition(peptide.getSequence().substring(2, peptide.getSequence().length()-2), isoReader.getIsotope()); 
                    
                    ElementComposition element = new ElementComposition(ch, 0, ch.length, isoReader.getIsotope());
                    ElementComposition totalElement;
                    
                    try {
                        totalElement = new ElementComposition(ch, 0, ch.length, isoTable);                    
                        totalElement.calculate();
                    } catch (InvalidAAException ive)
                    {
                        System.out.println("Not Quantifiable peptide : " + pepSequence);

                        percent += eachSeg;
			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);

			}
                        continue;                        
                    }
                    
                    //int chargeState = Integer.parseInt(peptide.getChargeState());
                    int chargeState = 1; //let's hard code for the charge state as 1 for now, and it will work anyway.  We will revisit later.
                   
                    int pepLength=0;
                    
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;

                        pepLength++;
                    }

                    bionSample = new double[pepLength][chargeState*3];
                    bionRef = new double[pepLength][chargeState*3];
                    //Yions
                    yionSample = new double[pepLength][chargeState*3];
                    yionRef = new double[pepLength][chargeState*3];
                    
                    int pepIndex=0;
                    
                    //System.out.println("aamass" + massTolerance + " " + conf.getMassTolerance());
                    
                    for(int i=0;i<ch.length;i++)
                    {
                        if(ch[i]=='*' || ch[i]=='@' || ch[i]=='#')
                            continue;
                    
			try {
			    element = new ElementComposition(ch, 0, i+1, isoTable);
			    element.calculate();

			} catch (InvalidAAException ive)
			{
			    System.out.println("Not Quantifiable peptide : " + pepSequence);

			    percent += eachSeg;
			    if(null != progress)
			    {
				ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
				progress.setProgress((int)percent);

			    }
			    continue;                        
			}

                        //Y ions
                        sampleDist = new IsotopeDist(
                                getComplementaryComposition(totalElement.getElementSampleArr(), element.getElementSampleArr(), sampleNterm, sampleCterm), element.getModShift(), true);
                        
                        refDist = new IsotopeDist(
                                getComplementaryComposition(totalElement.getElementRefArr(), element.getElementRefArr(), refNterm, refCterm), element.getModShift(), false);   //fix this
                        
                        switch(chargeState)
                        {
                            case 3:
                                yionSample[(pepIndex+1)%pepLength][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3;
                                yionSample[(pepIndex+1)%pepLength][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;
                                yionRef[(pepIndex+1)%pepLength][8] = (refDist.getEndMass()+3*PROTON_MASS)/3;
                                yionRef[(pepIndex+1)%pepLength][7] = (refDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                                yionRef[(pepIndex+1)%pepLength][6] = (refDist.getAvgMass()+3*PROTON_MASS)/3;
                                
                            case 2:
                                yionSample[(pepIndex+1)%pepLength][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2;
                                yionSample[(pepIndex+1)%pepLength][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                                yionRef[(pepIndex+1)%pepLength][5] = (refDist.getEndMass()+2*PROTON_MASS)/2;
                                yionRef[(pepIndex+1)%pepLength][4] = (refDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                                yionRef[(pepIndex+1)%pepLength][3] = (refDist.getAvgMass()+2*PROTON_MASS)/2;
                                
                            case 1:
                                //yionSample[(pepIndex+1)%pepLength][2] = sampleDist.getEndMass()+1*PROTON_MASS+massTolerance; //add proton to give b fragment ion
                                yionSample[(pepIndex+1)%pepLength][2] = sampleDist.getEndMass()+1*PROTON_MASS; //add proton to give b fragment ion
                                yionSample[(pepIndex+1)%pepLength][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                                yionSample[(pepIndex+1)%pepLength][0] = sampleDist.getAvgMass()+1*PROTON_MASS;
                                //yionRef[(pepIndex+1)%pepLength][2] = refDist.getEndMass()+1*PROTON_MASS+massTolerance;
                                yionRef[(pepIndex+1)%pepLength][2] = refDist.getEndMass()+1*PROTON_MASS;
                                yionRef[(pepIndex+1)%pepLength][1] = refDist.getStartMass()+1*PROTON_MASS-massTolerance;
                                yionRef[(pepIndex+1)%pepLength][0] = refDist.getAvgMass()+1*PROTON_MASS;

                            default:
                                break;         
                        }
                      
                        element.calculateBion();
                        //element.printComposition();

                        sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    
                        refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);            
    
                        switch(chargeState)
                        {
                            case 3:
                                bionSample[pepIndex][8] = (sampleDist.getEndMass()+2*PROTON_MASS)/3;
                                bionSample[pepIndex][7] = (sampleDist.getStartMass()+2*PROTON_MASS)/3-massTolerance;
                                bionSample[pepIndex][6] = (sampleDist.getAvgMass()+2*PROTON_MASS)/3;
                                bionRef[pepIndex][8] = (refDist.getEndMass()+2*PROTON_MASS)/3;
                                bionRef[pepIndex][7] = (refDist.getStartMass()+2*PROTON_MASS)/3-massTolerance;
                                bionRef[pepIndex][6] = (refDist.getAvgMass()+2*PROTON_MASS)/3;
                                
                            case 2:
                                bionSample[pepIndex][5] = (sampleDist.getEndMass()+1*PROTON_MASS)/2;
                                bionSample[pepIndex][4] = (sampleDist.getStartMass()+1*PROTON_MASS)/2-massTolerance;
                                bionSample[pepIndex][3] = (sampleDist.getAvgMass()+1*PROTON_MASS)/2;
                                bionRef[pepIndex][5] = (refDist.getEndMass()+1*PROTON_MASS)/2;
                                bionRef[pepIndex][4] = (refDist.getStartMass()+1*PROTON_MASS)/2-massTolerance;
                                bionRef[pepIndex][3] = (refDist.getAvgMass()+1*PROTON_MASS)/2;
                                
                            case 1:
                                bionSample[pepIndex][2] = sampleDist.getEndMass();
                                bionSample[pepIndex][1] = sampleDist.getStartMass()-massTolerance;
                                bionSample[pepIndex][0] = sampleDist.getAvgMass();
                                bionRef[pepIndex][2] = refDist.getEndMass();
                                bionRef[pepIndex][1] = refDist.getStartMass()-massTolerance;
                                bionRef[pepIndex][0] = refDist.getAvgMass();

                            default:
                                break;                                
                                
                        }                        

                        pepIndex++;
                    }
                   
		    try {
			element = new ElementComposition(ch, 0, ch.length, isoTable);                    
			element.calculate();
                    } catch (InvalidAAException ive)
                    {
                        System.out.println("Not Quantifiable peptide : " + pepSequence);

                        percent += eachSeg;
			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);

			}
                        continue;                        
                    }

                    sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    
                    refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);
                    double calcSamMass = (sampleDist.getAvgMass()+chargeState*PROTON_MASS)/chargeState;
                    double calcRefMass = (refDist.getAvgMass()+chargeState*PROTON_MASS)/chargeState;
                    
                    conf.setCalcSamAvgMass(calcSamMass);
                    conf.setCalcRefAvgMass(calcRefMass);
		    peptideEle.setAttribute("lightStartMass", String.valueOf(sampleDist.getStartMass()));  
		    peptideEle.setAttribute("heavyStartMass", String.valueOf(refDist.getStartMass()));
		    peptideEle.setAttribute("lightAvgMass", String.valueOf(conf.getCalcSamAvgMass()));  
		    peptideEle.setAttribute("heavyAvgMass", String.valueOf(conf.getCalcRefAvgMass()));
                    
                    switch(chargeState)
                    {
                        case 3:
                            yionSample[0][8] = (sampleDist.getEndMass()+3*PROTON_MASS)/3;
                            yionSample[0][7] = (sampleDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                            yionSample[0][6] = (sampleDist.getAvgMass()+3*PROTON_MASS)/3;
                            yionRef[0][8] = (refDist.getEndMass()+3*PROTON_MASS)/3;
                            yionRef[0][7] = (refDist.getStartMass()+3*PROTON_MASS)/3-massTolerance;
                            yionRef[0][6] = (refDist.getAvgMass()+3*PROTON_MASS)/3;

                        case 2:
                            yionSample[0][5] = (sampleDist.getEndMass()+2*PROTON_MASS)/2;
                            yionSample[0][4] = (sampleDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                            yionSample[0][3] = (sampleDist.getAvgMass()+2*PROTON_MASS)/2;
                            yionRef[0][5] = (refDist.getEndMass()+2*PROTON_MASS)/2;
                            yionRef[0][4] = (refDist.getStartMass()+2*PROTON_MASS)/2-massTolerance;
                            yionRef[0][3] = (refDist.getAvgMass()+2*PROTON_MASS)/2;

                        case 1:                        
                            yionSample[0][2] = sampleDist.getEndMass()+1*PROTON_MASS; //add proton to give b fragment ion
                            yionSample[0][1] = sampleDist.getStartMass()+1*PROTON_MASS-massTolerance;
                            yionSample[0][0] = sampleDist.getAvgMass()+1*PROTON_MASS;
                            yionRef[0][2] = refDist.getEndMass()+1*PROTON_MASS;
                            yionRef[0][1] = refDist.getStartMass()+1*PROTON_MASS-massTolerance;
                            yionRef[0][0] = refDist.getAvgMass()+1*PROTON_MASS;

                            
                        default:
                            break;                                

                    }

                    
                    
                    peptideEle = this.createXmlMrmChroPeptideTitle(true, peptide); //true is for full scan

		    //String fileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf(".")+1) + "ms1";

		    //String fileName=peptide.getFileName();                    
                    //System.out.println(ht);
                    //System.out.println(ht.keySet());
                    
        //            for(int ii=0;ii<flist.length;ii++)
          //              System.out.println(flist[ii]);            
                    
                    

                    
                    //System.out.println("--->?" + chargeState);

		    
                    if(!peptide.isLabeled())
                    {
                        peptide.setBionArr(bionSample);
                        peptide.setYionArr(yionSample);
                    }
                    else if(peptide.isLabeled())
                    {
                        peptide.setBionArr(bionRef);
                        peptide.setYionArr(yionRef);                       
                    }                    

                    pepList.add(peptide);
                    
                }

                Element chro = new Element("chro");
                
                try {
                        String outStr = CalcUtil.calculateMRMNoId(pepList, flist, conf, ht); 
                    if(outStr == null)
                        continue;
                        
                    chro.setText(outStr);                        
                } catch (PrecursorNotFoundException ive)
                {
                    ive.printStackTrace();

                    System.out.println("Error : " + ive.toString());                        

                    if(null != progress)
                    {
                        ChroProgressDialog.addMessageWithLine(progress, "Error : " + ive.toString());
                        percent += eachSeg;
                        progress.setProgress((int)percent);
                    }

                    continue;                        
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println("Error : " + e.toString());                                     

                    if(null != progress)
                    {
                        ChroProgressDialog.addMessageWithLine(progress, "Error : " + e.toString());
                        percent += eachSeg;
                        progress.setProgress((int)percent);
                    }

                    continue;                        
                }
		    
		    

                    peptideEle.addContent(chro);

                /*
                    Element fragEle = new Element("frag");
                    
                    Element bSample = new Element("bs");
                    StringBuffer tempSb = new StringBuffer();
                    for(int i=0;i<bionSample.length;i++)
                    {
                        int j;
                        for(j=0;j<bionSample[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(bionSample[i][j]) ).append(" ");
                        }
                      
                        tempSb.append( formatter.format(bionSample[i][j]) ).append(",");
                    }

                    bSample.setText(tempSb.toString());
                    fragEle.addContent(bSample);
                   
                    Element bRef = new Element("br");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<bionRef.length;i++)
                    {
                        int j;
                        for(j=0;j<bionRef[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(bionRef[i][j]) ).append(" ");
                        }

                        tempSb.append( formatter.format(bionRef[i][j]) ).append(",");
                        
                    }

                    bRef.setText(tempSb.toString());
                    fragEle.addContent(bRef);

                    Element ySample = new Element("ys");
                    tempSb.delete(0, tempSb.length());
                    for(int i=0;i<yionSample.length;i++)
                    {
                        int j;
                        for(j=0;j<yionSample[i].length-1;j++)
                        {
                            tempSb.append( formatter.format(yionSample[i][j]) ).append(" ");
                        }
                        
                    */

		    if(null != progress)
			progress.setProgress((int)percent);         
                    
                    System.out.print(pepCount);
                    System.out.print("/");
                    System.out.print(redundantPeptideNum);
                    System.out.print(" peptides, ");
                    System.out.print((int)percent);
                    //System.out.print(" % is complete\n");
                    System.out.print(" % is complete\r");

                    proteinEle.addContent(peptideEle);
                if(proteinEle.getChildren().size()>0)
                    rootEle.addContent(proteinEle);

            }
        
            Document doc = new Document(rootEle);
            OutputStream os = new FileOutputStream(filePath + "census_chro.xml");
            XMLOutputter outputter = new XMLOutputter();
	    outputter.setFormat(Format.getPrettyFormat());
            outputter.output(doc, os);
            os.close();

            System.out.println("\n100% complete");
            //System.out.println( System.out.println"\n100% complete");

            //Create relex.chro file
            /*
            out = new BufferedOutputStream(new FileOutputStream(filePath + "relex.chro"));
            p = new PrintStream(out);
            p.print(output.toString());
            */

/*
            Document doc = new Document(rootEle);
            OutputStream os = new FileOutputStream(filePath + "census_chro.xml");
            XMLOutputter outputter = new XMLOutputter();
	    outputter.setFormat(Format.getPrettyFormat());
            outputter.output(doc, os);
            os.close();
	    */
	    
        }
        catch (IOException e)
        {
            System.out.println("IO Error while generating msms chro file : " + e);
            e.printStackTrace();
            throw new IOException(e.toString());
        }
        catch (Exception e)
        {
            System.out.println("Error while generating msms chro file : " + e);
            e.printStackTrace();
            throw new Exception(e.toString());
        }
        finally
        {
            if(null != p)
                p.close();
            
            if(null != out)
                out.close();

            //Close all random files
            for (Enumeration e = ht.keys(); e.hasMoreElements(); ) 
            {
                iFile = ht.get(e.nextElement());

                if(null != iFile)
                    iFile.close();
            }

        }
    }    
   
    public double getMedianN15Ratio(IdentificationReader idReader, IsotopeReader isoReader, Hashtable<String, IndexedFile> ht) 
	throws IOException, CensusGeneralException, Exception {

	System.out.println("Calculating 15N enrichment...");
	int totalPepCount = idReader.getTotalPeptideNumber();
	
	Iterator<Protein> pitr = idReader.getProteins(); //need to run to calculate redundnat peptides
	int[] beanArr = new int[101];

	int count=0;

	for (Iterator<Protein> itr = pitr; itr.hasNext(); ) {
	    Protein protein = itr.next();

	    for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); ) 
	    {
		Peptide peptide = pepItr.next();                    
		count++;
		double progress = (double)count/totalPepCount*100;
		System.out.print( Formatter.formatDecimal(progress) );
		System.out.print(" % is complete\r");

		String pepSequence = peptide.getSequence();
		char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();
		ElementComposition element = new ElementComposition(ch, 0, ch.length, isoReader.getIsotope());

		try {
		    element.calculate();
		} catch (InvalidAAException invE)
		{
		    continue;
		}

		String fileName=peptide.getFileName();
		fileName = cleanFileName(fileName);

		switch(conf.getSpectrumFormat())
		{
		    case Configuration.MS_FILE_FORMAT: 
			fileName += ".ms1";
			break;

		    case Configuration.MZXML_FILE_FORMAT:
			fileName += ".mzXML";
			break;

		    default:
			break;
		}

		int scanNum = Integer.parseInt(peptide.getScanNum());
		IndexedFile iFile= ht.get(filePath + fileName);

		if(null == iFile)
		    continue;

		int chargeState = Integer.parseInt(peptide.getChargeState());

		IsotopeDist refDist = null;

		double startEnrich = conf.getStartEnrich();
		double endEnrich = conf.getEndEnrich();
		double enrichmentMaxDeviation = conf.getEnrichmentMaxDeviation();

		refDist = new edu.scripps.pms.census.util.N15EnrichmentCalc(element.getElementRefArr(), element.getModShift(), -1, startEnrich, endEnrich, enrichmentMaxDeviation, iFile, scanNum, chargeState);
		//System.out.println("=====" + refDist.getEnrichCorr());
		//System.out.println("=====" + refDist.getFixedEnrichRatio());

		int beanIndex = (int)(refDist.getBestEnrichRatio()*100);
		if(beanIndex<0)
		    beanIndex=0;

		beanArr[beanIndex] += 1;

	    }
	}

	int medianIndex = -1;
	int medianValue = -1;
	for(int i=1;i<beanArr.length;i++) {
	    int temp = beanArr[i];
	    if(temp>medianValue) {
		medianIndex = i;
		medianValue = temp;
	    }
	}

	System.out.println("");
	System.out.println("done.");

	return (double)medianIndex*0.01;
    }
    //labeling labeled label
    public void createFullscanXmlChro() throws IOException, CensusGeneralException, Exception
    {
        int[] keys;
        this.filePath = conf.getFilePath();

        Hashtable<String, IndexedFile> ht = null;

	switch(conf.getSpectrumFormat())
	{
	    case Configuration.MS_FILE_FORMAT: 
		ht = createIndexedFiles(filePath, CensusConstants.MS1_FILE);
		break;
	    
	    case Configuration.MZXML_FILE_FORMAT:                                
		ht = createIndexedFiles(filePath, CensusConstants.MZXML);
		break;

	    default:
		break;
	}

        if( !filePath.endsWith(File.separator) )
            filePath += File.separator;
                
        IndexedFile iFile=null;
        BufferedOutputStream out = null;
        PrintStream p = null;
        
        long startTime = System.currentTimeMillis();
       
        try
        {                
            /******************************************************************
             *  Read DTASelect.txt file to find spectrum range for each peptide
             ******************************************************************/
            //TIntLongHashMap index;            
            System.out.print("Parsing " + conf.getIdFileName() + "...");
            
            if(null != progress)
                progress.addMessage("\nParsing Identified Peptides...");

            if(null != progress)
                progress.addMessage("\ndone.");
            
            IsotopeReader isoReader = null;
            if(null != isotopeFile)
                isoReader = new IsotopeReader(isotopeFile);                        
            else 
                isoReader = new IsotopeReader(this.confRootEle);                        

            IdentificationReader idReader = BaseIdentificationReader.getIdentificationInst(isoReader);                        
            System.out.println("done.");
            
            SpecRangeGenerator rangeGen = null;
            
            File dtaFile = new File(filePath + "DTASelect.txt");

	    if(conf.isPrintLog())
		p = new PrintStream( new FileOutputStream(filePath + "progress.log") );
            
            //System.out.println(filePath + " " + dtaFile + " " + dtaFile.exists());
            
            if(dtaFile.exists()) {                
                if(conf.getIdFileName().endsWith("txt"))            
                {
                    System.out.print("Parsing DTASelect.txt...");
                    if(null != progress)
                        progress.addMessage("\nParsing DTASelect.txt...");
                }

                rangeGen = SpecRangeGenerator.getSpecRangeGenerator(idReader);
    //            SpecRangeGenerator rangeGen = new SpecRangeGenerator(this.filePath + this.dtaSelectFile, idReader.isVersion2(), idReader.getConfidence());
                //SpecRangeGenerator rangeGen = new SpecRangeGenerator(this.filePath + this.dtaSelectFile, idReader);
                //SpecRangeGenerator rangeGen = null; 

                if(conf.getIdFileName().endsWith("txt"))            
                {
                    System.out.println("done.");
                    if(null != progress)
                        progress.addMessage("\ndone.");
                }                                
            } else 
            {
                rangeGen = new SpecRangeGenerator();
             
            }
            Element rootEle = this.createXmlChroHeader(1);
            ElementComposition element;
            ElementComposition totalElement;

            int keyIndex=-1;
            //int start;
            //int last;

            double sampleStartMass;
            double sampleEndMass;
            double refStartMass;
            double refEndMass;

            Element proteinEle=null;
            Element peptideEle=null;
            
            Iterator<Protein> pitr = idReader.getProteins(); //need to run to calculate redundnat peptides
            int redundantPeptideNum = idReader.getTotalPeptideNumber();
            double percent = 0.0;
            double eachSeg = 100.0/redundantPeptideNum;
            int pepCount=0;

	    double medianRatio = -1;
	    if(conf.isCalculateEnrich()) {
		IdentificationReader tempReader = BaseIdentificationReader.getIdentificationInst(isoReader);                        
		medianRatio = getMedianN15Ratio(tempReader, isoReader, ht);

		Element enrichmentEle = new Element("n15_enrich_median");
		enrichmentEle.setText( String.valueOf(medianRatio) );
		rootEle.addContent(enrichmentEle);
	    }

	    ArrayList<Protein> aList = new ArrayList<Protein>();

            for (Iterator<Protein> itr = pitr; itr.hasNext(); ) {
                Protein protein = itr.next();
                
                proteinEle = new Element("protein");
                proteinEle.setAttribute("locus", protein.getLocus());
                proteinEle.setAttribute("seq_ct", protein.getSeqCount());
                proteinEle.setAttribute("spec_ct", protein.getSpectrumCount());
                proteinEle.setAttribute("seq_cov", protein.getSeqCoverage());
                proteinEle.setAttribute("length", protein.getLength());
                proteinEle.setAttribute("molwt", protein.getMolWt());
                proteinEle.setAttribute("pi", protein.getPI());
                proteinEle.setAttribute("val", protein.getValidation());

		try {
		    proteinEle.setAttribute("desc", protein.getDescription());
		} catch (org.jdom.IllegalDataException ide) {
		    proteinEle.setAttribute("desc", StringUtil.removeIsoControlChar(protein.getDescription()) );
		}

                for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); ) 
                {
                    Peptide peptide = pepItr.next();                    
                    pepCount++;

                    //trim additional characters from peptide sequence at both ends
                    String pepSequence = peptide.getSequence();

                    char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();
                    //element = new ElementComposition(peptide.getSequence().substring(2, peptide.getSequence().length()-2), isoReader.getIsotope()); 
                    
                    element = new ElementComposition(ch, 0, ch.length, isoReader.getIsotope());

		    try {
			element.calculate();
		    } catch (InvalidAAException invE)
		    {
			System.out.println("Not Quantifiable peptide : " + pepSequence);
			percent += eachSeg;

			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);
			}
			continue;
		    }

                    if(!element.isQuantifiable())
                    {
                        System.out.print("\nError : ");
                        System.out.println(pepSequence + " is not quantifiable.");                        
            
                        percent += eachSeg;
                        System.out.print(pepCount);
                        System.out.print("/");
                        System.out.print(redundantPeptideNum);
                        System.out.print(" peptides, ");
                        System.out.print((int)percent);
                        System.out.print(" % is complete\r");

                        
                        if(null != progress)
                        {
                            progress.addMessage("\nError : ");
                            progress.addMessage(pepSequence);
                            progress.addMessage(" is not quantifiable.\n");
			    progress.setProgress((int)percent);
                        }
                        
                        continue;
                    }
                    
                   //System.out.println( keyIndex, iFile, samIsoArr, refIsoArr, range) );    

		    String fileName=peptide.getFileName();
		    fileName = cleanFileName(fileName);

		    switch(conf.getSpectrumFormat())
		    {
			case Configuration.MS_FILE_FORMAT: 
			    fileName += ".ms1";
			    break;

			case Configuration.MZXML_FILE_FORMAT:
                            fileName += ".mzXML";
			    break;

			default:
			    break;
		    }

		    int scanNum = Integer.parseInt(peptide.getScanNum());
                    iFile = ht.get(filePath + fileName);

                    if(null == iFile)
                    {
			iFile = ht.get(filePath + fileName.substring(1));

			if(null == iFile) {
			    System.out.println("Error : cannot find the file " + fileName);
			    System.exit(0);
			}
                    //    throw new IOException("Error : cannot find the file " + filePath + fileName);
                    }

                    int chargeState = Integer.parseInt(peptide.getChargeState());
                    
                    IsotopeDist sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    
                    IsotopeDist refDist = null;

/*
		    System.out.println("===========" + element.getElementSampleArr());

		    //print element composition
		    System.out.println("sample===========");
		    int[] tempArr = element.getElementSampleArr();
		    for(int t : tempArr)
			System.out.println(t);
		    System.out.println("ref===========");
		    tempArr = element.getElementRefArr();
		    for(int t : tempArr)
*/		    


                    peptideEle = this.createXmlChroPeptideTitle(true, peptide); //true is for full scan

		
			refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);

			/*
			int[] eleArr = element.getElementSampleArr();
			for(int ii:eleArr)
			    System.out.println("sarr===========" + ii);
			eleArr = element.getElementRefArr();
			    System.out.println("===========");
			    */
			    /*
			double[] dmlist = sampleDist.getHighMassList();
			for(double dd:dmlist) {
			    if(dd<=0)
				continue;
			    System.out.println("sam mass :\t" + dd);
			}

			    System.out.println("===========");
//			for(int ii:eleArr)
//			    System.out.println("rarr===========" + ii);
			dmlist = refDist.getHighMassList();
			for(double dd:dmlist) {
			    if(dd<=0)
				continue;
			    System.out.println("ref mass :\t" + dd);
			}
			*/

		    if(conf.isCalculateEnrich()) {
			double startEnrich = conf.getStartEnrich();
			double endEnrich = conf.getEndEnrich();
			double enrichmentMaxDeviation = conf.getEnrichmentMaxDeviation();

			refDist = new edu.scripps.pms.census.util.N15EnrichmentCalc(element.getElementRefArr(), element.getModShift(), medianRatio, startEnrich, endEnrich, enrichmentMaxDeviation, iFile, scanNum, chargeState);
			peptideEle.setAttribute("enrichment", String.valueOf(refDist.getFixedEnrichRatio()));                        
			peptideEle.setAttribute("calc_enrich", String.valueOf(refDist.getBestEnrichRatio()));                        
			peptideEle.setAttribute("enrich_corr", String.valueOf(refDist.getEnrichCorr()));                        

	//	System.out.println("enrichment" + refDist.getFixedEnrichRatio());
	//	System.out.println("calc_enrich" + refDist.getBestEnrichRatio());
	//	System.out.println("enrich_corr" + refDist.getEnrichCorr()); 
            
		    }else {
			refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);
			peptideEle.setAttribute("enrichment", String.valueOf(conf.getEnrichment()));                        
		    }

                    conf.setCalcSamAvgMass(sampleDist.getAvgMass());
                    conf.setCalcRefAvgMass(refDist.getAvgMass());
		    peptideEle.setAttribute("lightStartMass", String.valueOf(sampleDist.getStartMass()));  
		    peptideEle.setAttribute("heavyStartMass", String.valueOf(refDist.getStartMass()));
		    peptideEle.setAttribute("lightAvgMass", String.valueOf(conf.getCalcSamAvgMass()));  
		    peptideEle.setAttribute("heavyAvgMass", String.valueOf(conf.getCalcRefAvgMass()));

		    //String fileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf(".")+1) + "ms1";
                    StringBuffer rangeKey = new StringBuffer();                                        
                    rangeKey.append(protein.getLocus());
                    rangeKey.append(fileName);
                    rangeKey.append(peptide.getSequence().substring(2, peptide.getSequence().length()-2));                   
                                       
                    SpecRange range = rangeGen.getSpecRange( rangeKey.toString() );                    
                    //sb.append("\tStartScan\tEndScan\tDTAPeakStart\tDTAPeakEnd\n");
                    
                    /*
		    if(null==range)
		    {
			System.out.println("Error : cannot find peptide in DTASelect.txt file " + protein.getLocus() + " " + peptide.getSequence());
                        
                        if(null != progress)
                        {
                            progress.addMessage("\nError : cannot find peptide in DTASelect.txt file " + protein.getLocus() + " " + peptide.getSequence());
                        }
                        
			continue;	
		    }*/
                    
                    
		    if(null==range)
		    {
                        int tmpScanNum = Integer.parseInt(peptide.getScanNum());
                        range = new SpecRange( tmpScanNum, tmpScanNum );                        
                        peptideEle.setAttribute("start_scan", peptide.getScanNum());
                        peptideEle.setAttribute("end_scan", peptide.getScanNum());
                    }
                    else
                    {
                        peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                        peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));                        
                    }

                    peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                    peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));
//		    int scanNum = Integer.parseInt(peptide.getScanNum());
               
                    keys = iFile.getKeys();
                    keyIndex = Arrays.binarySearch(keys, scanNum);

                    if(keyIndex<0) //Cannot find index
                        keyIndex=-(++keyIndex); //Math.abs(++keyIndex);

                    if(keyIndex>=keys.length)
                        keyIndex--;
                            
                    Element chro = new Element("chro");


		    if( conf.isHighRes() )
		    {
			double[] samIsoArr = sampleDist.getHighMassList();
			double[] refIsoArr = null; //refDist.getHighMassList();

			for(int i=0;i<samIsoArr.length;i++)
			{
//			    System.out.println("s before=======================" + samIsoArr[i]);
			    samIsoArr[i] = (samIsoArr[i]+chargeState*PROTON_MASS)/chargeState;
//			    System.out.println("sample :\t" + samIsoArr[i] + "\t" + sampleDist.getRelabun()[i]);
			}

			if(refDist instanceof N15EnrichmentCalc)
			{
			    refIsoArr = refDist.getBestEnrichMassArr();

			    //System.out.println("------------------" + refIsoArr);
			}
			else if(refDist instanceof IsotopeDist) {
			    refIsoArr = refDist.getHighMassList();
			    for(int i=0;i<refIsoArr.length;i++)
			    {
//					    System.out.println("r before=======================" + refIsoArr[i]);
				refIsoArr[i] = (refIsoArr[i]+chargeState*PROTON_MASS)/chargeState;

//				System.out.println("ref :\t " + refIsoArr[i] + "\t" + refDist.getRelabun()[i]);
			    }
			}

                        //boolean isProline = true;
                        //double prolineMassDiff = 6.0138;
                        
                        //System.out.println(pepSequence);
                        
                        if(conf.isUseProline() && pepSequence.substring(2, pepSequence.length()-2).contains("P"))
                        //if(conf.isUseProline() && pepSequence.substring(2, pepSequence.length()-2).contains("E") && !pepSequence.substring(2, pepSequence.length()-2).contains("P"))
                        {
			    int prolineCount = conf.getProlineCount();

			    if(prolineCount>1) {
				int tmpCount=0;
				char[] chArr = pepSequence.substring(2, pepSequence.length()-2).toCharArray();
				
				for(char c:chArr) {
				    if(c == 'P') 
					tmpCount++;
				}

				if(tmpCount>1)
				    prolineCount = 2;
				else 
				    prolineCount = 1;
			    }
			   

                            //double[] refProlineIsoArr = new double[refIsoArr.length*2];
                            double[] refProlineIsoArr = new double[refIsoArr.length*(prolineCount+1)];
                            
                            for(int i=0;i<refIsoArr.length;i++)
                            {
                                refProlineIsoArr[i] = refIsoArr[i];
                            }
                           
			    switch(prolineCount)
			    {
				case 1:
				    for(int i=refIsoArr.length;i<refProlineIsoArr.length;i++)
				    {
					refProlineIsoArr[i] = refIsoArr[i-refIsoArr.length] + Configuration.PROLINE_SHIFT/chargeState;
				    }
				    break;
				case 2:
				    for(int i=refIsoArr.length;i<refIsoArr.length*2;i++)
				    {
					refProlineIsoArr[i] = refIsoArr[i-refIsoArr.length] + Configuration.PROLINE_SHIFT/chargeState;
					refProlineIsoArr[i+refIsoArr.length-1] = refIsoArr[i-refIsoArr.length] + 2*Configuration.PROLINE_SHIFT/chargeState;				    
				    }
					
				    break;
			    }
                           
                            chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, samIsoArr, refProlineIsoArr, range) );    
                        } else
                        {
                            chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, samIsoArr, refIsoArr, range) );    
                        }
		    }
		    else
		    {
			sampleStartMass = (sampleDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
			sampleEndMass = (sampleDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;
			refStartMass = (refDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
			refEndMass = (refDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;

			TDoubleArrayList refAdditionalMassArr = new TDoubleArrayList();
			
                        if(conf.isUseProline() && pepSequence.substring(2, pepSequence.length()-2).contains("P"))
                        {
			    int prolineCount = conf.getProlineCount();

			    if(prolineCount>1) {
				int tmpCount=0;
				char[] chArr = pepSequence.substring(2, pepSequence.length()-2).toCharArray();
				
				for(char c:chArr) {
				    if(c == 'P') 
					tmpCount++;
				}

				if(tmpCount>1)
				    prolineCount = 2;
				else 
				    prolineCount = 1;
			    }			   
                                
			    switch(prolineCount)
			    {
				case 1:
				    refAdditionalMassArr.add(refStartMass + Configuration.PROLINE_SHIFT/chargeState);
				    refAdditionalMassArr.add(refEndMass + Configuration.PROLINE_SHIFT/chargeState);
				    break;

				case 2: //2 or more                                    
				    refAdditionalMassArr.add(refStartMass + Configuration.PROLINE_SHIFT/chargeState);
				    refAdditionalMassArr.add(refEndMass + Configuration.PROLINE_SHIFT/chargeState);
				    refAdditionalMassArr.add(refStartMass + 2*Configuration.PROLINE_SHIFT/chargeState);
				    refAdditionalMassArr.add(refEndMass + 2*Configuration.PROLINE_SHIFT/chargeState);

				    break;
			    }
                          
                            conf.setAddtionalRefMassArr(refAdditionalMassArr.toNativeArray());
                           // System.out.println(prolineCount + " " + Configuration.PROLINE_SHIFT + " " +chargeState + " " + (Configuration.PROLINE_SHIFT/chargeState));
                           // System.out.println("=" + refStartMass + " " + refEndMass + " " + massTolerance);
                            
                           // for(double d : refAdditionalMassArr.toNativeArray())
                           //     System.out.println(d);
                            
                            chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, sampleStartMass, sampleEndMass, refStartMass, refEndMass, range) ); 

                        } else {
                            //System.out.println("===");
			    chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, sampleStartMass, sampleEndMass, refStartMass, refEndMass, range) );
			}
		    }
/*
System.out.println( " " + peptide.getSequence());
System.out.println( " " + peptide.getChargeState());
System.out.println( " " + peptide.getScanNum());
System.exit(0);
*/
                    peptideEle.addContent(chro);
                    proteinEle.addContent(peptideEle);

                    percent += eachSeg;
                    
                    System.out.print(pepCount);
                    System.out.print("/");
                    System.out.print(redundantPeptideNum);
                    System.out.print(" peptides, ");
                    System.out.print((int)percent);
                    System.out.print(" % is complete\r");

		    if(conf.isPrintLog()) {
			p.println((int)percent + "\t" + pepCount + "\t" + redundantPeptideNum);
		    }
                    
                    if(null != progress)
                    {
			progress.setProgress((int)percent);
                    }
                }

                if(proteinEle.getChildren().size()>0) {
		    
		    Element redunEle = new Element("redundant");

		    int rPepCount=0;

		    for(Iterator<Protein> rItr=aList.iterator();rItr.hasNext(); ) {
			rPepCount++;
			Protein rp = rItr.next();

			Element rpEle = new Element("protein");
			rpEle.setAttribute("locus", rp.getLocus());
			rpEle.setAttribute("seq_ct", rp.getSeqCount());
			rpEle.setAttribute("spec_ct", rp.getSpectrumCount());
			rpEle.setAttribute("seq_cov", rp.getSeqCoverage());
			rpEle.setAttribute("length", rp.getLength());
			rpEle.setAttribute("molwt", rp.getMolWt());
			rpEle.setAttribute("pi", rp.getPI());
			rpEle.setAttribute("val", rp.getValidation());

			try {
			    rpEle.setAttribute("desc", rp.getDescription());
			} catch (org.jdom.IllegalDataException ide) {
			    rpEle.setAttribute("desc", StringUtil.removeIsoControlChar(rp.getDescription()) );
			}

			redunEle.addContent(rpEle);
		    }

		    if(rPepCount>0)
			proteinEle.addContent(redunEle);

                    rootEle.addContent(proteinEle);
		    aList.clear();
		} else {
		    aList.add(protein);
	//	    set.add(protein.getLocus());
		}
            }
           
            Document doc = new Document(rootEle);
            OutputStream os = new FileOutputStream(filePath + "census_chro.xml");
            XMLOutputter outputter = new XMLOutputter();
	    outputter.setFormat(Format.getPrettyFormat());
            outputter.output(doc, os);
            os.close();

            System.out.println("\n100% complete");
        }
        catch (IOException e)
        {
            System.out.println("IO Error while generating msms chro file : " + e);
            e.printStackTrace();
            throw new IOException(e.toString());
        }
        catch (Exception e)
        {
            System.out.println("Error while generating msms chro file : " + e);
            e.printStackTrace();
            throw new Exception(e.toString());
        }
        finally
        {
            if(null != p)
                p.close();
            
            if(null != out)
                out.close();

            //Close all random files
            for (Enumeration e = ht.keys(); e.hasMoreElements(); ) 
            {
                iFile = ht.get(e.nextElement());

                if(null != iFile)
                    iFile.close();
            }

        }

    
	System.out.println( (System.currentTimeMillis() - startTime)*0.001 + " seconds taken");
    }    
    
    
    public void createFullscanXmlChro_old() throws IOException, CensusGeneralException, Exception
    {
        int[] keys;
        this.filePath = conf.getFilePath();

	
        Hashtable<String, IndexedFile> ht = null;

	switch(conf.getSpectrumFormat())
	{
	    case Configuration.MS_FILE_FORMAT: 
		ht = createIndexedFiles(filePath, CensusConstants.MS1_FILE);
		break;
	    
	    case Configuration.MZXML_FILE_FORMAT:
		ht = createIndexedFiles(filePath, CensusConstants.MZXML);
		break;

	    default:
		break;
	}

        if( !filePath.endsWith(File.separator) )
            filePath += File.separator;
                
        IndexedFile iFile=null;
        BufferedOutputStream out = null;
        PrintStream p = null;
        
        long startTime = System.currentTimeMillis();
       
        try
        {    
            /******************************************************************
             *  Read DTASelect.txt file to find spectrum range for each peptide
             ******************************************************************/
            //TIntLongHashMap index;

            System.out.print("Parsing DTASelect-filter.txt...");

            IsotopeReader isoReader = null;
          
            if(null != isotopeFile)
                isoReader = new IsotopeReader(isotopeFile);                        
            else 
                isoReader = new IsotopeReader(this.confRootEle);                        

            
            if(null != progress)
                progress.addMessage("\nParsing DTASelect-filter.txt...");
          
            IdentificationReader idReader = BaseIdentificationReader.getIdentificationInst(isoReader);
            int redundantPeptideNum = idReader.getTotalPeptideNumber();

            
            System.out.println("done.");
            
            if(null != progress)
                progress.addMessage("\ndone.");
            
            
            SpecRangeGenerator rangeGen = null;
            
            File dtaFile = new File(filePath + "DTASelect.txt");
            
            if(dtaFile.exists()) {                
                System.out.print("Parsing DTASelect.txt...");
                if(null != progress)
                    progress.addMessage("\nParsing DTASelect.txt...");

                //SpecRangeGenerator rangeGen = new SpecRangeGenerator(this.filePath + this.dtaSelectFile, idReader.isVersion2(), idReader.getConfidence());
                rangeGen = SpecRangeGenerator.getSpecRangeGenerator(idReader);
                //SpecRangeGenerator rangeGen = null; 
                //Hashtable tempht = rangeGen.getTable();
                System.out.println("done.");
                if(null != progress)
                    progress.addMessage("\ndone.");

            } else {
                rangeGen = new SpecRangeGenerator();
            }
            
            
            
            //increase status bar

            double percent = 0.0;
            double eachSeg = 100.0/redundantPeptideNum;
            int pepCount=0;
                         
            Protein protein;
            Peptide peptide;
            
            Element rootEle = this.createXmlChroHeader(1);
            ElementComposition element;
            ElementComposition totalElement;

            int keyIndex=-1;
            //int start;
            //int last;

            double sampleStartMass;
            double sampleEndMass;
            double refStartMass;
            double refEndMass;

            Element proteinEle=null;
            Element peptideEle=null;
            
            for (Iterator<Protein> itr = idReader.getProteins(); itr.hasNext(); ) {
                protein = itr.next();

                proteinEle = new Element("protein");
                proteinEle.setAttribute("locus", protein.getLocus());
                proteinEle.setAttribute("seq_ct", protein.getSeqCount());
                proteinEle.setAttribute("spec_ct", protein.getSpectrumCount());
                proteinEle.setAttribute("seq_cov", protein.getSeqCoverage());
                proteinEle.setAttribute("length", protein.getLength());
                proteinEle.setAttribute("molwt", protein.getMolWt());
                proteinEle.setAttribute("pi", protein.getPI());
                proteinEle.setAttribute("val", protein.getValidation());

		try {
		    proteinEle.setAttribute("desc", protein.getDescription());
		} catch (org.jdom.IllegalDataException ide) {
		    proteinEle.setAttribute("desc", StringUtil.removeIsoControlChar(protein.getDescription()) );
		}

                for (Iterator<Peptide> pepItr = protein.getPeptides(); pepItr.hasNext(); ) 
                {
                    peptide = pepItr.next();
                    pepCount++;
                        
                    //trim additional characters from peptide sequence at both ends
                    String pepSequence = peptide.getSequence();
                    char[] ch = pepSequence.substring(2, peptide.getSequence().length()-2).toCharArray();
                    
                    element = new ElementComposition(ch, 0, ch.length, isoReader.getIsotope());

		    try {
			element.calculate();
		    } catch (InvalidAAException invE)
		    {
			System.out.println("Not Quantifiable peptide : " + pepSequence);
			percent += eachSeg;

			if(null != progress)
			{
			    ChroProgressDialog.addMessageWithLine(progress, "Not Quantifiable peptide : " + pepSequence);
			    progress.setProgress((int)percent);
			}
			continue;
		    }

                    if(!element.isQuantifiable())
                    {
                        System.out.print("\nError : ");
                        System.out.println(pepSequence + " is not quantifiable.");                        
            
                        percent += eachSeg;
                        System.out.print(pepCount);
                        System.out.print("/");
                        System.out.print(redundantPeptideNum);
                        System.out.print(" peptides, ");
                        System.out.print((int)percent);
                        System.out.print(" % is complete\r");
                        
                        
                        if(null != progress)
                        {
                            progress.addMessage("\nError : ");
                            progress.addMessage(pepSequence);
                            progress.addMessage(" is not quantifiable.\n");
			    progress.setProgress((int)percent);
                        }
                        
                        continue;
                    }
                    
                    peptideEle = this.createXmlChroPeptideTitle(true, peptide); //true is for full scan

		    //String fileName = peptide.getFileName().substring(0, peptide.getFileName().indexOf(".")+1) + "ms1";

		    String fileName=peptide.getFileName();
		    for(int i=0;i<3;i++)
			fileName = fileName.substring(0, fileName.lastIndexOf("."));

                    
                    StringBuffer rangeKey = new StringBuffer();                                        
                    rangeKey.append(protein.getLocus());
                    rangeKey.append(fileName);
                    rangeKey.append(peptide.getSequence().substring(2, peptide.getSequence().length()-2));                    
                    
                    //System.out.println(rangeKey);
                    
                    SpecRange range = rangeGen.getSpecRange( rangeKey.toString() );                    
                    //sb.append("\tStartScan\tEndScan\tDTAPeakStart\tDTAPeakEnd\n");
                    
                    /*
		    if(null==range)
		    {
			System.out.println("Error : cannot find peptide in DTASelect.txt file " + protein.getLocus() + " " + peptide.getSequence());
                        
                        if(null != progress)
                        {
                            progress.addMessage("\nError : cannot find peptide in DTASelect.txt file " + protein.getLocus() + " " + peptide.getSequence());
                        }
                        
			continue;	
		    }*/
                    
                    
		    if(null==range)
		    {
                        int tmpScanNum = Integer.parseInt(peptide.getScanNum());
                        range = new SpecRange( tmpScanNum, tmpScanNum );                        
                        peptideEle.setAttribute("start_scan", peptide.getScanNum());
                        peptideEle.setAttribute("end_scan", peptide.getScanNum());
                    }
                    else
                    {
                        peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                        peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));                        
                    }

                    peptideEle.setAttribute("start_scan", String.valueOf(range.getMin()));
                    peptideEle.setAttribute("end_scan", String.valueOf(range.getMax()));
		    int scanNum = Integer.parseInt(peptide.getScanNum());
                
		    switch(conf.getSpectrumFormat())
		    {
			case Configuration.MS_FILE_FORMAT: 
			    fileName += ".ms1";


			    //if(keyIndex<0) //Cannot find index
			    //    keyIndex=Math.abs(++keyIndex);                    

			    //start = keyIndex - scanBefore;
			    //start = (start<0)?0:start;

			    //last = keyIndex + scanAfter;
			    //last = (last>=keys.length)?keys.length-1:last;

			    //index = iFile.getMsIndex();

			    break;

			case Configuration.MZXML_FILE_FORMAT:
                            fileName += ".mzXML";
			    //ht = createIndexedFiles(filePath, CensusConstants.MZXML);
			    break;

			default:
			    break;
		    }

                    iFile = ht.get(filePath + fileName);

                    //iFile = ht.get(fileName);
                    if(null == iFile)
                    {
                        System.out.println("Error : cannot find the file " + fileName);
                        throw new IOException("Error : cannot find the file " + filePath + fileName);
                        //System.exit(0);
                    }

                    keys = iFile.getKeys();
                    keyIndex = Arrays.binarySearch(keys, scanNum);

                    if(keyIndex<0) //Cannot find index
                        keyIndex=-(++keyIndex); //Math.abs(++keyIndex);

                    if(keyIndex>=keys.length)
                        keyIndex--;
                            
                    Element chro = new Element("chro");

                    IsotopeDist sampleDist = new IsotopeDist(element.getElementSampleArr(), element.getModShift(), true);                    
                    IsotopeDist refDist = new IsotopeDist(element.getElementRefArr(), element.getModShift(), false);

                    int chargeState = Integer.parseInt(peptide.getChargeState());
            //        System.out.println("mass range==>>" + sampleDist.getStartMass() + "\t" + sampleDist.getEndMass() + "\t" + refDist.getStartMass()  + "\t" + refDist.getEndMass());
            //        System.out.println("mass range==>>" + sampleStartMass + "\t" + sampleEndMass + "\t" + refStartMass  + "\t" + refEndMass);
                                
		    if( conf.isHighRes() )
		    {
			double[] samIsoArr = sampleDist.getHighMassList();
			double[] refIsoArr = refDist.getHighMassList();
        
			for(int i=0;i<samIsoArr.length;i++)
			    samIsoArr[i] = (samIsoArr[i]+chargeState*PROTON_MASS)/chargeState;
			
			for(int i=0;i<refIsoArr.length;i++)
			    refIsoArr[i] = (refIsoArr[i]+chargeState*PROTON_MASS)/chargeState;
                        
			chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, samIsoArr, refIsoArr, range) );
		    }
		    else
		    {
			sampleStartMass = (sampleDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
			sampleEndMass = (sampleDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;

			refStartMass = (refDist.getStartMass() + chargeState*PROTON_MASS) / chargeState - massTolerance;
			refEndMass = (refDist.getEndMass() + chargeState*PROTON_MASS) / chargeState + massTolerance;
		   
		   //System.out.println("=======================" + keys[keyIndex]);
			chro.setText( CalcUtil.calculateFullMS( keyIndex, iFile, sampleStartMass, sampleEndMass, refStartMass, refEndMass, range) );
		    }

                    peptideEle.addContent(chro);
                    proteinEle.addContent(peptideEle);

                    percent += eachSeg;

                    System.out.print(pepCount);
                    System.out.print("/");
                    System.out.print(redundantPeptideNum);
                    System.out.print(" peptides, ");
                    System.out.print((int)percent);
                    System.out.print(" % is complete\r");
                    
                    if(null != progress)
                    {
			progress.setProgress((int)percent);
                    }
                }

                if(proteinEle.getChildren().size()>0)
                    rootEle.addContent(proteinEle);

            }
           
            Document doc = new Document(rootEle);
            OutputStream os = new FileOutputStream(filePath + "census_chro.xml");
            XMLOutputter outputter = new XMLOutputter();
	    outputter.setFormat(Format.getPrettyFormat());
            outputter.output(doc, os);
            os.close();

            System.out.println("\n100% complete");
        }
        catch (IOException e)
        {
            System.out.println("IO Error while generating msms chro file : " + e);
            e.printStackTrace();
            throw new IOException(e.toString());
        }
        catch (Exception e)
        {
            System.out.println("Error while generating msms chro file : " + e);
            e.printStackTrace();
            throw new Exception(e.toString());
        }
        finally
        {
            if(null != p)
                p.close();
            
            if(null != out)
                out.close();

            //Close all random files
            for (Enumeration e = ht.keys(); e.hasMoreElements(); ) 
            {
                iFile = ht.get(e.nextElement());

                if(null != iFile)
                    iFile.close();
            }

        }

     
    }    

    public static void setConfiguration(Configuration con) {
	conf = con;
    }
}
